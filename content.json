[{"title":"webgl-coordinate","date":"2023-07-18T05:48:42.000Z","path":"webgl-coordinate/","text":"WebGL coordinates tips Fragment shader only accepts a normalized and left-handed cube. Each axis begins from -1 to 1 and any contents out of it will be cut out. As to lefted-handed, it means positive z axis points into the screen and points with bigger z will be in the back of points with smaller z. So it is the vertex shader’s responsibility to output positions within this normalized cube with any way. We(vertex shader) usually take 4 steps to output this normalized cube: modeling in local coordinate system transformation with model matrix(translate(),rotate(),scale()) to get positions in world coordinates set up the camara with view matrix(lookAt()) to get positions in view coordinate projection(orthogonal or perspective) with projection matrix(setOrtho(), setPerspective()) to get positions in clipping coordinate(i.e. the normalized cube) For step 1 ~ step 3, we use right-handed coordinate in general. In step 4, positions are transformed from right-handed to left-handed clipping coordinate. From now on, WebGL takes in charge. It maps positions in the normalized cube(positions out of it will be cut out) to the cavans, using z-value(usually be re-mapped from (-1, 1) to (0, 1), i.e. 0 represents the device’s screen) for depth test:","tags":[{"name":"webgl","slug":"webgl","permalink":"http://tomwang1013.github.io/tags/webgl/"}]},{"title":"webpack-hot-loader-react","date":"2020-12-16T12:27:10.000Z","path":"webpack-hot-loader-react/","text":"基本方式对webpack的hot loader机制，基本用法很简单，只需要把hot开启： 1234devServer: &#123; hotOnly: true, // hot: true&#125; 然后以用module.hot.accept在根组件做重新渲染就行了： 1234567891011// App.tsximport React from &quot;react&quot;;function App() &#123; return ( &lt;div className=&#x27;hello&#x27;&gt; Hello, webpack! &lt;/div&gt; );&#125;;export default App; 1234567891011121314151617181920// index.tsximport React from &#x27;react&#x27;;import ReactDom from &#x27;react-dom&#x27;;import App from &#x27;./App&#x27;;const render = (Component: () =&gt; JSX.Element) =&gt; &#123; ReactDom.render( &lt;Component /&gt;, document.getElementById(&#x27;app&#x27;) );&#125;render(App);if (module.hot) &#123; module.hot.accept([&#x27;./App&#x27;], function () &#123; const App = require(&#x27;./App&#x27;).default; render(App); &#125;)&#125; 利用react-hot-loader保持组件状态上面的方式有个问题：组件hot load重新渲染之后状态丢失了，这个时候可以使用react-hot-loader这个包，用法如下，需要改动几个地方： 123456// 1. babel.config.js&#123; &quot;plugins&quot;: [ &quot;react-hot-loader/babel&quot; ],&#125; 123456789101112// 2. App.tsximport React from &quot;react&quot;;import &#123; hot &#125; from &#x27;react-hot-loader/root&#x27;function App() &#123; return ( &lt;div className=&#x27;hello&#x27;&gt; Hello, webpack! &lt;/div&gt; );&#125;;export default hot(App); 1234567// 3. package.json&#123; &quot;dependencies&quot;: &#123; &quot;react-hot-loader&quot;: &quot;^4.13.0&quot;, &quot;@hot-loader/react-dom&quot;: &quot;^17.0.1&quot; &#125;&#125; 12345678// 4. webpack.config.js&#123; resolve: &#123; alias: &#123; &#x27;react-dom&#x27;: &#x27;@hot-loader/react-dom&#x27; &#125; &#125;&#125;","tags":[]},{"title":"两个新API-requestIdleCallback和requestPostAnimationFrame的介绍","date":"2020-04-29T06:22:50.000Z","path":"requestIdleCallback-requestPostAnimationFrame/","text":"新的html5中有一个以request开头的方法：*requestAnimationFrame(raf)*，这个大家都基本用过，至少听过：用于在渲染(rendering, i.e. style recalculation, layout change等)之前做一些事，一般是更新CSS或DOM。 最近又出来两个方法(可能还在提案中)，也是以request开头，一个是rquestIdelCallback(后面简称ric), 一个是requestPostAnimationFrame(后面简称rpaf)。这里我们就要简单地介绍一下它们：它们的调用时机及主要功能。 在前一篇关于事件循环(event loop)的文章中，其实很我们已经说到了raf和ric的执行时机： event loop2 可以看到，ric是在浏览器空闲的时候，即task queue为空的时候执行的，这相当于是安排了一个低优先级的任务。一般来说，不建议在ric中修改css和dom，因为这时候浏览器可能已经做完了rendering，如果在ric中修改css和dom的话，那下一个task处理中对layout的读取(如clientWidth等)将触发强制layout同步(Forced Synchronous Layout)，带来很大的性能问题。前面说过，这些事情应该放在raf中进行。 从名字可以猜到，正如raf是在rendering之前执行，rpaf是在rendering之后执行(post)，并且是正好在rendering之后，中间没有任何打扰！ 为什么需要rpaf？ 有两个原因： 更早为下一次页面渲染做准备 一般来说我们在raf中来更新dom及css来为下一次渲染做准备，但是如果raf中的代码耗时过长，页面可能无法在下一次显卡更新之前(vsync)及时完成渲染并将渲染结果发送到显卡上，毕竟从上图中可以看到，raf的执行时机是在一次事件循环(也叫frame)的后期。 rpaf提供了一种可能，使得我们可以在上一帧渲染完之后马上为下一帧做准备，不会有任何任务来打扰，这样更有可能将渲染结果及时呈现出来 阻止强制layout更新(forced relayout) 为了保证性能，我们始终要避免编写导致forced layout的代码(即先改变css然后马上读取dom的size)。但是，先阶段浏览器还没有提供一种机制来使得代码在页面完全干净之后运行。下面是一种可能的方法，但是仍然无法百分百保证： 1234567addEventListener(&quot;message&quot;, event =&gt; &#123; // Query layout information here.&#125;);requestAnimationFrame(() =&gt; &#123; postMessage(&quot;*&quot;, &quot;&quot;);&#125;); 因为可能还会有其他事件在message事件之前被处理(如timeout，input等)。由于rpaf能保证立即在rendering之后、在所有其他代码之前执行，所以在rpaf中查询dom的size信息，所以这种查询不会引起forced relayout 参考： https://github.com/WICG/requestPostAnimationFrame/blob/master/explainer.mdhttps://html.spec.whatwg.org/multipage/webappapis.html#processing-model-8https://developers.google.com/web/updates/2015/08/using-requestidlecallback","tags":[{"name":"html5","slug":"html5","permalink":"http://tomwang1013.github.io/tags/html5/"},{"name":"event loop","slug":"event-loop","permalink":"http://tomwang1013.github.io/tags/event-loop/"}]},{"title":"event-and-drawing","date":"2020-04-18T06:17:44.000Z","path":"event-and-drawing/","text":"深入理解浏览器event loop基本定义浏览器要做非常多的事情：解析html、渲染、用户交互(如点击)、网络请求等，它使用event loop来统一协调这些事务。每个agent(如window, web worker, service worker)都有一个event loop。 每个event loop都有一个或多个task queue, 它是task的集合(set of tasks)。每个task queue和一个或多个task source相关联，因为task来自于某个task source。 Essentially, task sources are used within standards to separate logically-different types of tasks, which a user agent might wish to distinguish between. Task queues are used by user agents to coalesce task sources within a given event loop. For example, a user agent could have one task queue for mouse and key events (to which the user interaction task source is associated), and another to which all other task sources are associated. Then, using the freedom granted in the initial step of the event loop processing model, it could give keyboard and mouse events preference over other tasks three-quarters of the time, keeping the interface responsive but not starving other task queues. Note that in this setup, the processing model still enforces that the user agent would never process events from any one task source out of order. 简而言之，事件有很多来源，浏览器根据事件的来源将它们放入不同的处理队列，可以给予队列不同的处理优先级，从而尽可能保证好的用户体验。常见的事件来源有： The DOM manipulation task source This task source is used for features that react to DOM manipulations, such as things that happen in a non-blocking fashion when an element is inserted into the document. The user interaction task source This task source is used for features that react to user interaction, for example keyboard or mouse input. The networking task source This task source is used for features that trigger in response to network activity The history traversal task This task source is used to queue calls to history.back() and similar APIs. 每个event loop有一个当前执行任务(currently running task)，可能是null。每个event loop还有一个微任务队列(microtask queue)，初始为空。 后面会讲到，microtask和task的区别在于它们执行的时机不同，microtask在当前task执行完之后，并在下一个task执行之前处理。 任务入队(Queueing tasks or microtasks)浏览器主线程(main thread)只是负责不停地从任务队列中取出任务来执行，我们可以假设是其他线程将任务放入队列的。 任务执行总体来说，主线程永不停止地从队列中取出任务并执行，如下所示： event loop 具体来说，每次任务迭代(event iteration OR “frame“)包含如下步骤: 按一定的规则选出一个包含可执行任务的任务队列，我们称之为taskqueue 从taskQueue中取出第一个可执行任务(first runnable task)，我们称之为oldestTask，将其移出队列 将当前运行任务(currently running task)设为oldestTask 将当前时间设置为taskStartTime 运行oldestTask 将当前运行任务置为null 处理微任务(microTasks)，反复执行如下步骤，直到微任务队列(microTask queue)为空： 从微任务队列中取出一个任务，设为oldestMicroTask 将当前运行任务置为oldestMicroTask 运行oldestMicroTask 将当前运行任务置为null 将hasARenderingOpportunity置为false 将当前时间设为now 统计并报过任务执行时间：taskStartTime，now 更新渲染：如果当前是一个window event loop(worker event loop没有这一步) 这是很重要的一步，浏览器渲染页面就发生在这一步，即在当前task即所有mircoTask都处理完之后进行渲染更新。但是，更新不是一定会发生，浏览器先要做两个判断： 当前有没有渲染机会(rendering opportunity) 当前有没有必要进行渲染 如果浏览器判断当前没有渲染机会或者没有必要进行渲染，则不会执行任何渲染动作，页面也不会有任何更新，跳过这一步，直接进入下一步 关于渲染机会及渲染的必要性，可以参考规范中的两段话： This specification does not mandate any particular model for selecting rendering opportunities. But for example, if the browser is attempting to achieve a 60Hz refresh rate, then rendering opportunities occur at a maximum of every 60th of a second (about 16.7ms). If the browser finds that a browsing context is not able to sustain this rate, it might drop to a more sustainable 30 rendering opportunities per second for that browsing context, rather than occasionally dropping frames. Similarly, if a browsing context is not visible, the user agent might decide to drop that page to a much slower 4 rendering opportunities per second, or even less. The step labeled Rendering opportunities prevents the user agent from updating the rendering when it is unable to present new content to the user (there’s no rendering opportunity). The step labeled Unnecessary rendering prevents the user agent from updating the rendering when there’s no new content to draw.This step enables the user agent to prevent the steps below from running for other reasons, for example, to ensure certain tasks are executed immediately after each other, with only microtask checkpoints interleaved (and without, e.g., animation frame callbacks interleaved). Concretely, a user agent might wish to coalesce timer callbacks together, with no intermediate rendering updates. 如果浏览器判断当前有渲染机会，则将hasARenderingOpportunity置为true，再进一步，如果当前有必要进行渲染，则执行渲染相关的事情，包含但不限于： 触发窗口的resize事件(如果有的话) 触发窗口的scroll事件(如果有的话) 执行所有requestAnimationFrame的callbacks 更新页面UI的渲染(我们平时所指的rendering) 从这里我们可以看到raf(requestAnimationFrame)的执行时机：它总是在真正的渲染发生之前执行。所以，对页面和dom的改变类的操作尽量放在ref中。 既然event loop的每次任务迭代(task iteration)时渲染不一定会执行，所以ref也不一定会执行。 执行requestIdleCallback的callbacks，如果下面所有条件都满足： 当前event loop是一个window event loop 任务队列为空 微任务队列为空 hasARenderingOpportunity为false 这篇文章本质上是对规范的精简解读，规范中还包括大量的作者无法理解的细节，这里都没列出来，有兴趣的读者可以仔细研读一番，定有大的收获。","tags":[{"name":"chrome","slug":"chrome","permalink":"http://tomwang1013.github.io/tags/chrome/"},{"name":"html","slug":"html","permalink":"http://tomwang1013.github.io/tags/html/"}]},{"title":"our-qq-talk","date":"2019-04-02T03:23:58.000Z","path":"our-qq-talk/","text":"早上女儿上学又不肯起来，在她睡着的时候给她穿衣服也不配合，我一怒，用力在她大腿上打了两下，照例哇哇大哭之后乖乖配合把衣服穿上了。在父母看来，任何时候孩子的表现只有两种：听话或不听话。听话的时候小嘴巴说个不停，和你一本正经地对话，和你谈条件：他要照你说的做可以，但是必须如何如何，否则就不爱你，只爱妈妈或爸爸；还讲学校里同学的趣事，期间“爸爸”、“妈妈”从不停地从嘴里清脆地蹦出来，做父母的最快乐的时刻也莫过如此。不听话的时候呢把你气得要死，给他下个命令重复八遍都不理你，直到你把电视关了或把他手里的玩具收了才勉强应一下；他做得不对的地方，你见一次说一次，重复几个月还是一样，怎么都改不了。 育儿经多如牛毛，自己却不太相信，也没这个精力去看。我自己的想法是孩子健康快乐是最根本的，所以尽量多陪孩子，除了某些必要的地方，如吃饭睡觉等，其他事情都尽量由着他，不强迫他做不喜欢的事情。但是该教育还是得教育，所以也免不了斥责甚至动手。电视里面动不动就“从小到大，父母连手指都没碰我一下”我是不信的，至少是挨过父亲的打的。我小时候父母的打都挨过，还不少，长大后觉得真没什么。 多陪孩子玩，多耐心和他们对话，偶尔不听话打一下哭一下，这就是我和我的女儿的现状。有时候真不想吼她打她，但是真忍不住，我尽量改吧，希望女儿不要记仇","tags":[{"name":"diary","slug":"diary","permalink":"http://tomwang1013.github.io/tags/diary/"}]},{"title":"老二看病小记","date":"2019-04-01T05:48:22.000Z","path":"sick/","text":"快三周前，我的第二个小孩出生了，欢喜之余，总希望他没病没灾快点长大。前几天突然有点小症状：鼻塞，打喷嚏，打出来黄色的浓稠鼻涕，观察了两三天不见好转，就送医院了，这里要说的就是送医院后的事 第一次送的医院是他出生的医院，因为很近的缘故不想多走。一个年轻的女医生接待的： “我的孩子鼻塞，打喷嚏，有黄鼻涕” “几天了？咳嗽吗？” “三四天了，基本不咳嗽” 我说完后她用听诊器在孩子的胸腔上的几个部位随意听了大概十秒钟吧，然后淡然说到： “先去照个胸片吧，可能是肺炎”。 “肺炎？不会吧，孩子能吃能睡，大小便都正常的”，我惊了一跳回应到。 “这有什么？小孩子肺炎很常见。你如果不照的话签个字吧”，年轻医生简短说到。 “照这个胸片会不会对小孩子有影响，毕竟太小了，还不足月呢”，我有些顾忌。 “手机还有辐射呢。你们快点决定做不做”，年轻医生又不耐烦地催促到。 我心里想的是孩子的身体应该没什么大问题，但是抱着以防万一以求心安的心理，还是决定给小孩照个胸透。一个小时以后，结果拿到了，像是有点问题的结论：支气管炎症状，请结合临床。我们拿给年轻医生看。她虽然只瞄了一眼，但一出口便让我们无比恐慌： “确是肺炎，准备住院吧，大概十到十四天的样子。”，她语气很快，且平淡得近乎漠然，丝毫没有医生在给病人传递坏消息时该有的同情甚至歉意 我一时蒙了，不太敢相信，说到：“结论准确吗？”。 “你不相信的话可以去其他医院看看，如果要在本院住院的话填下这个单子然后半小时后去住院部办理手续，预交四千元钱；如果不住院的话，在这里签个字就可以走了”。 这个决定对孩子意义重大，出生不到二十天，十多天的住院输液对孩子是多大的摧打，而这个医生却没有多一句解释，态度就像例行公事一样，还一个劲地催你签字，似乎病人签完字她作为医生的责任就算尽到了。 我随她的愿，签了字，打算换个大医院再看看。回到家，宝贝白天没什么异常，在妈妈怀里的时候鼻子很通顺，但是一放下就出现阻塞症状，并伴随着喷嚏偶尔加一两声咳嗽，我赶紧挂了省妇幼今天上午的号。省妇幼在市中心，里我们家很远，吃完早饭我们就打车过去了，赶上上班高峰，走了近一个小时才到。 和我们想的一样，这里的医生说宝贝没什么问题，是新生儿常见的鼻塞现象，经常清洗注意一下就行了，压根没谈到什么肺炎，也没让我们照片子，只开了点咳嗽的药。我们又打车回来了，一来一去看病的钱只是车费的零头。但是重要的是宝贝没事了。心里释然的同时，我们不住地骂那个冷漠且医术平庸的女医生，发誓以后不再到这个医院看儿科了，不，什么科都不看了。 上午送妻子和孩子到医院后我先回来上班了，由还未出月的妻子一个人带着孩子看的医生，出门时有热心的老阿姨以亲身例子要求妻子赶紧带上帽子，否则到老以后眼睛会迎风出泪，妻子说没事，还没想那么远，其实我们都不太相信。 快下班了，我迫不及待想回家看到丢丢（宝贝小名）和妻子！","tags":[{"name":"dairy","slug":"dairy","permalink":"http://tomwang1013.github.io/tags/dairy/"}]},{"title":"开始练习写作了","date":"2019-03-29T01:45:31.000Z","path":"begin-writing/","text":"经过很久的思虑，我决定开始练习写作了，有很多原因促成这一决定，而这些原因又可以归结成一个中心点：暂时没有其他事情可以提起自己永久或长远的兴趣了 对于大多数像自己这样平凡却不甘于平庸的人来说，总想找个地方发力一下。按理说在自己目前的岗位上发力是最好的选择：努力提高业务及专业能力以在公司博得一个好的发展前景。但是鉴于自己平庸的专业才能及公司的平台限制，总觉得这种努力没太大意义，人们常说选择比努力更重要，我此刻只能以此来安慰自己。但是，接下来怎么办呢？除了应付公司对自己所在岗位的要求以及自己应尽的家庭义务之外，还有些许时间，这些时间用来做点什么呢？我一有时间，脑子里就在想这个问题。作为技术人员，我尝试过创业（当然是在业余时间），做过两个小东西，但是几乎没人使用，看到别人做的东西之后，我觉得自己一个人根本没机会（我又在为自己找借口了，那些鼓吹坚持就是胜利的人该嘲笑我了）。我也想过钻研一种小吃，比如萝卜干啥的，然后把它卖火并以此谋生，但是实施起来很难（不排除以后会尝试的可能性）。想起自己中学曾经的作文被老师作为范文当堂念过，那时候也看过不少世界名著并做过将来当作家的梦，突然觉得自己可以尝试写写东西，不为当什么作家，权当抒发自己聊作兴趣而已。写得好坏不重要，重要的是写的过程。并且要写，当然得读，自己大学以前都是喜欢看文学类书的，只是后来工作了就很少看了。 万事开头难，这个决心早就下了，但是我今天才提笔记录下来。凡事都需要不断实践努力，写作也一样。今天在开篇的同时，也需要制定一个大概的计划： 每天写一篇：题材不限，字数500以上 坚持阅读：阅读方向主要集中在两块：名著及古文，名著目前选了《围城》，《追忆似水年华》，古文目前还没有具体的学习计划 最后，还是那两个字：坚持！所谓成功，就是做自己力所能及的事，并做到最好","tags":[{"name":"draft","slug":"draft","permalink":"http://tomwang1013.github.io/tags/draft/"}]},{"title":"几张图看懂元素几何尺寸","date":"2019-03-28T02:00:41.000Z","path":"geo-summary/","text":"元素和viewport的尺寸一直很迷惑，看到几张图，记录下来做个备份： 窗口尺寸 viewport尺寸 元素尺寸 element size element size 2 参考文档： https://txd.alibaba-inc.com/post/znwpg9?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io","tags":[{"name":"css","slug":"css","permalink":"http://tomwang1013.github.io/tags/css/"}]},{"title":"这段时间的总结","date":"2019-02-27T01:04:22.000Z","path":"recent-time-summary/","text":"​ 很久没有更新了，这段时间主要忙于做微信小程序，不是公司的事情，是自己想做。很久以来自己一直有一个产品梦，希望独立完成一款有价值的产品。不过一来自己懒，二来自己是个前端，不会做APP，web又需要兼顾后端，一个人说实话要完成很难（考虑到自己有家庭又在上班）。微信小程序的出现让我看到了希望，尤其是它推出的云开发大大简化了开发过程，使得开发者完全不用自己处理后端服务器了，所以自己立马选取了两个idea，并且马上开干，由于其中一个还牵涉到支付，自己还为此注册了公司，忙得不亦乐乎，两三个月的时间，两个小程序都基本开发完了。 ​ 结果如何呢？ ​ 不太好！这又要从两个方面说起：一是产品本身不够吸引人；做之前想的是如果有很多人用，肯定会给使用的人带来价值；但是做出来了发现，自己都不怎么想用，它的价值远远低于使用成本，特别是在这个人人都很忙的社会；二是微信小程序目前还有很多限制，无法满足产品功能的要求。举个明显的例子，它是无法主动给用户发送通知消息的：对于用户之间有交互行为的功能，一个用户的行为触动了另一个用户，我却无法及时通知给另一个用户，这是很致命的，因为小程序不像app，有事没事你会打开看看。如果不是必要，你是不会主动打开一个小程序来看的。 ​ 这些结果让我很沮丧，目前还没有找到什么好办法，也许会开发另外的小程序，并且等微信那边渐渐开放一些功能吧。总之，做产品不容易","tags":[{"name":"thinking","slug":"thinking","permalink":"http://tomwang1013.github.io/tags/thinking/"}]},{"title":"web push notification精髓","date":"2018-11-30T02:15:59.000Z","path":"push-notification-intro/","text":"push notification是PWA的重要组成部分，它使得web程序也具有native app类似的”离线”通知功能：即使程序的页面被关掉了，用户依然可以收到服务端发送的通知消息。push notification机制建立在service worker之上，是以下几个部分共同作用的结果： web server 后端服务，将消息推送给push service push service 和browser相关联的专门用来处理通知的服务，用来接受web server推送的消息。每个浏览器都有自己的push service browser 浏览器，除了常规功能之外(毕竟离开浏览器什么都干不了)，它负责和push service通信，并在有消息时唤醒SW client web客户端代码，用来注册(register)SW SW service worker，最终由它来接受消息并展示给用户 要完成消息推送并展示，需要经过下面几个步骤： client注册SW并向push service发起消息订阅请求，并将订阅信息(subscription)保存起来 web server从client处拿到subscription web server向subscription中的目的地(endpoint，其中包含了push service的地址)发送消息 push service收到消息，转发给browser browser唤醒SW，将消息发给它 SW收到消息，展示出来 整个过程图示如下： 下面进入show me the code阶段，分步讲解每个步骤： client订阅消息 获得通知权限 要展示通知，首先我们需要获取系统通知权限，如果用户不允许通知，后面一切都没有意义： 1234// main.jsNotification.requestPermission(status =&gt; &#123; console.log(&#x27;Notification permission status:&#x27;, status);&#125;); 运行之后会弹出一个框，让用户选择： 用户的选择结果会保存在Notification.permission中，值为”granted”或”denied” 注册SW 订阅之前先要注册SW，因为所有的操作都是通过SW进行的，注册之后把注册对象保存起来 123456789// main.jswindow.addEventListener(&#x27;load&#x27;, () =&gt; &#123; navigator.serviceWorker.register(&#x27;sw.js&#x27;).then(swReg =&gt; &#123; console.log(&#x27;Service Worker is registered&#x27;, swReg); swRegistration = swReg; &#125;).catch(err =&gt; &#123; console.error(&#x27;Service Worker Error&#x27;, err); &#125;);&#125;); 向push service发起消息订阅请求 123456789101112swRegistration.pushManager.subscribe(&#123; userVisibleOnly: true,&#125;).then(subscription =&gt; &#123; console.log(&#x27;User is subscribed:&#x27;, subscription); // 将subscription保存起来发给web server&#125;).catch(err =&gt; &#123; if (Notification.permission === &#x27;denied&#x27;) &#123; console.warn(&#x27;Permission for notifications was denied&#x27;); &#125; else &#123; console.error(&#x27;Failed to subscribe the user: &#x27;, err); &#125;&#125;); 订阅成功之后我们得到了订阅信息：subscription，这个信息包含两个关键部分： web server往哪里发送信息 browser收到push service信息后，唤醒那个SW，即里面包含了SW的标识 在chrome上示例如下： 1&#123; &quot;endpoint&quot;: &quot;https://fcm.googleapis.com/fcm/send/cc_aSQO9_gA:APA91bHLpiir8eZqvsMjRULQY16Pv8WXSlStr8G6Lrkyb-Qytxof_r6zZ0jPgViNMTZZgLZ5I4KVjXGiNex-pKnVKckaLdb9wW7_XwZeXT-LQUXHTppHBq7BP428BN_tiriyRRfuelYj&quot;, &quot;expirationTime&quot;: null, &quot;keys&quot;: &#123; &quot;p256dh&quot;: &quot;BLy8MEBjYFnwnLH1yiiY9PkWC4o4-pq13G3nSwq8xsCVV_-RhVoPujEndmCwQTXJD32OSekJoHsn-7_eIsH387U&quot;, &quot;auth&quot;: &quot;_jNmRauTLOXHLbV0Np2v0Q&quot; &#125; &#125; 其中的endpoint就是web server发送消息的目的地 可以看到chrome的push service服务运行在https://fcm.googleapis.com，每个浏览器都不一样，firefox的是https://updates.push.services.mozilla.com， edge的是https://sg2p.notify.windows.com web server往push service推送消息web server从client中原封不动拿到subscription，通过一个Web Push Protocol给push service推送消息，这个协议非常复杂，所以我们一般使用第三方库去做这件事，在nodejs端我们使用web-push包 因为chrome端发送消息需要使用google的服务，而我们一般用不了， 所以我们以firefox为例。使用web-push库推送消息很简单，基本上只需要上一步的subscription就行了： 12345678910111213141516171819// node端const webPush = require(&#x27;web-push&#x27;);// 从client端拿到的subscriptionconst pushSubscription = &#123; &quot;endpoint&quot;: &quot;https://updates.push.services.mozilla.com/wpush/v1/gAAAAABcAN9TNEnJkWUet1JCu0BFE4307sZ1e9RQaxs2x5ReXXcDxU-lRwb9t5B3TWKjSEEmgmJVPjqFDmfWSS2LFiTlynI1T4IVLVyVglR0uM6YYsUa07cUdwnkpwfFLQBCCWjsdgnS&quot;, &quot;keys&quot;: &#123; &quot;auth&quot;: &quot;a-2f-JnVWOWyeic1pJNYNA&quot;, &quot;p256dh&quot;: &quot;BBgpcZSWJc_VsjQZphdWhADpoDwziiiI3650nG4FrOKrhgWJdMDtWBHDi_BpurksrJc2r-6P2r5BsJBMFGUhuMY&quot; &#125; &#125;// 要发送的信息const payload = &#x27;Here is a payload!&#x27;;// 发送选项：使用默认值const options = &#123;&#125;webPush.sendNotification( pushSubscription, payload, options).catch(err =&gt; &#123; console.log(&#x27;send failed: &#x27;, err);&#125;) SW处理浏览器通知push service收到消息后，会通知浏览器(如果浏览器当前关闭了，下一次打开时会收到通知)，浏览器唤醒相应的SW，具体就是给SW发送”push”事件，SW处理push事件，并弹个小框将消息展示出来： 1234567891011121314151617181920212223242526272829303132333435// sw.jsself.addEventListener(&#x27;push&#x27;, event =&gt; &#123; let body; if (event.data) &#123; body = event.data.text(); &#125; else &#123; body = &#x27;Default body&#x27;; &#125; const options = &#123; body: body, icon: &#x27;images/notification-flat.png&#x27;, vibrate: [100, 50, 100], data: &#123; dateOfArrival: Date.now(), primaryKey: 1 &#125;, actions: [ &#123; action: &#x27;explore&#x27;, title: &#x27;Go to the site&#x27;, icon: &#x27;images/checkmark.png&#x27; &#125;, &#123; action: &#x27;close&#x27;, title: &#x27;Close the notification&#x27;, icon: &#x27;images/xmark.png&#x27; &#125;, ] &#125;; event.waitUntil( // Show notification self.registration.showNotification(&#x27;Push Notification&#x27;, options); );&#125;); 我们通过showNotification(title, options)展示通知，第一个参数是标题，第二个参数是一些控制弹窗的选项： body：消息内容 icon：展示在内容旁边的大图标 vibrate：振动控制 data SW不但可以展示消息，还可以处理用户的点击事件，这个data可以存储一些传递给点击处理的信息 actions 在消息弹框上设置一些点击按钮，这样我们可以根据不同的点击做不同的处理 根据上面的设置，在chrome上的效果如下： 而在firefox上actions却没有生效： 可见，每个浏览器的支持还不一样 处理用户点击用户看到通知之后，可以选择关闭弹窗(如果有关闭按钮)或点击上面的任何区域，如果有actions按钮的话还可以点击按钮，点击之后SW会收到notificationclick事件： 12345678910111213self.addEventListener(&#x27;notificationclick&#x27;, event =&gt; &#123; const notification = event.notification; const primaryKey = notification.data.primaryKey; const action = event.action; if (action !== &#x27;close&#x27;) &#123; event.waitUntil( clients.openWindow(&#x27;samples/page&#x27; + primaryKey + &#x27;.html&#x27;) ); &#125; notification.close();&#125;); 如果用户选择关闭消息窗口而不是点击其他区域，SW会收到notificationclose事件： 123456self.addEventListener(&#x27;notificationclose&#x27;, event =&gt; &#123; const notification = event.notification; const primaryKey = notification.data.primaryKey; console.log(&#x27;Closed notification: &#x27; + primaryKey);&#125;); VAPID介绍从前面的流程来看，任何web server只要它拿到了subscription信息都可以向我们push消息，因为push service没法判断谁是合法的pusher，这可能会导致某些安全问题，如DDOS攻击；另外，如果web server在push过程中出问题了，push service也没法和pusher取得联系。所以，我们有必要对web server做标识，区分出合法的pusher，这就是VAPID(Voluntary Application Server Identification的来源 具体来说，我们为web server生成一个密匙对，包含公匙和私匙，并加上一个email地址，以便发生问题时push service可以联系server。加上VAPID后，在代码逻辑上需要做一点修改： 在client订阅的时候需要加上VAPID中的public key 12345678const applicationServerPublicKey = &#x27;.........&#x27;;const applicationServerKey = urlB64ToUint8Array(applicationServerPublicKey);swRegistration.pushManager.subscribe(&#123; userVisibleOnly: true, applicationServerKey: applicationServerKey&#125;).then(subscription =&gt; &#123; ...&#125;); server端push消息的时候要加上整个VAPID信息 12345678910111213141516171819// 密匙对：可以使用web-push生成const vapidPublicKey = &#x27;...&#x27;;const vapidPrivateKey = &#x27;...&#x27;;const payload = &#x27;Here is a payload!&#x27;;const options = &#123; TTL: 600, vapidDetails: &#123; subject: &#x27;mailto: ********@***.com&#x27;, publicKey: vapidPublicKey, privateKey: vapidPrivateKey &#125;,&#125;;webPush.sendNotification( pushSubscription, payload, options) 更多细节请参考一下文档： https://developers.google.com/web/ilt/pwa/introduction-to-push-notifications","tags":[{"name":"html5","slug":"html5","permalink":"http://tomwang1013.github.io/tags/html5/"},{"name":"push notification","slug":"push-notification","permalink":"http://tomwang1013.github.io/tags/push-notification/"}]},{"title":"响应式图片设计的几个核心概念","date":"2018-11-22T10:04:11.000Z","path":"responsive-image-core-concepts/","text":"提到响应式图片设计，我们脑海中首先闪现的是picture, source, secret, sizes这些新的标签或属性，内容很多，且似乎都不是一看就能明白的道理，关于此方面的文章也多，一般看了过段时间就忘了，今天自己也来总结一下，做个备忘 初衷是这样的：由于设备的多样性，我们希望在不同的设备上，从图片大小和质量上选择最合适的图片！比如说屏幕只有300px，我们肯定不希望加载1000px的原图；比如说在高分辨率的设备上，我们希望提供比普通分辨率上更大的图片。所以我们设置多种条件以及每种条件下的图片，用来引导浏览器根据设备的情况和我们设定的条件选择最好的图片。这种选择是浏览器做出的，只要信息足够多，它就能选出最合适的图片 在具体讨论这些新的标签或属性之前，我们先搞清楚几个基本的概念： device pixel radio(dpr): 设备像素比 一个css像素对应多少个设备像素：如果dpr是2，则一个css像素对应2个物理像素 image real width: 图片的真实宽度 就是图片文件里面记录的图片的真实宽度，单位是物理px image display width: 图片的展示宽度 就是我们通过css或width属性给图片设置的宽度，单位是css px window width: 浏览器窗口宽度 就是浏览器viewport的宽度，单位是css px 有了这些基础概念，我们再思考一个简单的问题： 假设当前设备的dpr是2，一个图片的真实宽度是400px，我们没有给图片设置展示宽度，那么图片的默认展示宽度是多少？ 答案是200 (css)px，也就是物理宽度/dpr 好了，准备工作差不多了，我们开始讨论具体情况，首先考虑一种最简单最常见的情况： fixed size, varying density: 在不同分辨率下展示不同的图片，而图片的展示宽度固定简单，只需要在img的srcset中指定不同dpr对应的图片url即可： 1&lt;img width=&quot;320&quot; srcset=&quot;pic-2x.png 2x, pic-3x.png 3x&quot; src=&quot;pic.png&quot;&gt; 浏览器自动会根据当前dpr去加载对应的图片，如果所有dpr都不匹配，就会取src中的图片。 我们甚至都不需要指定width，只要我们的图片是按dpr等比例设置尺寸的，直接按默认宽度展示即可，因为在任何分辨率下展示的宽度都是一样的 varying size, varying density：图片的展示大小不固定，分辨率也不固定如果展示大小不固定，而在图片下载完之前浏览器是无法知道图片的的真实大小的，所以我们可以提供这些信息给浏览器：在srcset中指定图片的真实大小，在sizes指定我们期望图片的展示大小，浏览器会根据这些条件，并考虑当前dpr，去加载最合适的图片，所谓最合适的图片，就是尺寸最小的符合展示大小的图片。 举个例子： 假设当前dpr是2，当前窗口大小是700px，我们设置如下img： 123&lt;img src=&quot;default.png&quot; srcset=&quot;small.png 500w, medium.png 800w, large.png 1400w&quot; sizes=&quot;(min-width: 1000) 800px，(min-width: 800) 600px, (min-width: 500) 400px， 50vm&quot;&gt; srcset中的宽度是图片的真实宽度，而sizes中的单位都是css像素 由于当前窗口宽度是700，所以满足sizes中的第三个条件：(min-width: 500) 400px，这样浏览器认为图片的展示宽度是400px，而当前dpr是2，所以它会去加载真实宽度大于或等于400*2&#x3D;800的最小的图片，从srcset中我们得知，满足这个条件的最合适的图片是medium.png，所以浏览器只会去加载这张图片 更强大的picture上面提到的sizes中包含了media query，如(min-width: 1000)等，但是sizes中能使用的media query是有限制的，比如如果你想实现在横屏竖屏下使用不用的图片，用sizes就没法做，这时我们可以使用更强大的picture元素，它的source子元素可以使用真正的css media query，如： 1234567891011&lt;figure&gt; &lt;picture&gt; &lt;source media=&quot;(min-width: 750px)&quot; srcset=&quot;images/horses-1600_large_2x.jpg 2x, images/horses-800_large_1x.jpg&quot; /&gt; &lt;source media=&quot;(min-width: 500px)&quot; srcset=&quot;images/horses_medium.jpg&quot; /&gt; &lt;img src=&quot;images/horses_small.jpg&quot; alt=&quot;Horses in Hawaii&quot;&gt; &lt;/picture&gt; &lt;figcaption&gt;Horses in Hawaii&lt;/figcaption&gt;&lt;/figure&gt; 浏览器会找到第一个满足media条件的source，否则使用后面的img元素。source和img中的srcset和sizes和前面将的一样处理，唯一值得注意的是source中不能使用src属性来指定默认图片，但是可以在srcset中指定默认图片 我们还可是使用picture来选择图片格式，如对新的浏览器使用webp等高级图片格式： 参考文档： https://jakearchibald.com/2015/anatomy-of-responsive-images/ https://developers.google.com/web/ilt/pwa/lab-responsive-images","tags":[{"name":"html5","slug":"html5","permalink":"http://tomwang1013.github.io/tags/html5/"},{"name":"responsive design","slug":"responsive-design","permalink":"http://tomwang1013.github.io/tags/responsive-design/"}]},{"title":"对webpack的几个核心概念的理解","date":"2018-11-22T02:08:42.000Z","path":"webpack-core-concepts/","text":"webpack是公认的功能强大但是难用的工具，虽然文档很全，但是由于各种配置太多且很多配置只有经过测试才能发现其意义，虽然自己从两年前就开始使用了，但是也只是勉强能给出符合项目要求的配置而已。最近webpack4发布了，自己又从头开始仔细读了一下它的guide文档，并按照文档的示例跑了一遍，对webpack的几个核心概念终于有了稍微清晰的认识，这里记录一下 chunk chunk大概是文档中出现最频繁的单词，它指的是webpack最终输出的文件。chunk有两种类型： entry chunk 就是在entry配置中的入口文件，最终输出的文件名由另一个配置项output.filename决定 其他chunk 除了entry chunk外，webpack会根据我们的配置及代码情况自动输出很多文件，如optimization.splitChunks提取出的公共文件，dynamic.import生成的延迟加载文件 这种chunk的输出文件名由配置项output.chunkFilename决定 module module就是我们代码中通过import或require引入的一个文件，可以是js，css或图片等等。注意它和chunk的不同：chunk是最终的输出文件，而module是编码时的内部引用 runtime &amp; manifest 为了使得这一套打包系统能够正常工作，也就是浏览器引入我们最终生成的chunk文件后能运转起来，包括module的解析引用能顺利进行，webpack提供了一段支撑代码，就是runtime。runtime最主要的工作就是module依赖关系的解析及module的导入，所以，在runtime中我们还需要所有module的一些meta信息，如各个module的唯一标识id及关系等等，这些信息称为manifest 这个runtime代码可以包含在entry chunk中，或者单独提取出来作为独立的runtime chunk；在html文件中，runtime chunk一般放在entry chunk前面 caching 提到caching，标准的做法是做code splitting，将runtime代码, 第三方库代码及自己的代码分离开来打成独立的chunk并在chunk的输出文件名中带上chunkhash： 1234567891011121314151617output: &#123; filename: &#x27;[name].bundle.[contenthash].js&#x27;, chunkFilename: &#x27;[name].bundle.[contenthash].js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;)&#125;,optimization: &#123; runtimeChunk: &#x27;single&#x27;, splitChunks: &#123; cacheGroups: &#123; vender: &#123; test: /[\\\\/]node_modules[\\\\/]/, name: &#x27;vendors&#x27;, chunks: &#x27;all&#x27; &#125; &#125; &#125;&#125; 这样会打出三个chunk文件： 1234567... Asset Size Chunks Chunk Names vendor.a7561fb0e9a071baadb9.js 541 kB 0 [emitted] [big] vendor main.b746e3eb72875af2caa9.js 1.22 kB 1 [emitted] mainmanifest.1400d5af64fc1b7b3a45.js 5.85 kB 2 [emitted] manifest index.html 352 bytes [emitted]... 但是这还不够：如果这时候我们增加或删除一个module，这三个chunk的内容都可能发生变化；原因是默认情况下module的id是按照引用顺序从0递增，所以增加或删除module会导致其他module的id发生变化。要避免这种情况，就要让module的id只和自己有关，这个时候就要用到HashedModuleIdsPlugin，它使得module的id和自己内容的hash绑定，只要内容不变，id就不变： 123plugins: [ new webpack.HashedModuleIdsPlugin()] 待续…","tags":[{"name":"webpack","slug":"webpack","permalink":"http://tomwang1013.github.io/tags/webpack/"}]},{"title":"Same-origin policy(SOP)和Content Security Policy(CSP)拾遗","date":"2018-11-21T02:46:40.000Z","path":"sop-csp-intro/","text":"SOP浏览器的同源策略(Same-origin policy，下面简称SOP)用来控制document及其里面的script如何访问不同域的资源，政策大家都听过，但是细节很多，这里做个总结备忘 cross-site ajax request跨域ajax请求，毫无疑问是被阻止的，这也是我们对SOP的第一印象 cross-site script API access跨域访问另一个文档的内容，也是被阻止的 但是，我们可以拿到另一个文档的window对象，这个对象暴露了很有限的属性或方法可以访问： The following cross-origin access to these Window properties is allowed: Methods window.blur window.close window.focus window.postMessage Attributes window.closed Read only. window.frames Read only. window.length Read only. window.location Read&#x2F;write. window.opener Read only. window.parent Read only. window.self Read only. window.top Read only. window.window Read only. Cross-origin network access和js发起的请求不一样，浏览器自动发起的跨域请求很多情况下是允许的，如： Cross-origin writes：如链接(link)、重定向(redirect)及表单提交(form submission) Cross-origin embedding：资源嵌套，如： &lt;script src=&quot;...&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;…&quot;&gt; &lt;img&gt; &lt;video&gt;和&lt;audio&gt; 插件嵌入：&lt;object&gt;, &lt;embed&gt;, &lt;applet&gt; @font-face引入的字体文件(有些浏览器不允许) &lt;iframe src=&quot;...&quot;&gt;(可以使用X-Frame-Options来阻止页面被嵌入其他网站) Cross-origin reads：和embedding不一样，这个不是为了将资源展示出来，而是为了读取资源的内容，比如说我在img标签中将src设置为一个html或json文档。现在浏览器已经做了一些事来阻止这种行为 如何允许跨域访问 CORS 如何阻止跨域访问CSRF token Cross-origin data storage access 对localStorage(包括sessionStorage)和indexDB来说，它们是严格按origin划分的。一个origin中的js不能访问另一个origin中的存储 对cookie来说，情况稍微有点不同： 我们创建一个cookie时，cookie.domain可以设置成当前domain或当前domain的父domain 我们给cookie设置一个domain，这个cookie对所有子domain也是可见的：For example, if Domain=mozilla.org is set, then cookies are included on subdomains like developer.mozilla.org。 If domain is not unspecified, it defaults to the host of the current document location, excluding subdomains. If Domain is specified, then subdomains are always included. CSPContent Security Policy(下面简称CSP)是浏览器用来控制页面上所有资源(js, css, img, etc)的来源，初衷是为了减少页面受攻击的可能性。比如XSS攻击是用户不小心执行了攻击者放入页面的脚本，用CSP我们可以限制页面上js的来源，这样我们只能执行特定来源的js从而使得这种攻击不会发生 使用使用CSP很简单，只需由web server在响应头中指定Content-Security-Policy头，格式如下： 1Content-Security-Policy: policy 这里的policy就可以控制各个资源的加载，举个例子： 12Content-Security-Policy: default-src &#x27;self&#x27;; img-src *; media-src media1.com media2.com; script-src userscripts.example.com 这个policy说明了： 默认情况下，资源只能从本地加载(default-src ‘self’) 图片能从任何地方加载(img-src *) 音视频只能从media1.com media2.com这两个地方加载 只执行从userscripts.example.com加载的js脚本(script-src userscripts.example.com) 参考文档： https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies","tags":[{"name":"security","slug":"security","permalink":"http://tomwang1013.github.io/tags/security/"},{"name":"http","slug":"http","permalink":"http://tomwang1013.github.io/tags/http/"}]},{"title":"webpack sideEffects选项简介","date":"2018-11-20T08:51:45.000Z","path":"webpack-sideEffects/","text":"webpack的sideEffects选项和tree shaking有关，按照官方文档我测试了下这个选项对打包代码的影响，示例代码如下： 12345678910// math.jsexport function square(x) &#123; return x * x;&#125;console.log(&#x27;math has side effects&#x27;)export function cube(x) &#123; return x * x * x;&#125; 123456789101112131415// index.jsimport &#123; cube, square &#125; from &#x27;./math.js&#x27;;function component() &#123; var element = document.createElement(&#x27;pre&#x27;); element.innerHTML = [ &#x27;Hello webpack!&#x27;, &#x27;5 cubed is equal to 125&#x27;/* + cube(5) */ ].join(&#x27;\\n\\n&#x27;); return element;&#125;document.body.appendChild(component()); index.js虽然import了math.js，但是没有用到import进来的方法，按我们的理解最终math.js的代码最终会打包进来，下面分三种情况做下测试： sideEffects不设置，看默认情况 只有console.log(&quot;math has side effects&quot;);这句代码被打包进来，math.js中的其他两个函数都没有打包 看来webpack已经很智能了：即使你引入了，只要没使用都不会打包进来 sideEffects: false math中的任何代码都没有打进来，和预期的一致：这个选项告诉webpack，我的文件没有任何副作用 sideEffects: [“.&#x2F;src&#x2F;math.js”] 和第一种情况一样：这里显式指明有副作用的文件，这样webpack会把文件中没有用到的代码也打包进来 总结： 即使你不做任何事情，webpack的tree shaking机制也已经在起作用了，并且作用得很好 注意：此处我们用的是webpack 4，它在production环境下会自动开启minification和tree shaking机制","tags":[{"name":"webpack","slug":"webpack","permalink":"http://tomwang1013.github.io/tags/webpack/"}]},{"title":"module javascript(mjs)介绍","date":"2018-11-15T05:38:19.000Z","path":"mjs-intro/","text":"作为前端工程师，我们基本都被webpack和babel蹂躏过，并且将继续被蹂躏。module javascript(下面简称mjs)带来了一点点曙光，本文简单介绍一下mjs 基本用法我们知道，一个js模块是封闭的：它里面定义的所有顶层变量的作用范围都是在模块之内；它对外的接口需要手动导出(export)，模块是我们写代码的正确姿势。但是普通的js文件被浏览器引入之后它里面的代码都是在全局作用域运行的，这才导致了各种模块加载方式的出现，如commonJS，AMD, es6 Module等。 mjs指的是在浏览器端可以直接引用es6 module模块，和普通的js一样，可以引入一个文件，也可以直接inline： 12345&lt;script type=&quot;module&quot; src=&quot;main.mjs&quot;&gt;&lt;/script&gt;&lt;script type=&quot;module&quot;&gt; import foo from &#x27;./bar.mjs&#x27; ...&lt;/script&gt; 模块文件一般以mjs作为后缀，里面可以使用import和export，和平时的写法一样 mjs和普通js的区别加上type=&quot;module&quot;之后，引入的js变成了mjs，它和普通的js有很多区别： mjs默认使用strict mode mjs中定义的顶层变量不再是全局变量 新的import和export语法只能在mjs中使用，不能再普通js中使用 不管被加载多少次，同一个mjs只执行一次；而普通的js每次加载都会执行 mjs通过CORS的方式加载，需要服务端的配合；而普通js直接可以跨域加载 mjs默认是defer，而普通js需要指定defer属性 inline mjs默认也是defer，而普通inline js无法defer inline mjs可以设置async属性，而普通inline js无法async 这里有张经典的图可以说明上面几条性质： 其他注意点 mjs文件的路径(import * from modulePath)的限制： 1234// Not supported (yet):import &#123;shout&#125; from &#x27;jquery&#x27;;import &#123;shout&#125; from &#x27;lib.mjs&#x27;;import &#123;shout&#125; from &#x27;modules/lib.mjs&#x27;; 12345// Supported:import &#123;shout&#125; from &#x27;./lib.mjs&#x27;;import &#123;shout&#125; from &#x27;../lib.mjs&#x27;;import &#123;shout&#125; from &#x27;/modules/lib.mjs&#x27;;import &#123;shout&#125; from &#x27;https://simple.example/modules/lib.mjs&#x27;; 对于CORS请求，如果是同域的话，需要注意是否发送credentials(cookies, etc) 大部分和CORS相关的api如果是请求同域的话，默认都会发送credentials的，但是fetch和mjs是个例外，你可能需要设置crossorigin 才能发送： 1234567891011121314&lt;!-- Fetched with credentials (cookies etc) --&gt;&lt;script src=&quot;1.js&quot;&gt;&lt;/script&gt;&lt;!-- Fetched without credentials --&gt;&lt;script type=&quot;module&quot; src=&quot;1.mjs&quot;&gt;&lt;/script&gt;&lt;!-- Fetched with credentials --&gt;&lt;script type=&quot;module&quot; crossorigin src=&quot;1.mjs?&quot;&gt;&lt;/script&gt;&lt;!-- Fetched without credentials --&gt;&lt;script type=&quot;module&quot; crossorigin src=&quot;https://other-origin/1.mjs&quot;&gt;&lt;/script&gt;&lt;!-- Fetched with credentials--&gt;&lt;script type=&quot;module&quot; crossorigin=&quot;use-credentials&quot; src=&quot;https://other-origin/1.mjs?&quot;&gt;&lt;/script&gt; 但是这个例外未来很可能会变成不例外： Both fetch() and module scripts will send credentials to same-origin URLs by default. Issue 要使mjs生效，服务端必须明确在对mjs文件的响应中把content-type设置为js格式：推荐为text/javascript 有了mjs，还需要打包吗？简单答案是：要 但是mjs提供了一些想象的优化空间，值得注意一下。 TODO 参考文档： https://developers.google.com/web/fundamentals/primers/modules https://jakearchibald.com/2017/es-modules-in-browsers/ https://philipwalton.com/articles/deploying-es2015-code-in-production-today/","tags":[{"name":"html5","slug":"html5","permalink":"http://tomwang1013.github.io/tags/html5/"},{"name":"es6","slug":"es6","permalink":"http://tomwang1013.github.io/tags/es6/"}]},{"title":"使用preload & prefetch提高加载速度","date":"2018-11-15T02:33:47.000Z","path":"preload-prefetch/","text":"概述：提前加载资源，用的时候直接从本地取对一些资源，如css，js，font，img等，我们可以不必等到用的时候再按常规加载，而可以提前加载好(注意：只是先准备好，并不会马上生效)，等到需要用的时候直接取就行了，举两个例子： 我们通常把js放在底部： 123&lt;body&gt; &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 这样这个js必须等到页面解析完才能被加载并执行。其实我们可以先把这个js下载到本地，等页面解析到这里时直接从本地去，这样就省去了一部分网络加载时间： 123456&lt;head&gt; &lt;link ref=&quot;preload&quot; as=&quot;script&quot; href=&quot;main.js&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 一些资源是动态加载的，我们可以把这些资源提前加载好，假设页面的管家加载路径如下： 1234├─┬ / (initial HTML file) └── fetch-css.js └── main.css └── K2D.woff2 这时网络加载顺序如下： 我们可以把main.css和k2D.woff2提前加载好： 1234&lt;head&gt; &lt;link rel=&quot;preload&quot; href=&quot;main.css&quot; as=&quot;style&quot;&gt; &lt;link rel=&quot;preload&quot; href=&quot;fonts/K2D.woff2&quot; as=&quot;font&quot;&gt;&lt;/head&gt; 修改之后这两个文件提前加载了： 这样节省了不少时间，提高了首屏渲染速度 preload vs prefetch它们的区别就是资源加载的优先级不同：preload的优先级更高，所以它加载的资源一般是本页面要用到的；而prefetch的优先级很低，浏览器只有在空闲的时候才回去加载，它加载的资源一般会在其他页面用到 对于preload，如果加载的资源在一定时间内没有用到(就是没有再去加载)，浏览器就会报出警告： 其他注意点 cross-origin fetch 可以设置crossorigin属性加载跨域资源： 1&lt;link rel=&quot;preload&quot; href=&quot;other-site/main.css&quot; as=&quot;style&quot; crossorigin&gt; 字体比较特殊，即使同域也需要加上： 1&lt;link rel=&quot;preload&quot; href=&quot;fonts/K2D.woff2&quot; as=&quot;font&quot; crossorigin=&quot;anonymous&quot;&gt; 动态加载preload资源 可以用js来加载preload资源： 12345var preloadLink = document.createElement(&quot;link&quot;);preloadLink.href = &quot;myscript.js&quot;;preloadLink.rel = &quot;preload&quot;;preloadLink.as = &quot;script&quot;;document.head.appendChild(preloadLink); 然后像平时一样使用它： 123var preloadedScript = document.createElement(&quot;script&quot;);preloadedScript.src = &quot;myscript.js&quot;;document.body.appendChild(preloadedScript); webpack提供支持 webpack提供了code splitting的机制，可以让我们动态加载js文件： 1234567form.addEventListener(&quot;submit&quot;, e =&gt; &#123; e.preventDefault() import(&#x27;lodash.sortby&#x27;) .then(module =&gt; module.default) .then(sortInput()) .catch(err =&gt; &#123; alert(err) &#125;);&#125;); 我们也可以把这个文件preload &amp; prefetch： 1234567form.addEventListener(&quot;submit&quot;, e =&gt; &#123; e.preventDefault() import(/* webpackPrefetch: true */ &#x27;lodash.sortby&#x27;) .then(module =&gt; module.default) .then(sortInput()) .catch(err =&gt; &#123; alert(err) &#125;);&#125;); webpack会自动将prefetch link标签插入到head中 和浏览器内置的preloader的区别 我们知道浏览器可能有内置的对我们不可见的preloader会提前解析html文件找出需要加载，但是这个机制是没有标准的，每个浏览器都不一样，况且不是所有资源都写在html脚本中的，所以本篇说的preload和这个是完全不同的两件事 浏览器支持目前只有chrome支持，但是其他浏览器都在积极实现中，考虑到chrome No.1的市场地位，值得一试 参考文档： https://web.dev/fast/preload-critical-assets/codelab-preload-critical-assets https://developer.mozilla.org/en-US/docs/Web/HTML/Preloading_content","tags":[{"name":"html5","slug":"html5","permalink":"http://tomwang1013.github.io/tags/html5/"},{"name":"performance","slug":"performance","permalink":"http://tomwang1013.github.io/tags/performance/"}]},{"title":"PWA的一种fetch模式：cache then network","date":"2018-11-14T07:12:08.000Z","path":"pwa-cache-then-network/","text":"详解PWA中处理请求有很多种模式，比如： Cache falling back to network 先查询缓存，有的话取缓存的数据；没有的话再请求服务端数据 Network falling back to cache 和上面一种刚好相反 这是比较常见的两种，还有一种，就是今天我们要介绍的：cache then network，什么意思呢？就是同时发请求及查询缓存，如果缓存中有数据的话先用缓存的数据；当请求返回数据后再用返回的数据覆盖。这种方式适合内容更新比较频繁的请求，先让用户尽快看到内容，然后看到最新的内容 代码实现如下： 123456789101112131415161718192021222324252627// client.jsvar networkDataReceived = false;startSpinner();// 1. fetch fresh datavar networkUpdate = fetch(&#x27;/data.json&#x27;).then(function(response) &#123; return response.json();&#125;).then(function(data) &#123; networkDataReceived = true; updatePage(data);&#125;);// 2. fetch cached datacaches.match(&#x27;/data.json&#x27;).then(function(response) &#123; if (!response) throw Error(&quot;No data&quot;); return response.json();&#125;).then(function(data) &#123; // don&#x27;t overwrite newer network data if (!networkDataReceived) &#123; updatePage(data); &#125;&#125;).catch(function() &#123; // we didn&#x27;t get cached data, the network is our last hope: return networkUpdate;&#125;).catch(showErrorMessage).then(stopSpinner()); 一般来说缓存中的数据先被取出来展示，网络请求完成后再用最新的数据刷新页面。 这种方式需要sw配合，sw收到fetch时就不能直接读缓存了，需要直接向服务端发起请求，并将返回的数据写入缓存： 1234567891011// sw.jsself.addEventListener(&#x27;fetch&#x27;, function(event) &#123; event.respondWith( caches.open(&#x27;mysite-dynamic&#x27;).then(function(cache) &#123; return fetch(event.request).then(function(response) &#123; cache.put(event.request, response.clone()); return response; &#125;); &#125;) );&#125;); 大概就这样了，这种模式可能不太常用，但是碰到特殊场景时还是不错的 和Stale-while-revalidate的区别stale-while-revalidate是另外一种模式：还是从缓存中取，取完之后再在后台发起一个请求得到最新的数据来刷新缓存，这样可以保持缓存的数据是比较新的(虽然不是最新的)。在这种模式下，客户端不用直接读缓存，一切逻辑都在sw里面： sw的实现如下： 1234567891011121314self.addEventListener(&#x27;fetch&#x27;, function(event) &#123; event.respondWith( caches.open(&#x27;mysite-dynamic&#x27;).then(function(cache) &#123; return cache.match(event.request).then(function(response) &#123; // 得到缓存之后发起一个后台请求去拿最新的数据 var fetchPromise = fetch(event.request).then(function(networkResponse) &#123; cache.put(event.request, networkResponse.clone()); return networkResponse; &#125;) return response || fetchPromise; &#125;) &#125;) );&#125;);","tags":[{"name":"html5","slug":"html5","permalink":"http://tomwang1013.github.io/tags/html5/"},{"name":"pwa","slug":"pwa","permalink":"http://tomwang1013.github.io/tags/pwa/"}]},{"title":"vue patch算法解读之二：自定义组件的实例化及首次渲染","date":"2018-11-12T01:08:46.000Z","path":"vue-patch-2/","text":"在上一篇中我们介绍了根组件root的初始化渲染过程： 123new Vue(&#123; render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;) 当时我们提到，root的_vnode的componentInstance中存储了App组件的实例(后面称为app)： 12345const child = vnode.componentInstance = createComponentInstanceForVnode( vnode, activeInstance)child.$mount(hydrating ? vnode.elm : undefined, hydrating) 在app这个实例mount之后，我们把app.$el插入到页面上整个root就渲染出来了，其中的数据结构如下： 本篇中我们详细看看app的创建及首次渲染过程，我们从createComponentInstanceForVnode开始，在本例中，我们传给你它的2个参数依次为root._vnode和root： 123456789101112export function createComponentInstanceForVnode ( vnode: any, // we know it&#x27;s MountedComponentVNode but flow doesn&#x27;t parent: any, // activeInstance in lifecycle state): Component &#123; const options: InternalComponentOptions = &#123; _isComponent: true, _parentVnode: vnode, parent &#125; return new vnode.componentOptions.Ctor(options)&#125; App的构造函数是Vue.extend中定义的，最终会调用Vue.prototype._init进行初始化： 12345678910111213141516171819202122232425262728293031323334353637// src/core/instance/init.jsVue.prototype._init = function (options?: Object) &#123; const vm: Component = this vm._uid = uid++ vm._isVue = true // merge options if (options &amp;&amp; options._isComponent) &#123; // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options) &#125; else &#123; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ) &#125; vm._renderProxy = vm // expose real self vm._self = vm initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, &#x27;beforeCreate&#x27;) initInjections(vm) // resolve injections before data/props initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, &#x27;created&#x27;) if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125;&#125; 这个初始化方法主要有三个步骤： 得到vm的最终的$options 主要是把参数中的options和构造函数的options合并起来作为最终的$options，这里我们options._isComponent是true，所以走的是initInternalComponent，这个细节不讨论，有兴趣大家可以看看参考文档(http://hcysun.me/vue-design/art/) 做各种初始化 有兴趣参考(http://hcysun.me/vue-design/art/)，这里我们只列出一点：在initLifecycle中我们设置了`vm.$parent`及`vm.$root`: 12345678910111213// src/core/instance/lifecycle.jsexport function initLifecycle (vm: Component) &#123; const options = vm.$options let parent = options.parent if (parent &amp;&amp; !options.abstract) &#123; ... parent.$children.push(vm) &#125; vm.$parent = parent vm.$root = parent ? parent.$root : vm&#125; 我们这里的options里面是传了parent选项的，这里的值是root mount 这里if条件不成立，所以没有mount，mount发生在实例被创建之后 app创建之后，我们马上进行了mount： 1child.$mount(hydrating ? vnode.elm : undefined, hydrating) 第一个参数是undefined，第二个参数是false。我们知道，mount会重新走_render及_update的过程，我们先看看_render，简化如下： 1234567891011121314151617181920// src/core/instance/render.js Vue.prototype._render = function (): VNode &#123; const vm: Component = this const &#123; render, _parentVnode &#125; = vm.$options /*if (_parentVnode) &#123; vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject &#125;*/ // set parent vnode. this allows render functions to have access // to the data on the placeholder node. vm.$vnode = _parentVnode // render self let vnode vnode = render.call(vm._renderProxy, vm.$createElement) // set parent vnode.parent = _parentVnode return vnode&#125; 在render之前我们设置了实例的$vnode属性，render之后又设置了vnode.parent属性，_render函数返回的vnode传入_update，我们看看update： 1234567891011121314151617181920212223242526// src/core/instance/lifecycle.jsVue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const prevActiveInstance = activeInstance activeInstance = vm vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) &#125; else &#123; // updates &#125; activeInstance = prevActiveInstance // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125; // updated hook is called by the scheduler to ensure that children are // updated in a parent&#x27;s updated hook.&#125; prevEl和prevVnode分别保存之前的根元素($el)和_vnode，在首次渲染之前，它们都是空的。然后设置新的_vnode，并在patch之后设置新的$el，并且在patch之前修改全局变量activeInstance，设置为自己，这里即app实例，patch完之后再还原成root。最后是一个if语句，在本例中是满足的，所以把root的根元素置为和app的一样，所以经过_render和_update时候数据结构变成： 理解了大概的数据结构之后，我们再详细看看app的render和update过程 renderApp组件的html模板为： 123456&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt; &lt;div&gt;hello, world!&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 它生产的render函数如下： 1234567891011121314151617181920212223// webpack:///./src/App.vue?5b21var render = function() &#123; var _vm = this var _h = _vm.$createElement var _c = _vm._self._c || _h return _vm._m(0)&#125;var staticRenderFns = [ function() &#123; var _vm = this var _h = _vm.$createElement var _c = _vm._self._c || _h return _c(&quot;div&quot;, &#123; attrs: &#123; id: &quot;app&quot; &#125; &#125;, [ _c(&quot;img&quot;, &#123; attrs: &#123; alt: &quot;Vue logo&quot;, src: require(&quot;./assets/logo.png&quot;) &#125; &#125;), _c(&quot;div&quot;, [_vm._v(&quot;hello, world!&quot;)]) ]) &#125;]render._withStripped = trueexport &#123; render, staticRenderFns &#125; 我们在_render中是这么调用的： 1vnode = render.call(vm._renderProxy, vm.$createElement) vm._renderProxy在生产环境下就是vm，_vm._m其实就是staticRenderFns，_c定义如下： 1vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false) 最终执行的是下面这段代码： 123456return _c(&quot;div&quot;, &#123; attrs: &#123; id: &quot;app&quot; &#125; &#125;, [ _c(&quot;img&quot;, &#123; attrs: &#123; alt: &quot;Vue logo&quot;, src: require(&quot;./assets/logo.png&quot;) &#125; &#125;), _c(&quot;div&quot;, [_vm._v(&quot;hello, world!&quot;)])]) 最终执行的是_createElement： 12345678910// src/core/vdom/create-element.jsexport function _createElement ( context: Component, tag?: string | Class&lt;Component&gt; | Function | Object, data?: VNodeData, children?: any, normalizationType?: number): VNode | Array&lt;VNode&gt; &#123; ...&#125; 对顶层的div来说，传递给这个函数的参数为： context：当前实例，即app tag：”div” data：&#123; attrs: &#123; id: &quot;app&quot; &#125; &#125; children: 123456[ _c(&quot;img&quot;, &#123; attrs: &#123; alt: &quot;Vue logo&quot;, src: require(&quot;./assets/logo.png&quot;) &#125; &#125;), _c(&quot;div&quot;, [_vm._v(&quot;hello, world!&quot;)])] 其实就是包含2个vnode元素的数组 normalizationType：undefined 根据这些参数，这个函数的执行路径为： 12345678910111213141516171819202122// src/core/vdom/create-element.jsexport function _createElement ( ...): VNode | Array&lt;VNode&gt; &#123; let vnode, ns if (typeof tag === &#x27;string&#x27;) &#123; if (config.isReservedTag(tag)) &#123; // platform built-in elements vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ) &#125; else if (...) &#123; ... &#125; else &#123; ... &#125; &#125; else &#123; ... &#125; return vnode&#125; 直接是以内置div标签new一个vnode出来 update得到这个vnode之后，我们调用patch： 1vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) 这是vm.$el是undefined，因为这是首次渲染，我看把视角转向patch函数： 123456789101112131415// src/core/vdom/patch.jsreturn function patch (oldVnode, vnode, hydrating, removeOnly) &#123; let isInitialPatch = false const insertedVnodeQueue = [] if (isUndef(oldVnode)) &#123; // empty mount (likely as component), create new root element isInitialPatch = true createElm(vnode, insertedVnodeQueue) &#125; else &#123; ... &#125; return vnode.elm&#125; 这次很简单，因为oldVnode是空的，所以直接调用createElm基本就结束了，这次只传了2个参数，我们看看这个函数这次的执行路径： 1234567891011121314151617181920212223242526272829303132333435// src/core/vdom/patch.jsfunction createElm ( vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index) &#123; vnode.isRootInsert = !nested // for transition enter check if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123; return &#125; const data = vnode.data const children = vnode.children const tag = vnode.tag if (isDef(tag)) &#123; vnode.elm = nodeOps.createElement(tag, vnode) if (__WEEX__) &#123; ... &#125; else &#123; createChildren(vnode, children, insertedVnodeQueue) if (isDef(data)) &#123; invokeCreateHooks(vnode, insertedVnodeQueue) &#125; &#125; &#125; else if (isTrue(vnode.isComment)) &#123; ... &#125; else &#123; ... &#125;&#125; 这次createComponent是不会返回true的，且调用之后没有任何效果，因为这里的vnode只是一个div的包装而已。代码直接进入第一个if执行下面这行代码： 1vnode.elm = nodeOps.createElement(tag, vnode) 它直接创建一个div元素！因为children还有2个vnode，所以再调用createChildren创建子元素，这样app的整个dom就创建好了，然后patch直接返回根元素。最后回到_update把这个元素赋给vm.$el，整个数据结构变成： 在上一篇我们知道，这个根元素最终会被root插入到文档中从而展示在页面上。至此，下面这两三行简单的代码基本分析完了： 1234import App from &#x27;./App.vue&#x27;new Vue(&#123; render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;) 可以看到，这后面其实牵涉到很多逻辑，何况我们还省略了很多细节，但是更复杂的情况也能从这里推导出来。","tags":[{"name":"vue","slug":"vue","permalink":"http://tomwang1013.github.io/tags/vue/"},{"name":"read-source-code","slug":"read-source-code","permalink":"http://tomwang1013.github.io/tags/read-source-code/"}]},{"title":"vue patch算法解读之一：根组件的初始化","date":"2018-11-10T15:52:03.000Z","path":"vue-patch-1/","text":"vue的渲染过程是由vnode驱动的，当数据发生变化时，根据前后vnode的差异使用patch算法只重新渲染变化的部分。这里说的渲染其实就是重新调整组件的DOM结构：复用、移动、删除dom节点使得真实dom和vdom保持一致。这个过程其实是很复杂的，这里我尝试一边读源码调试，一边记录对这个过程的理解，在完全理解之前，这里记录的都是一些片段，希望最后能将这些片段串联起来组成一篇真正的有条理的解读 根组件的初始化我们以一个简单的例子开始： 12345// main.jsimport App from &#x27;./App.vue&#x27;new Vue(&#123; render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;) 12345678910111213// app.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt; &lt;div&gt;hello, world!&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;app&#x27;,&#125;&lt;/script&gt; 12// index.html&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 我们把最顶层组件(new Vue出来的)称为root，程序的运行以root的渲染开始。vue实例的渲染分两步：第一步是render，得到代表它的结构的vnode；第二部根据vnode，渲染出真实的dom。整个渲染过程为： 1234// src/core/instance/lifecycle.jsupdateComponent = () =&gt; &#123; vm._update(vm._render(), hydrating)&#125; _render_render会调用vm的render函数，root的render函数很简单：h =&gt; h(App)。这里的h其实就是实例方法vm.$createElement： 1234// src/core/instance/render.js// normalization is always applied for the public version, used in// user-written render functions.vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true) App就是import App.vue得到的一个表示组件的对象 createElement这个函数返回一个vnode： 123456789101112// src/core/vdom/create-element.jsexport function createElement ( context: Component, tag: any, data: any, children: any, normalizationType: any, alwaysNormalize: boolean): VNode | Array&lt;VNode&gt; &#123; ... return _createElement(context, tag, data, children, normalizationType)&#125; 只是简单包装了一下，最终调用的是_createElement，这个函数很复杂，我们截出骨干部分： 1234567891011121314151617181920212223242526272829303132// src/core/vdom/create-element.jsexport function _createElement ( context: Component, tag?: string | Class&lt;Component&gt; | Function | Object, data?: VNodeData, children?: any, normalizationType?: number): VNode | Array&lt;VNode&gt; &#123; ... let vnode, ns if (typeof tag === &#x27;string&#x27;) &#123; let Ctor ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag) if (config.isReservedTag(tag)) &#123; // platform built-in elements vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ) &#125; else if ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, &#x27;components&#x27;, tag))) &#123; // component vnode = createComponent(Ctor, data, context, children, tag) &#125; else &#123; ... &#125; &#125; else &#123; // direct component options / constructor vnode = createComponent(tag, data, context, children) &#125; return vnode;&#125; 我们看看这个函数的参数： context：表示当前的vue实例，因为所有的方法最开始都是由某个vue实例调用方法引起的，就这里来说是调用$createElement引起的 tag：表示这个vnode的类型，它可以是以下几种类型： html内置的标签名，如”div” vue组件名称，如&lt;cmpName&gt;&lt;/cmpName&gt;中的”cmpName” 代表vue组件的对象，如这里的App，是从app.vue import进来的 代表vue组件的构造函数，本质上和对象是一致的 data：vnode的数据，如各种属性 children：子元素 normalizationType：暂时不管 就我们这个例子来说，App是一个对象，所以走的是下面这句代码： 12// direct component options / constructorvnode = createComponent(tag, data, context, children) 由函数createComponent返回vnode，这个函数也比较复杂，我们看看关键部分： 123456789101112131415161718192021222324252627282930313233// src/core/vdom/create-component.jsexport function createComponent ( Ctor: Class&lt;Component&gt; | Function | Object | void, data: ?VNodeData, context: Component, children: ?Array&lt;VNode&gt;, tag?: string): VNode | Array&lt;VNode&gt; | void &#123; const baseCtor = context.$options._base // plain options object: turn it into a constructor if (isObject(Ctor)) &#123; Ctor = baseCtor.extend(Ctor) &#125; data = data || &#123;&#125; // extract props const propsData = extractPropsFromVNodeData(data, Ctor, tag) // install component management hooks onto the placeholder node installComponentHooks(data) // return a placeholder vnode const name = Ctor.options.name || tag const vnode = new VNode( `vue-component-$&#123;Ctor.cid&#125;$&#123;name ? `-$&#123;name&#125;` : &#x27;&#x27;&#125;`, data, undefined, undefined, undefined, context, &#123; Ctor, propsData, listeners, tag, children &#125;, asyncFactory ) return vnode&#125; 这个函数主要就是根据App这个组件来构造一个vnode出来，它首先做了一件最关键的事：创建组件的构造函数。我们知道，所有的组件实例最终都是通过某个构造函数new出来的：new Ctor(options)，这个Ctor可以是Vue这个顶层内置构造函数，也可以是从Vue继承下来的组件构造函数。 这里的baseCtor就是Vue，Ctor就是App这个对象，我们通过Vue.extend函数将App对象转化为构造函数：Ctor = baseCtor.extend(Ctor)，extend函数构建原型链并返回创建的构造函数： 123456789101112131415161718// src/core/global-api/extend.jsVue.extend = function (extendOptions: Object): Function &#123; const Super = this extendOptions = extendOptions || &#123;&#125; const Sub = function VueComponent (options) &#123; this._init(options) &#125; Sub.prototype = Object.create(Super.prototype) Sub.prototype.constructor = Sub Sub.cid = cid++ Sub.options = mergeOptions( Super.options, extendOptions ) Sub[&#x27;super&#x27;] = Super ... return Sub&#125; 这里特别要注意的是构造函数的options属性，它是由自己的属性和父类的属性合并而成的。在通过构造函数new一个vue实例的时候，我们还会传另一个options对象进来，这个对象和构造函数本身的options一起构成vue实例最终的$options属性值。 我们继续回到createComponent函数，得到构造函数之后我们提取propsData，即传给组件的props的数据；然后调用installComponentHooks在data上面增加一个hook属性，属性里面包含四个函数，它们将会在patch过程中分别在不同的时机被调用到： 123456data.hook = &#123; init() &#123;&#125;, prepatch() &#123;&#125;, insert() &#123;&#125;, destroy() &#123;&#125;&#125; 我们后面会讲到其中的init，其他的先不管。最后就是vnode的创建了： 123456const vnode = new VNode( `vue-component-$&#123;Ctor.cid&#125;$&#123;name ? `-$&#123;name&#125;` : &#x27;&#x27;&#125;`, data, undefined, undefined, undefined, context, &#123; Ctor, propsData, listeners, tag, children &#125;, asyncFactory) 大家可以对照下VNode的构造函数看看： 123456789101112constructor ( tag?: string, data?: VNodeData, children?: ?Array&lt;VNode&gt;, text?: string, elm?: Node, context?: Component, componentOptions?: VNodeComponentOptions, asyncFactory?: Function) &#123; ...&#125; 可以看到，构造函数保存在componentOptions中，并且tag值是类似vue-component-1-app这种字符串。 这样，root实例的vnode就得到了 _update_render返回vnode之后，_update将vnode转化为真正的DOM： 1234567891011121314151617Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this const prevEl = vm.$el const prevVnode = vm._vnode const prevActiveInstance = activeInstance activeInstance = vm vm._vnode = vnode if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode) &#125; activeInstance = prevActiveInstance ... &#125; 返回的vnode保存在_vnode中，然后看之前的_vnode是否存在，不存在的话表示第一次渲染，否则只是更新。无论如何都是调用__path__函数，__path__函数定义如下： 123456789101112131415// src/platforms/web/runtime/index.jsimport &#123; patch &#125; from &#x27;./patch&#x27;Vue.prototype.__patch__ = inBrowser ? patch : noop// src/platforms/web/runtime/patch.jsimport * as nodeOps from &#x27;web/runtime/node-ops&#x27;import &#123; createPatchFunction &#125; from &#x27;core/vdom/patch&#x27;import baseModules from &#x27;core/vdom/modules/index&#x27;import platformModules from &#x27;web/runtime/modules/index&#x27;// the directive module should be applied last, after all// built-in modules have been applied.const modules = platformModules.concat(baseModules)export const patch: Function = createPatchFunction(&#123; nodeOps, modules &#125;) 可以看到最终的patch函数是src&#x2F;core&#x2F;vdom&#x2F;patch.js中的createPatchFunction的返回值，整个这个文件就是来生成真正的DOM的： 12345678910// src/core/vdom/patch.jsexport function createPatchFunction (backend) &#123; const &#123; modules, nodeOps &#125; = backend /* 定义了一大堆内部函数 */ return function patch (oldVnode, vnode, hydrating, removeOnly) &#123; ... &#125;&#125; 我们以这个例子看看首次渲染是如何进行的，首次渲染调用如下： 1vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) 在渲染之前vm.$el的值是html中div#app元素($mount(&#39;#app&#39;))，vnode是当前_vnode，hydrating只有在SSR时才是true，其他情况都是false，以这些参数，我们看看patch函数是如何执行的，为简单起见，我们只保留这个例子要执行的代码路径： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// src/core/vdom/patch.js function patch (oldVnode, vnode, hydrating, removeOnly) &#123; if (isUndef(vnode)) &#123; ... &#125; let isInitialPatch = false const insertedVnodeQueue = [] if (isUndef(oldVnode)) &#123; ... &#125; else &#123; const isRealElement = isDef(oldVnode.nodeType) if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; ... &#125; else &#123; if (isRealElement) &#123; // mounting to a real element oldVnode = emptyNodeAt(oldVnode) &#125; // replacing existing element const oldElm = oldVnode.elm const parentElm = nodeOps.parentNode(oldElm) // create new node createElm( vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a // leaving transition. Only happens when combining transition + // keep-alive + HOCs. (#4590) oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm) ) // destroy old node if (isDef(parentElm)) &#123; removeVnodes(parentElm, [oldVnode], 0, 0) &#125; else if (isDef(oldVnode.tag)) &#123; ... &#125; &#125; &#125; ... return vnode.elm &#125; 因为这里的oldVnode是一个dom元素，isRealElement为true，所以会调用createElm来创建vnode对应的根元素并保存在vnode的elm属性中，整个patch函数返回的也是这个根元素。我们来看看createElm的实现，和之前一样，只列出关键代码： 12345678910111213141516171819202122232425262728293031323334353637383940function createElm ( vnode, insertedVnodeQueue, parentElm, refElm, nested, ownerArray, index ) &#123; if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123; return &#125; const data = vnode.data const children = vnode.children const tag = vnode.tag if (isDef(tag)) &#123; vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode) setScope(vnode) /* istanbul ignore if */ if (__WEEX__) &#123; ... &#125; else &#123; createChildren(vnode, children, insertedVnodeQueue) if (isDef(data)) &#123; invokeCreateHooks(vnode, insertedVnodeQueue) &#125; insert(parentElm, vnode.elm, refElm) &#125; &#125; else if (isTrue(vnode.isComment)) &#123; vnode.elm = nodeOps.createComment(vnode.text) insert(parentElm, vnode.elm, refElm) &#125; else &#123; vnode.elm = nodeOps.createTextNode(vnode.text) insert(parentElm, vnode.elm, refElm) &#125; &#125; 这个函数接受七个参数，我们先只关注第一、三、四个，vnode不用说；parentElm和refElm表示将要创建的根节点的父元素和后面的兄弟元素，我们需要将根节点插入到指定位置。函数开头先用前四个参数调用createComponent，并且如果返回值为true的话直接结束，后面那一大段代码都不用执行了，就我们的例子来说，返回值确实是true。实际上在vm.$createElement中所有由createComponent(不是这里的createComponent)创建的vnode调用这里的createComponent都会返回true： 1234567891011121314151617181920// src/core/vdom/create-element.jsexport function _createElement ( ...): VNode | Array&lt;VNode&gt; &#123; if (typeof tag === &#x27;string&#x27;) &#123; if (config.isReservedTag(tag)) &#123; ... &#125; else if (...) &#123; // component vnode = createComponent(Ctor, data, context, children, tag) &#125; else &#123; ... &#125; &#125; else &#123; // direct component options / constructor vnode = createComponent(tag, data, context, children) &#125; return vnode&#125; 我们来看看patch中的createComponent： 123456789101112131415161718// src/core/vdom/patch.jsfunction createComponent (vnode, insertedVnodeQueue, parentElm, refElm) &#123; let i = vnode.data if (isDef(i)) &#123; if (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) &#123; i(vnode, false /* hydrating */) &#125; // after calling the init hook, if the vnode is a child component // it should&#x27;ve created a child instance and mounted it. the child // component also has set the placeholder vnode&#x27;s elm. // in that case we can just return the element and be done. if (isDef(vnode.componentInstance)) &#123; initComponent(vnode, insertedVnodeQueue) insert(parentElm, vnode.elm, refElm) return true &#125; &#125;&#125; 这里判断vnode中的data属性是否存在，然后在判断data中的hook及hook中的init函数是否存在，根据我们之前的分析，这些都是存在的，所以会调用vnode.data.hook.init函数，这个函数定义如下： 12345678910111213141516// src/core/vdom/create-component.jsinit (vnode: VNodeWithData, hydrating: boolean): ?boolean &#123; if ( vnode.componentInstance &amp;&amp; !vnode.componentInstance._isDestroyed &amp;&amp; vnode.data.keepAlive ) &#123; ... &#125; else &#123; const child = vnode.componentInstance = createComponentInstanceForVnode( vnode, activeInstance ) child.$mount(hydrating ? vnode.elm : undefined, hydrating) &#125;&#125;, if不满足，进入else，这里就是App这个组件实例化的地方。我们知道，这里的vnode保存了App的构造函数，我们通过createComponentInstanceForVnode创建一个App实例，并将它保存在componentInstance属性中： 123456789101112// src/core/vdom/create-component.jsexport function createComponentInstanceForVnode ( vnode: any, // we know it&#x27;s MountedComponentVNode but flow doesn&#x27;t parent: any, // activeInstance in lifecycle state): Component &#123; const options: InternalComponentOptions = &#123; _isComponent: true, _parentVnode: vnode, parent &#125; return new vnode.componentOptions.Ctor(options)&#125; App的构造函数我们之前讲过了，这里我们给构造函数再传了一个options，注意options中包含的值，这些值最终都会被合并到被创建的vm实例的$options属性中。 创建完App的实例后再调用$mount将这个实例渲染出来，这又会重新走一次_render和_update的过程，只不过当前实例变成了刚创建的App组件实例，而不是我们现在正在分析的根组件实例。这个重新的过程我们暂时按下不表，我们先假设它们已经走完了，这样我们从hook.init返回了重新来到了这里： 123456789101112131415161718192021// src/core/vdom/patch.jsfunction createComponent (vnode, insertedVnodeQueue, parentElm, refElm) &#123; let i = vnode.data if (isDef(i)) &#123; if (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) &#123; i(vnode, false /* hydrating */) &#125; // 返回了，vnode.componentInstance已经保存了App实例 // after calling the init hook, if the vnode is a child component // it should&#x27;ve created a child instance and mounted it. the child // component also has set the placeholder vnode&#x27;s elm. // in that case we can just return the element and be done. if (isDef(vnode.componentInstance)) &#123; initComponent(vnode, insertedVnodeQueue) insert(parentElm, vnode.elm, refElm) return true &#125; &#125;&#125; 再往下的if为真，我们先执行initComponent： 1234567// src/core/vdom/patch.jsfunction initComponent (vnode, insertedVnodeQueue) &#123; ... vnode.elm = vnode.componentInstance.$el ...&#125; 关键的代码就上面一句，App实例(vnode.componentInstance)mount之后，实例中的$el就是它的根元素，我们把它赋给vnode.elm。 接下来就是insert操作，这才是真正的dom操作，把这个渲染好的根元素插入到指定位置：insert(parentElm, vnode.elm, refElm)： 123456789101112// src/core/vdom/patch.jsfunction insert (parent, elm, ref) &#123; if (isDef(parent)) &#123; if (isDef(ref)) &#123; if (nodeOps.parentNode(ref) === parent) &#123; nodeOps.insertBefore(parent, elm, ref) &#125; &#125; else &#123; nodeOps.appendChild(parent, elm) &#125; &#125;&#125; 至此，根组件就展示在页面上面了： 由于createComponent返回true，createElm直接返回，这样patch继续： 1234567891011121314151617181920212223242526272829303132// src/core/vdom/patch.js function patch (oldVnode, vnode, hydrating, removeOnly) &#123; if (isUndef(oldVnode)) &#123; ... &#125; else &#123; if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; ... &#125; else &#123; // create new node createElm( vnode, insertedVnodeQueue, // extremely rare edge case: do not insert if old element is in a // leaving transition. Only happens when combining transition + // keep-alive + HOCs. (#4590) oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm) ) // 继续 // destroy old node if (isDef(parentElm)) &#123; removeVnodes(parentElm, [oldVnode], 0, 0) &#125; else if (isDef(oldVnode.tag)) &#123; ... &#125; &#125; &#125; return vnode.elm &#125; 我们新创建了一个根元素(vnode.elm)，所以需要把以前的删掉：removeVnodes(parentElm, [oldVnode], 0, 0)。然后就返回新的根元素，重新回到_update： 1vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */) 至此，故事告一段落，下次继续讲解App实例是怎么mount的。","tags":[{"name":"vue","slug":"vue","permalink":"http://tomwang1013.github.io/tags/vue/"},{"name":"read-source-code","slug":"read-source-code","permalink":"http://tomwang1013.github.io/tags/read-source-code/"}]},{"title":"property descriptor的几个疑难点","date":"2018-10-29T02:18:05.000Z","path":"property-attribtes-tips/","text":"property descriptor是javascript对象中属性的描述对象，包括了这个属性的meta信息，基本知识大家都知道，这里总结一些很隐晦的容易忽略的注意点 writable vs configurable writable控制value能否更改： 如果writable &#x3D; true, value可以(通过赋值直接)修改，和configurable无关 如果writable &#x3D; false, value不可以(通过赋值直接)修改，但是如果此时configurable为true，则仍然可以通过defineProperty修改value的值 configurable控制能否修改descriptor的所有属性以及能否删除属性(delete o.foo) 如果configurable为true，没啥说的，descriptor中什么都能改 如果configurable为false，按理说，descriptor中什么都不能改，但是有一个例外：writable能从true改成false defineProperty vs assignmentdefineProperty和直接赋值(assignment)都能定义或修改属性，但是它们还是有很多不同点的： descriptor中的默认值不一样 1234567891011let o = &#123;&#125;Object.defineProperty(o, &#x27;foo&#x27;, &#123; value: 1&#125;)// &#123; value: 1, writable: false, enumerable: false, configurable: false&#125;Object.getOwnPropertyDescriptor(o, &#x27;foo&#x27;)o.bar = 1// &#123; value: 1, writable: true, enumerable: true, configurable: true&#125;Object.getOwnPropertyDescriptor(o, &#x27;bar&#x27;) 是否需要考虑原型链的情况不一样 defineProperty和原型链完全无关：它只会定义一个新的属性或修改现有的own property assignment情况有点复杂： 如果这个属性存在setter(own or inherited)，直接调用setter 如果这个属性是只读的(own or inherited)，抛出异常或静静地失败 如果这个属性是own(可写)的，修改这个属性的值 如果这个属性不存在(own or inherited)，定义一个新的own属性 如果这个属性是inherited且是writable，也是一个新的own属性(覆盖掉inherited的属性) 应该包含了所有情况吧！ 保护对象：preventExtensions vs seal vs freeze为了防止对象被修改，javascript也提供了三种方法，它们的不同点在于对对象的保护程度，按保护程度从小到大依次为：preventExtensions &lt; seal &lt; freeze，freeze的保护程度是最强的。我们在使用的时候按照自己的需求选择合适的方法，下面依次介绍一下： preventExtensions 防止往对象上添加新的属性(defineProperty or assignment) seal 除了preventExtensions之外，还把所有属性置为”unconfigurable” 1234567891011let o = &#123; foo: 1 &#125;// before sealing: &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;Object.getOwnPropertyDescriptor(o, &#x27;foo&#x27;)Object.seal(o)// after sealing: &#123;value: 1, writable: true, enumerable: true, configurable: false&#125;Object.getOwnPropertyDescriptor(o, &#x27;foo&#x27;)// 依然可以修改属性的值o.foo = 2 freeze 除了seal之外，还把所有属性置为”unwritable”，就是说属性的值也不能修改了，这是最彻底的：不能增&#x2F;删&#x2F;改，也不能修改descriptor 注意：上面所有的保护措施只针对对象本身，和它的原型链无关","tags":[{"name":"javascript","slug":"javascript","permalink":"http://tomwang1013.github.io/tags/javascript/"},{"name":"es5","slug":"es5","permalink":"http://tomwang1013.github.io/tags/es5/"}]},{"title":"一文读懂vue响应式系统实现过程","date":"2018-10-28T10:45:11.000Z","path":"vue-reactive/","text":"和众多前端框架一样，vue的数据驱动系统是它的核心，很多人都大概知道它是通过Object.defineProperty将普通属性变成get,set实现的，但知道这一点其实没啥用，因为实际情况远比这个复杂、精巧，本文尝试对整个响应式系统做一个简短、清晰、全面而不失深度的总结。以我自己这两年来使用vue的经验，了解这个系统是如何运作的对用好vue是非常有帮助的 概述数据驱动系统用一句话来概括就是：当数据变化时，自动通知监听者(也叫观察者、依赖者等)，这里面有两个主体：一是数据(data)，二是监听者(watcher)。它们两个是多对多的关系：一个数据可以有多个监听者，同时一个监听者可以同时监听多个数据： 既然要通知，就牵涉到两个问题： 怎么知道数据变化了？ 通知谁？ 我们先看下第一个问题：怎么知道数据变化了？ 这个问题很简单，当我们改变对象某个属性的值，如obj.foo = 1时，如果foo是一个setter属性，那这个赋值操作就会调用setter函数，所以在setter函数中我们就可以知道属性的值变了。所以数据驱动的第一步便是要将数据对象的普通属性转为化accessor属性，我们称这一步为将数据变成响应式。 再来看第二个问题：数据变化时，通知谁？ 很简单：谁依赖于我就通知谁啊。所以问题变成如何收集所有的对此数据的监听者。所谓监听者依赖于数据，指的是监听者在自身的执行过程中访问了数据，所以当其所访问的数据发生变化时，我们需要通知他重新执行一下。所以，我们可以在数据被访问的时候(getter)将当前的访问者(假设我们知道)保存起来，然后在数据变化的时候依次通知他们更新, 伪代码如下： 12345678910111213let obj = &#123; const watchers = []; // 对foo字段的监听者 get foo() &#123; // 假设当前的访问者是currentWatcher watchers.push(currentWatcher) &#125;， set foo(newValue) &#123; // 数据变化，通知所有监听者更新 watchers.forEach(w =&gt; w.update()) &#125;&#125; 所以整个数据驱动系统可以用下面的图简单概括： 下面我们依次从源码分析图中的各个步骤是如何实现的。vue中响应式模块的代码如下，后面我们会直接引用文件名而忽略路径信息： 将数据变成响应式要构建响应式数据系统，首先要把数据变成响应式，准确地说是把一个对象变成响应式，这样我们就能知道何时访问或修改了这个对象的属性。根据前面的描述，这个过程很简单，就是遍历对象的所有属性，利用defineProperty把它们变成accessor(getter &amp; setter)，但是需要注意以下几点： 对象的每个属性都是单独收集自己的watcher的，所以在遍历的过程中需要为每个属性准备一个专属于它的容器来保存将来要收集的监听者 根据情况我们需要深度遍历：属性的值可能也是个对象，我们需要把这个子对象也变成响应式 如果这个对象是一个数组，我们需要把数组的每个元素变成响应式 根据这几点，我们来看看源码，把对象变成响应式的入口在index.js的observe中： 123456export function observe (value: any, asRootData: ?boolean): Observer | void &#123; ... ob = new Observer(value) ... return ob;&#125; 这个入口函数主要是做了一些判断，看看value能否转成响应式以及是否已经是响应式了，真正的入口是Observer这个class的构造函数： 12345678910111213141516171819202122232425262728// index.js: 省略了一些代码export class Observer &#123; value: any; // 需要转成响应式的对象 constructor (value: any) &#123; this.value = value if (Array.isArray(value)) &#123; // 如果是数组，把数组的每个元素变成响应式 this.observeArray(value) &#125; else &#123; // 如果是普通对象，遍历它的每个属性，将其变成accessor属性 this.walk(value) &#125; &#125; walk (obj: Object) &#123; const keys = Object.keys(obj) for (let i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]) &#125; &#125; observeArray (items: Array&lt;any&gt;) &#123; for (let i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]) &#125; &#125;&#125; 可以看到，真正把对象的某个属性变成accessor的是defineReactive，对于每个属性，都需要调用一次这个函数： 12345678910111213141516171819202122232425262728293031// index.js: 省略部分代码export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) &#123; // 这个属性(key)专有的用来收集watcher的容器 const dep = new Dep() // 深度遍历：将所有子对象也变成响应式 let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; const value = getter ? getter.call(obj) : val // 如果当前存在监听者，将它收集起来 if (Dep.target/*当前监听者*/) &#123; dep.depend() // 收集动作 &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; // 如果数据发生变化，通知所有收集到的监听者 dep.notify() &#125; &#125;)&#125; 这些代码实现完全印证了我们前面的思路：当后面有watcher访问响应式对象的属性时，getter被调用，访问者被对应属性收集 扩充及边界：再看Observer前面我们讲的是主体思想及实现，我们贴的代码也是精简过的，真实实现要比这个复杂一些，有很多边界条件及系统的健壮性可用性需要考虑，考虑以下两个问题： 如果一个watcher依赖于对象o的属性a，而a本身是一个对象： 123let o = &#123; a: &#123; b: 2 &#125;&#125; 按照我们前面贴出的代码，我们直接赋给o.a一个新的值是可以触发watcher的更新操作的，但是给o.a对象新增或删除一个属性却不会通知watcher： 123456// 可以触发watcher更新o.a = &#123; c: 2 &#125; // 新增或删除字段都不会触发o.a.c = 2delete o.b 而一般情况下，后面2种操作我们也是需要触发的，所以需要提供给用户某种接口，使得新增或删除字段时也能触发更新 如果一个watcher依赖于对象o的属性a，而a本身是一个数组： 123let o = &#123; a: [1, 2]&#125; 同理，按照我们前面贴出的代码，我们直接赋给o.a一个新的值是可以触发watcher的更新操作的，但是给o.a对象新增或删除数组元素时却不会触发： 123456789// 可以触发watcher更新o.a = [3, 4] // 新增或删除字段都不会触发o.a.splice(0, 1, 10);o.a.push(3)o.a.pop()... 而一般情况下，我们是希望触发的，所以vue也需要对数组做些特殊处理，使得我们对数组的改动也能触发watcher的更新 这两种情况，vue作者都做了考虑，答案就在Observer中，我们重新看下它的构造函数未贴出的部分： 123456789101112131415161718export class Observer &#123; dep: Dep; // 收集依赖于整个value对象的watcher constructor (value: any) &#123; this.dep = new Dep() def(value, &#x27;__ob__&#x27;, this) if (Array.isArray(value)) &#123; const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) ... &#125; else &#123; ... &#125; &#125;&#125; 这里面有两个重要的变化： Observer对象定义了一个dep字段，我们知道dep对象是用来收集watcher的，但是这里的dep不是和value对象的某个属性绑在一起，而是和整个value相关联，它起的作用正是收集依赖于整个value对象的所有watcher，当value增加删除字段(如果value是纯对象)或元素(如果value是数组)自动通知watcher更新。那什么叫依赖于整个value对象呢？很简单，就是value作为其他响应式对象的一个属性的值，而watcher依赖于这个属性，如： 12345const o = &#123; a: &#123; b: 1 &#125;&#125; 如果w依赖于o.a，那么我们就说w依赖于o.a对应的整个对象：&#123; b: 1 &#125;。假设value &#x3D; o.a，则经过Observer构造函数后，value的值变成如下： 1234567891011&#123; __ob__: &#123; dep // 收集依赖于外层a字段的watcher，即这里的w value &#125;, b: &#123; dep // 收集依赖于b字段的watcher get() &#123; &#125;, set() &#123; &#125; &#125; &#125; 对数组的特殊处理 同理，如果w依赖于一个数组字段value，那么这个数组经过observe之后，value.__ob__.dep也会收集这个w： 12345678910111213const o = &#123; // w依赖于o.a，value = o.a a: [1, 2]&#125;// observe(value)之后, value上多了__ob__这个属性：&#123; __ob__: &#123; dep, // 收集依赖于外层a字段的watcher，即这里的w value &#125;&#125; 此外，我们还需要监听数组元素的变化，即当用户调用push，pop等修改数组的方法时会自动通知watcher，vue实现的原理是改写这些数组方法，并拦截调用，这就是下面这几行代码做的事： 1234const augment = hasProto ? protoAugment : copyAugment augment(value, arrayMethods, arrayKeys) 讲到这里，我们可以知道，一个对象是否是响应式的，只要看看它有没有__ob__属性。另外，有时还需要关注它是否是另一个响应式对象的某个属性的值，即这个对象是不是顶层对象，如果是顶层对象的话，它的__ob__.dep中是没有监听者的，vue组件中的data对象就是一个顶层对象 收集监听者前面我们反复提到了Dep类(上面的dep都是它的实例)就是用来收集watcher的，这节我们仔细看看它和数据及watcher三者的关系，我们先看看较为简单的Dep Dep一个dep从属于某个响应式属性，里面包含了所有依赖于该属性的watcher，它的实现比较简单： 12345678910111213141516171819202122232425262728293031323334export default class Dep &#123; static target: ?Watcher; // 当前监听者：任何时刻最多只有一个监听者 id: number; // dep的唯一标识 subs: Array&lt;Watcher&gt;; // 收集到的所有watcher constructor () &#123; this.id = uid++ this.subs = [] &#125; addSub (sub: Watcher) &#123; this.subs.push(sub) &#125; removeSub (sub: Watcher) &#123; remove(this.subs, sub) &#125; // 收集watcher depend () &#123; if (Dep.target) &#123; // 收集watcher动作：将当前watcher收集起来 Dep.target.addDep(this) &#125; &#125; // 通知watcher更新 notify () &#123; const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125; &#125;&#125; 基本没啥说的，唯一要注意的地方是在depend中，我们不是直接调用addSub将当前watcher收集起来，而是调用watcher的addDep方法，其实watcher.addDep内部最终也是调用dep.addSub(this)的，只是它还做了一些其他处理，这个我们后面会说。 这里再强调一点：dep和watcher是多对多的关系： dep需要管理自己的watchers，通过addSub和removeSub随时更新watchers，但是这两个动作都是由watcher发起的。watcher也需要管理自己当前正在监听的所有数据，即管理和这些数据关联的deps。 watcher终于讲到watcher了，我们把数据变成响应式之后，需要访问数据(调用数据属性的getter)才能将当前的访问者收集起来，这个访问动作就是由watcher发起的。简单地说，这个访问动作就是调用一个求值函数。所以构建一个watcher需要至少提供： 求值函数 回调函数：求值函数返回的值发生变化时回调 另外，任何一个watcher都属于某个vue组件实例， 此外，watcher还需要保存所依赖的所有deps，我们看看简化的源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// watcher.jsexport default class Watcher &#123; vm: Component; // 所属的vue实例 cb: Function; // 当value发生变化时的回调函数 id: number; // 标识watcher的唯一id // 需要维护的依赖集 deps: Array&lt;Dep&gt;; newDeps: Array&lt;Dep&gt;; depIds: SimpleSet; newDepIds: SimpleSet; getter: Function; // 求值函数 value: any; // 求值函数返回结果 constructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: ?Object, isRenderWatcher?: boolean ) &#123; this.vm = vm // vm把自己的watchers保存起来 vm._watchers.push(this) this.cb = cb this.id = ++uid // uid for batching this.deps = [] this.newDeps = [] this.depIds = new Set() this.newDepIds = new Set() // parse expression for getter if (typeof expOrFn === &#x27;function&#x27;) &#123; this.getter = expOrFn &#125; else &#123; this.getter = parsePath(expOrFn) &#125; // 求值：触发收集操作 this.value = this.get() &#125; /** * Subscriber interface. * Will be called when a dependency changes. */ update () &#123; &#125;&#125; 精简后的watcher实现应该比较好理解了，getter保存了我们的求值函数，构造函数末尾我们通过watcher.get函数的调用触发求值函数，从而将watcher收集到所有的求值过程中遇到的dep中： 123456789101112131415/** * Evaluate the getter, and re-collect dependencies. */get () &#123; pushTarget(this) // 将此watcher设置为当前watcher let value const vm = this.vm // 调用求值函数，启动收集过程 value = this.getter.call(vm, vm) popTarget() // 还原当前watcher this.cleanupDeps() return value&#125; 函数开始我们先将自己设置为当前watcher，然后调用求值函数，启动收集过程，这个过程中每次访问到响应式属性都会触发下面的调用过程： 1data.getter() =&gt; dep.depend() =&gt; watcher.addDep() =&gt; (可选)dep.addSub() 我们来看看watcher.addDep，看看为什么不直接在dep.depend中调用dep.addSub，而需要绕一圈： 12345678910111213/** * Add a dependency to this directive. */addDep (dep: Dep) &#123; const id = dep.id if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) &#123; dep.addSub(this) &#125; &#125;&#125; 在构造函数中我们看到watcher定义了下面四个字段来管理依赖，它们的意义如下： 1234567// 保存当前的依赖集 newDeps: Array&lt;Dep&gt;;newDepIds: SimpleSet;// 保存上一次求值时的依赖集deps: Array&lt;Dep&gt;;depIds: SimpleSet; 为什么要这多呢？其实这是用来避免将一个watcher重复收集在同一个dep中的。假设getter函数如下： 123function fn() &#123; return o.a + o.a;&#125; o.a是一个响应式数据，如果我们不做处理的话，o.a.dep中将包含2个一样的watcher，这是为了在同一次求值过程中避免重复收集依赖；还有一种情况需要考虑：watcher的多次求值，这种情况我们同样需要避免重复收集watcher。所以我们在watcher中不但要保存当前求值正在收集的依赖(newDeps, newDepIds)，还需要保存上一次求值收集的依赖，每次求完值之后，我们会把newDeps赋值给deps，并把newDeps清空，这是通过在求值最后调用cleanupDeps实现的： 1234567891011121314151617cleanupDeps () &#123; let i = this.deps.length while (i--) &#123; const dep = this.deps[i] if (!this.newDepIds.has(dep.id)) &#123; dep.removeSub(this) &#125; &#125; let tmp = this.depIds this.depIds = this.newDepIds this.newDepIds = tmp this.newDepIds.clear() tmp = this.deps this.deps = this.newDeps this.newDeps = tmp this.newDeps.length = 0&#125; 这个函数的逻辑分成两部分：后面的部分就是newDeps赋值给deps，并把newDeps清空；前一部分是解除废弃的依赖，就是说如果watcher不再依赖于某个数据了，需要把watcher从这个数据的依赖集中去掉：dep.removeSub。 vue中watcher的分类在watcher的构造函数中，有几个实例属性我们没有讲到，这牵涉到watcher的分类，我们来看看： 1234567891011121314151617181920212223// watcher.jsconstructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: ?Object, isRenderWatcher?: boolean) &#123; this.vm = vm if (isRenderWatcher) &#123; vm._watcher = this &#125; vm._watchers.push(this) // options if (options) &#123; this.user = !!options.user this.computed = !!options.computed &#125; else &#123; this.user = this.computed = false &#125; ...&#125; 参数isRenderWatcher表示watcher是否是渲染watcher，我们知道每个vue实例都有一个渲染函数，它监控实例数据的变化并重新渲染dom，渲染watcher保存在vue实例的_watcher中，渲染watcher在src&#x2F;core&#x2F;instance&#x2F;lifecycle.js中创建，大家有兴趣可以看看： 12345678910111213141516171819// lifecycle.jsexport function mountComponent ( vm: Component, el: ?Element, hydrating?: boolean): Component &#123; ... // we set this to vm._watcher inside the watcher&#x27;s constructor // since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child // component&#x27;s mounted hook), which relies on vm._watcher being already defined new Watcher(vm, updateComponent, noop, &#123; before () &#123; if (vm._isMounted) &#123; callHook(vm, &#x27;beforeUpdate&#x27;) &#125; &#125; &#125;, true /* isRenderWatcher */) ...&#125; 另外两个属性user和computed的意义分别如下： user：标识是否是用户定义的watcher，即用户通过vm.$watch函数或watch选项定义的watcher computed：标识是否是计算属性watcher，即系统自动为计算属性创建的watcher，它监听计算属性所依赖的数据的变化并更新计算属性的值 再看getter看了dep和watcher的实现，我们对依赖收集的整个过程应该比较清楚了，下面我们再看看getter中省略的部分： 123456789101112131415161718192021222324252627282930export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) &#123; const dep = new Dep() ... let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; const value = getter ? getter.call(obj) : val if (Dep.target) &#123; ... if (childOb) &#123; childOb.dep.depend() if (Array.isArray(value)) &#123; dependArray(value) &#125; &#125; &#125; return value &#125; &#125;)&#125; 这里我们重点看看if (childOb)里面的代码，我们先看看childOb是怎么来的： 1let childOb = !shallow &amp;&amp; observe(val) 如果val是一个对象，我们需要把这个对象也变成响应式，并把val.__ob__保存在childOb中。前面说过，如果一个watcher依赖于这个字段(key)，那么它也依赖于整个对象(val)，所以把它也收集到val中：childOb.dep.depend()。 除了这个之外，还有一段代码： 123if (Array.isArray(value)) &#123; dependArray(value) &#125; 这里的意思是，如果这个字段对应的值是一个数组，需要再调用一个函数：dependArray： 12345678910// index.jsfunction dependArray (value: Array&lt;any&gt;) &#123; for (let e, i = 0, l = value.length; i &lt; l; i++) &#123; e = value[i] e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend() if (Array.isArray(e)) &#123; dependArray(e) &#125; &#125;&#125; 这个函数的意思很明显：递归遍历数组的每个元素，如果这个元素也是个响应式对象，那么这个元素也需要把当前的watcher收集起来，举例来说： 123const o = &#123; a: [&#123; b: 1 &#125;, &#123; c: 2 &#125;]&#125; 如果w依赖于o.a, 且o.a的每个元素都是响应式对象，那么这些对象新增或删除元素(通过vue提供的api)也会引起w的更新： 1Vue.set(o.a[0], &#x27;key1&#x27;, &#x27;val1&#x27;) // 引起w的更新 总结响应式数据需要通过dep收集监听者(watcher)，而watcher也需要收集并管理其依赖的所有依赖集(dep)，这个过程都是由watcher的求值发起的，这个过程中需要避免重复收集依赖 通知监听者更新响应式系统的第三步便是修改数据，通知watcher更新，调用流程如下： 1data.setter() -&gt; dep.notify() -&gt; watcher.update() 我们先看看setter setter简略代码如下： 1234567891011121314151617181920export function defineReactive ( obj: Object, key: string, val: any, customSetter?: ?Function, shallow?: boolean) &#123; const dep = new Dep() ... let childOb = !shallow &amp;&amp; observe(val) Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, set: function reactiveSetter (newVal) &#123; ... childOb = !shallow &amp;&amp; observe(newVal) dep.notify() &#125; &#125;)&#125; 主要代码就两句，第二句dep.notify()就是通知所有watcher更新，没啥说的。第一句childOb = !shallow &amp;&amp; observe(newVal)在getter中也见过：如果我们新附的值也是一个对象，那没说的，需要把这个新对象也变成响应式 dep.notifydep中保存了所有依赖的watcher，数据变化时挨个通知它们就行了： 12345678// dep.jsnotify () &#123; // stabilize the subscriber list first const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update() &#125;&#125; watcher.updatewatcher怎么更新很重要的一件事，有不少问题需要考虑： 同步还是异步 一个watcher的多个依赖数据同时修改，如何保证它只更新一次？ 多个watcher需要更新，它们的更新顺序有没有要求？ watcher在更新过程中又触发了新的更新(包含它自己的)怎么处理？ 我们一边看代码一边讲解这些问题是如何处理的，首先看看入口函数：watcher.update: 12345678910// watcher.jsupdate () &#123; if (this.computed) &#123; ... &#125; else if (this.sync) &#123; this.run() &#125; else &#123; queueWatcher(this) &#125;&#125; 我们先不考虑this.computed为true的情况，后面会单独讲计算属性。this.sync标识watcher是否是同步的，如果是，马上执行更新操作，这个标识可以在创建watcher的时候指定；如果不是，我们把watcher缓存起来，后面统一异步更新，所以watcher的更新一般是异步的，这是为了效率考虑。 无论是异步还是同步，最后都会调用watcher.run： 123456// watcher.jsrun () &#123; if (this.active) &#123; this.getAndInvoke(this.cb) &#125;&#125; active标识watcher是否还有效，如果有效，会调用watcher.getAndInvoke，顾名思义，这个函数就是重新求值并调用回调函数： 1234567891011121314151617// watcher.jsgetAndInvoke (cb: Function) &#123; const value = this.get() if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. isObject(value) || this.deep ) &#123; // set new value const oldValue = this.value this.value = value cb.call(this.vm, value, oldValue) &#125;&#125; 首先求出最新的值，然后判断该不该调用回调函数，判断条件有三个： 值发生了变化 值没变化，但是值是一个对象，说明对象内部发生了变化 deep为true 这三种情况都应该调用回调函数 异步批量更新入口：queueWatcher: 1234567891011121314151617181920212223242526272829// scheduler.jsconst queue: Array&lt;Watcher&gt; = [] // 缓存所有待更新的watcher的队列let has: &#123; [key: number]: ?true &#125; = &#123;&#125; // 保证队列中watcher不会重复let waiting = false // 是否已经安排watcher批量更新let flushing = false // watcher的批量更新是否正在进行let index = 0 // 当前正在进行更新的watcher在queue中的下标export function queueWatcher (watcher: Watcher) &#123; const id = watcher.id if (has[id] == null) &#123; has[id] = true if (!flushing) &#123; queue.push(watcher) &#125; else &#123; // if already flushing, splice the watcher based on its id // if already past its id, it will be run next immediately. let i = queue.length - 1 while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123; i-- &#125; queue.splice(i + 1, 0, watcher) &#125; // queue the flush if (!waiting) &#123; waiting = true nextTick(flushSchedulerQueue) &#125; &#125;&#125; 这个函数回答了我们前面关于watcher.update的第二和第四个问题，首先我们用has对象记录所有待更新的watcher是否已经放入更新队列，这样保证同一个watcher被多次触发更新时只会进入队列一次。 flushing标识批量更新是否正在进行，如果不在进行，直接将watcher放入更新队列末尾；否则，将watcher按id大小放入队列中的对应位置(后面会提到，队列在批量更新之前会先按id升序排序)，就是说，更新过程中可能有watcher被不断加入队列，我们要确保中途加进来的watcher也能在本次批量中得到更新。 waiting标识watcher的批量更新这个整体动作是否已经放入javascript的异步队列，防止这个动作被触发多次，你可以理解为和防止按钮被多次点击而采取的在首次点击都先disable，事件处理完再enable的逻辑差不多。 这里的nextTick(cb)你可以简单地理解为setTimeout(cb, 0)，真正的批量更新操作在flushSchedulerQueue中, 代码简化如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// scheduler.jsfunction flushSchedulerQueue () &#123; flushing = true let watcher, id // Sort queue before flush. // This ensures that: // 1. Components are updated from parent to child. (because parent is always // created before the child) // 2. A component&#x27;s user watchers are run before its render watcher (because // user watchers are created before the render watcher) // 3. If a component is destroyed during a parent component&#x27;s watcher run, // its watchers can be skipped. queue.sort((a, b) =&gt; a.id - b.id) // do not cache length because more watchers might be pushed // as we run existing watchers for (index = 0; index &lt; queue.length; index++) &#123; watcher = queue[index] if (watcher.before) &#123; watcher.before() &#125; id = watcher.id has[id] = null watcher.run() // in dev build, check and stop circular updates. if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; has[id] != null) &#123; circular[id] = (circular[id] || 0) + 1 if (circular[id] &gt; MAX_UPDATE_COUNT) &#123; warn( &#x27;You may have an infinite update loop &#x27; + ( watcher.user ? `in watcher with expression &quot;$&#123;watcher.expression&#125;&quot;` : `in a component render function.` ), watcher.vm ) break &#125; &#125; &#125; // keep copies of post queues before resetting state const activatedQueue = activatedChildren.slice() const updatedQueue = queue.slice() resetSchedulerState() // call component updated and activated hooks callActivatedHooks(activatedQueue) callUpdatedHooks(updatedQueue)&#125; 首先将flushing置为true，表示批量更新正在进行。 然后对watcher按id进行升序排序，排序的原因注释里已经写了，这牵涉到其他模块的知识，大家先可以不必深究。 之后从队列中依次取出watcher调用run函数进行更新，before是创建watcher时提供的一个函数选项，表示在更新在之前的回调。这里还做了一个循环触发更新的监测，我们知道在队列的更新中不断有watcher被加入队列中，如果同一个watcher被加入很多次，有可能就是一个死循环，需要监测出来提醒用户 队列更新完之后再做一些更新后的回调，如果有的话 computed属性实现原理我们知道计算属性和普通方法的区别就是计算属性不会每次访问都重新求值，而是它会监听求值过程中的数据的变化，有变化时才会重新求值，就这点来说，它和watcher的性质是一样的，不难想到计算属性是使用watcher实现的，每个计算属性内部都对应一个watcher，其computed属性为true。 除此之外，计算属性还可以被其他watcher所依赖，这是它和普通方法的另一个重要区别。 基于这两点，computed watcher的实现和普通watcher有些不一样，我们来看看watcher作了哪些特殊处理，首先来看看构造函数： 123456789101112131415161718// watcher.jsconstructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: ?Object, isRenderWatcher?: boolean ) &#123; ... this.dirty = this.computed // for computed watchers ... if (this.computed) &#123; this.value = undefined this.dep = new Dep() &#125; else &#123; this.value = this.get() &#125;&#125; 从构造函数可以看出2点： computed watcher还多了一个dirty属性，用来标识watcher是否需要重新求值 computed watcher在构造函数中不会马上求值以收集依赖，而是把value置为undefined且创建了一个Dep实例：this.dep = new Dep()。如果有其他的watcher依赖于计算属性的值，这个dep就是用来收集这些watcher的： 计算属性的初始化简介这里我们省略了一些细节，具体大家可以参考src&#x2F;core&#x2F;instance&#x2F;state.js中的initComputed函数 假设我们在vue实例上定义了计算属性： 12345computed: &#123; a() &#123; ... &#125;&#125; 经过初始化后，系统为每个计算属性定义了一个watcher，所有的计算属性watcher保存在_computedWatchers中： 123456789vm._computedWatchers = &#123; a: new Watcher( vm, getter || noop, // 计算属性的求值函数 noop, &#123; computed: true &#125; ) &#125;&#125; 并且在vue实例上定义了一个同名属性： 123456789101112Object.defineProperty(vm, &#x27;a&#x27;, &#123; enumerable: true, configurable: true, get: function computedGetter () &#123; const watcher = this._computedWatchers &amp;&amp; this._computedWatchers[a] if (watcher) &#123; watcher.depend() return watcher.evaluate() &#125; &#125;, set: setter // 可选&#125;) 计算属性的求值在watcher的构造函数中我们看到，computed watcher没有马上求值，而是在我们访问计算属性时才开始求值。我们通过vue实例访问计算属性的时候(如vm.a)，进入get函数，下面两句代码得以执行： 12watcher.depend()return watcher.evaluate() 第一句代码用来收集对计算属性本身的值的依赖： 123456789// watcher.js/** * Depend on this watcher. Only for computed property watchers. */depend () &#123; if (this.dep &amp;&amp; Dep.target) &#123; this.dep.depend() &#125;&#125; 注释已经写得很清楚了 第二句代码就是计算属性的求值，返回给访问者： 123456789101112// watcher.js/** * Evaluate and return the value of the watcher. * This only gets called for computed property watchers. */evaluate () &#123; if (this.dirty) &#123; this.value = this.get() this.dirty = false &#125; return this.value&#125; 可以看出它是惰性求值的，只有dirty为true，说明计算属性需要重新求值了，才重新求值，否则返回之前的值 computed watcher的更新：再看updatecomputed watcher的更新机制也不一样，我们再来看看： 1234567891011121314151617181920212223// watcher.jsupdate () &#123; /* istanbul ignore else */ if (this.computed) &#123; // A computed property watcher has two modes: lazy and activated. // It initializes as lazy by default, and only becomes activated when // it is depended on by at least one subscriber, which is typically // another computed property or a component&#x27;s render function. if (this.dep.subs.length === 0) &#123; // In lazy mode, we don&#x27;t want to perform computations until necessary, // so we simply mark the watcher as dirty. The actual computation is // performed just-in-time in this.evaluate() when the computed property // is accessed. this.dirty = true &#125; else &#123; // In activated mode, we want to proactively perform the computation // but only notify our subscribers when the value has indeed changed. this.getAndInvoke(() =&gt; &#123; this.dep.notify() &#125;) &#125; &#125;&#125; 如果是计算属性watcher，我们看看第一个if语句：if (this.dep.subs.length === 0)，它说明没有其他watcher依赖于这个计算属性，这个时候我们只是设置一些dirty，表示计算属性要重新求值，后面访问计算属性的时候它就会重新求值(见watcher.evaluate)；否则的话说明有其他watcher依赖于此计算属性，这个时候我们应该马上求值并通知其他watcher去更新 总结到此为止，整个响应式系统就差不多讲完了，其实基本思路很简单，但是细节多，但愿讲清楚了；特别感谢： http://hcysun.me/vue-design/art/的作者，其他他写得更详细，我这里只是结合自己的理解重新总结了一遍，大家要看更多细节的话可以去看看 看了一些最新的源码，有些地方改了，我这个是基于2.5.17-beta.0，最新的是正式版2.5.17，回头有时间看了再修改下","tags":[{"name":"vue","slug":"vue","permalink":"http://tomwang1013.github.io/tags/vue/"}]},{"title":"service worker之clients.claim() vs self.skipWaiting()","date":"2018-10-25T09:20:09.000Z","path":"pwa-clients-claim-vs-self-skipWaiting/","text":"service worker中有两个api出镜率很高：一个是clients.claim(), 另一个是self.skipWaiting()，我们分别看看它们的应用场景： clients.claim当页面第一次注册sw的时候，我们注意到即使此页面及其子页面处于sw的控制范围之内，但是由此页面发出的任务请求都没有经过sw，换句话说，sw在页面第一次打开的时候并没有生效。这是一个正常行为，原因如下： if your page loads without a service worker, neither will its subresources 就是说，如果页面自身的加载没有经过sw，那么它发出的所有请求也不会经过sw，这很正常，毕竟这只和首次加载有关，且即使没有sw应该也能工作良好。 如果你想改变这种情况，系统也提供了api，这就是clients.claim，你可以在sw的activate事件处理中调用，让sw马上生效，这样注册页面发出的请求在第一次页面加载的时候就会经过sw： 123456// sw.jsself.addEventListener(&#x27;activate&#x27;, e =&gt; &#123; console.log(&#x27;Service worker activating...&#x27;) clients.claim();&#125;) self.skipWaiting我们知道，当sw更新的时候如果前一版本的sw还在工作，新的sw会等待，处于waiting状态知道所有被老的sw控制的页面都关闭，这也是正常行为，有利于保证应用状态的一致性。 如果你想新的sw马上取代老的进入工作状态(即进入activate状态)，你可以在install事件处理中调用self.skipWaiting： 1234self.addEventListener(&#x27;install&#x27;, e =&gt; &#123; console.log(&#x27;Service worker installing...&#x27;) self.skipWaiting();&#125;)","tags":[{"name":"html5","slug":"html5","permalink":"http://tomwang1013.github.io/tags/html5/"},{"name":"pwa","slug":"pwa","permalink":"http://tomwang1013.github.io/tags/pwa/"}]},{"title":"web component之shadow dom","date":"2018-10-22T06:33:45.000Z","path":"web-component-shadow-dom/","text":"在custom elment中我们提到web component的封装性需要shadow dom来进一步提升，因为shadow dom具有两大特点： Isolated DOM：隔离的dom结构 Scoped CSS：作用范围受限的CSS 一句话：custom elements使我们能创建新的html元素，而shadow dom则为新的元素提供内容(html &amp; css)，它们结合在一起使web component(self-contained HTML, CSS, and JavaScript)成为可能 在下文中，我们会交换使用”自定义元素”和”组件”这两个术语，它们基本可以理解为同一个东西 下面我们从基础开始一点点揭开shadow dom的面纱 什么是shadow dom？普通的dom元素可以有自己的子节点，如： 1234&lt;div&gt; &lt;p&gt;p1&lt;/p&gt; &lt;p&gt;p2&lt;/p&gt;&lt;/div&gt; 这里的div元素有两个子元素；除此之外，我们还可以在它上面依附(attach)另一个dom树： 12345const div = document.getElementById(&#x27;to-attach-shadow&#x27;);// attach a shadow dom tree to itconst shadowRoot = div.attachShadow(&#123; mode: &#x27;open&#x27; &#125;);shadowRoot.innerHTML = &#x27;&lt;p&gt;shadow p1&lt;/p&gt;&lt;p&gt;shadow p2&lt;/p&gt;&#x27;; 依附的这个dom树就是shadow dom，它的根节点叫shadow root，而它依附的元素(这里的div)叫shadow host： 12div.shadowRoot === shadowRoot // trueshadowRoot.host === div // true 那这里的渲染结果是什么？根据之前custom element中的例子，我们应该才到原来的内容被丢弃了，渲染出来的是shadow dom中的内容： Isolated DOM这里我们通过document.querySelectorAll只能得到原来的两个p元素： shadow dom中的内容没法通过正常途径查询出来，只能通过shadow root来查： 不是所有的元素都可以attach shadow dom有些元素(如：textarea，video等)浏览器已经使用了shadow dom来实现了，你不能再加了；有些元素加shadow dom没有任何意义，如img。所以，只有部分元素可以添加shadow dom，当然这部分元素包含了所有合法的custom elements，参考attachShadow查看具体哪些元素可以 内容分发与slot我们把元素原来的子节点dom结构称为light dom，前面我们知道，默认情况下light dom是不会渲染出来的，最终的渲染结果完全由其上依附的shadow dom决定: 这样不是很灵活，有时候我们希望由组件的使用者和开发者共同决定最终的渲染内容，这就是slot的由来：我们可以在shadow dom里面指定一些slot(插槽)，用来接收来自light dom中的内容，例如： 12345shadowRoot.innerHTML = ` &lt;p&gt;shadow p1&lt;/p&gt; &lt;p&gt;shadow p2&lt;/p&gt; &lt;slot&gt;&lt;/slot&gt;`; 上面的代码将整个light dom的内容插入到slot指定位置，渲染结果： shadow dom结构： slot还可以指定name属性，然后在light dom中可以通过在元素上指定slot=slotName将对应元素渲染到指定的slot中，例如： 123456shadowRoot.innerHTML = ` &lt;p&gt;shadow p1&lt;/p&gt; &lt;slot name=&quot;slot1&quot;&gt;&lt;/slot&gt; &lt;p&gt;shadow p2&lt;/p&gt; &lt;slot&gt;&lt;/slot&gt;`; 1234&lt;div id=&quot;to-attach-shadow&quot;&gt; &lt;p slot=&quot;slot1&quot;&gt;p1&lt;/p&gt; &lt;p&gt;p2&lt;/p&gt;&lt;/div&gt; 渲染结果： dom结构： light dom中没有指定slot属性的都被渲染到默认的匿名slot中 shadow dom样式scoped cssshadow dom内部的元素样式不受外部css影响，内部定义的css也只作用于内部的元素，不影响外部，你可以把shadow root看做是一个屏障，把shadow dom和外面隔开了。比如说我们在外面定义了样式： 1234p &#123; font-size: 200%; color: red;&#125; 这个样式只影响light dom，对shadow dom没有影响： 同理，我们在shadow dom内部定义了它自己的样式(外部的样式被删除了)，对外部元素的样式没有影响： 123456789101112shadowRoot.innerHTML = ` &lt;style&gt; p &#123; font-size: 20px; color: blue; &#125; &lt;/style&gt; &lt;p&gt;shadow p1&lt;/p&gt; &lt;slot name=&quot;slot1&quot;&gt;&lt;/slot&gt; &lt;p&gt;shadow p2&lt;/p&gt; &lt;slot&gt;&lt;/slot&gt;`; 但是，shadow dom的样式还是受继承属性的影响，比如我们在body上面定义了一些继承属性，如font-size等，shadow dom也受这个影响: 1234body &#123; font-size: 20px; color: red;&#125; 特别地，shadow dom的样式从shadow host继承，受host元素样式的影响，把上面的body换成div同样成立 从shadow dom内部控制host的样式我们可以在shadow dom内部利用下面三个selector选中其所在的host元素： :host 无条件选中host :host(selector) 只有满足selector的host才被选中 :host-context(selector) 只有其本身或其祖先节点满足selector的host才被选中，是:host(selector)的超集 利用这些选择器，我们可以在shadow dom内部控制host的样式，如： 123456789101112131415shadowRoot.innerHTML = ` &lt;style&gt; :host &#123; color: red; &#125; p &#123; color: blue; &#125; &lt;/style&gt; &lt;p&gt;shadow p1&lt;/p&gt; &lt;slot name=&quot;slot1&quot;&gt;&lt;/slot&gt; &lt;p&gt;shadow p2&lt;/p&gt; &lt;slot&gt;&lt;/slot&gt;`; 结果如下： 我们在host元素(即这里的div)上设置了color: red，所以light dom中的p元素都是红色；在shadow dom内部还重新定义了p的样式：color: blue，覆盖了从host元素继承的样式，所以shadow dom内部的p是蓝色。 从shadow dom内部控制light dom的样式从上一节可以看到，light dom样式完全不受shadow dom内部样式影响，我们可以想象成light dom以外部样式渲染好了之后再插入到shadow dom的slot处。浏览器提供了一种机制：在light dom中的元素插入到slot处时，可以继续对它(已经使用外部样式渲染好了)追加一些样式： 123456789101112131415shadowRoot.innerHTML = ` &lt;style&gt; :host &#123; color: red; &#125; ::slotted(p) &#123; font-size: 30px; &#125; &lt;/style&gt; &lt;p&gt;shadow p1&lt;/p&gt; &lt;slot name=&quot;slot1&quot;&gt;&lt;/slot&gt; &lt;p&gt;shadow p2&lt;/p&gt; &lt;slot&gt;&lt;/slot&gt;`; 这使得light dom中的p元素的font-size变成30px： ::slotted(selector)只能作用于顶层元素，例如这里只能选择p元素，而不能选择p元素的子元素(如果有的话) 外部host样式优先对于host元素，我们既可以在外部也可以在内部添加样式，当发生冲突时，外部的样式优先 使用shadow dom来填充custom element前面一直以普通的div元素来讲解shadow dom的机制，其实它的最佳拍档是custom element，一般来说，我们是在自定义元素的constructor中进行填充： 12345678910111213141516export class HTMLClockElement extends HTMLElement &#123; constructor() &#123; super(); // this.innerHTML = &#x27;i am a clock custom element&#x27; const shadowRoot = this.attachShadow(&#123; mode: &#x27;open&#x27; &#125;); shadowRoot.innerHTML = ` &lt;style&gt; ... &lt;/style&gt; &lt;p&gt;from clock&#x27;s shadow dom&lt;/p&gt; &lt;slot&gt;&lt;/slot&gt; `; console.log(&#x27;custom element created&#x27;) &#125;&#125; 使用： 1&lt;x-clock&gt;i am a clock&lt;/x-clock&gt; 这样，x-clock就算得上一个真正的组件了，cool~ 高级主题有一些高级主题这里就不详细介绍了，大家碰到时可以参考google文档：https://developers.google.com/web/fundamentals/web-components/shadowdom#advanced 其中最重要的是shadow dom的事件模型：发生在shadow dom内部的事件如何处理","tags":[{"name":"html5","slug":"html5","permalink":"http://tomwang1013.github.io/tags/html5/"},{"name":"web component","slug":"web-component","permalink":"http://tomwang1013.github.io/tags/web-component/"}]},{"title":"web component之custom element","date":"2018-10-22T05:57:34.000Z","path":"web-componet-custom-element/","text":"web component是html5原生的组件机制，它由四个标准组成： custom element shadow dom html template html import 这些标准可以单独使用，也可以结合在一起使用，今天先介绍一下custom element，后面会依次介绍其他几个 native elements与custom elementshtml文档由很多基本元素组成，如div, span, ul等等，我们可以称这些已经存在的元素为native elements(本地元素)。每一种本地元素都有一个class与之对应，如div对应HTMLDivElement, span对应HTMLSpanElement，ul对应HTMLUListElement，这些class都是从HTMLElement继承下来 一个自然而然的想法是：我们能否创建一些自定义元素并使用自定义标签呢？如： 1&lt;my-tag&gt;&lt;/my-tag&gt; 答案是可以，这就是custom elements的由来 创建一种自定义元素要创建一种自定义元素，我们首先要准备一个class，就像本地的HTMLDivElement一样，从HTMLElement继承，用来定义元素的内在行为，假设我们要创建一个表示时钟的元素，我们可以这样做： 123456class HTMLClockElement extends HTMLElement &#123; constructor() &#123; super(); ... &#125;&#125; 像div一样我们还需要指定这个元素对应的标签名，这样我们就能直接在html语言中使用这个元素了，我们把这个动作叫注册自定义元素： 1customElements.define(&#x27;x-clock&#x27;, HTMLClockElement); 1&lt;x-clock&gt;&lt;/x-clock&gt; 关于元素的标签名需要注意的是： 它们必须包含短横线(-)，这样浏览器在解析的时候才能将它们和本地元素区分开来 在使用的时候不能自包含(self-closing:&lt;x-clock/&gt;)，必须使用结束标签 钩子函数在自定义元素的生命周期中有一些钩子(lifecycle hooks)，我们可以在其中做一些适当的响应处理： Name 调用时机(Called when) constructor An instance of the element is created or upgraded. Useful for initializing state, settings up event listeners, or creating shadow dom. See the spec for restrictions on what you can do in the constructor. connectedCallback Called every time the element is inserted into the DOM. Useful for running setup code, such as fetching resources or rendering. Generally, you should try to delay work until this time. disconnectedCallback Called every time the element is removed from the DOM. Useful for running clean up code. attributeChangedCallback(attrName, oldVal, newVal) Called when an observed attribute has been added, removed, updated, or replaced. Also called for initial values when an element is created by the parser, or upgraded. Note: only attributes listed in the observedAttributes property will receive this callback. adoptedCallback() The custom element has been moved into a new document (e.g. someone called document.adoptNode(el)). constructor,connectedCallback,disconnectedCallback都很好理解，我们说下attributeChangedCallback和adoptedCallback： attributeChangedCallback 在使用元素的时候我们经常要指定一些属性，不同的元素需要指定不同的属性，如img元素有src属性，input元素有disabled, value等属性，这些都是浏览器内置的。作为自定义元素的作者，我们需要决定元素需要哪些属性供使用者使用，如： 1&lt;x-clock disabled hour=&quot;4&quot; minute=&quot;30&quot; second=&quot;0&quot;&gt;&lt;/x-clock&gt; 在这些属性中，我们可以指定哪些属性的变化可以被监控到，通过observedAttributes函数指定： 1234// 指定需要观察的属性static get observedAttributes() &#123; return [&#x27;disabled&#x27;];&#125; 这样，当disabled属性被修改或移除(setAttribute,remoteAttribute)时，attributeChangedCallback将被同步调用 adoptedCallback 当元素从当前文档移到另一个文档时被调用，移动的方式是document.adoptNode 自定义元素的”升级”(upgrade)我们可以在自定义元素被注册之前就使用它： 1&lt;x-clock&gt;&lt;/x-clock&gt; 这个时候系统知道这些元素是自定义元素，但是是未定义的(undefined)，我们可以在后面再使用customElements.define来注册它，一旦被注册，这些未定义的元素就自动”升级(upgrade)”。 我们可以使用customElements.whenDefined来得知一个元素什么时候被定义了： 123customElements.whenDefined(&#x27;x-clock&#x27;).then(() =&gt; &#123; console.log(&#x27;x-clock defined&#x27;);&#125;); 我们来测试一下，页面如下： 1234&lt;p&gt;现在是未定义的：&lt;/p&gt;&lt;button id=&quot;reg&quot;&gt;点击注册clock&lt;/button&gt;&lt;x-clock&gt;&lt;/x-clock&gt;&lt;script src=&quot;main.mjs&quot; type=&quot;module&quot;&gt;&lt;/script&gt; 1234567891011121314151617181920212223242526272829// clock.mjsexport class HTMLClockElement extends HTMLElement &#123; constructor() &#123; super(); this.innerHTML = &#x27;i am a clock custom element&#x27; console.log(&#x27;custom element created&#x27;) &#125; // 指定需要观察的属性 static get observedAttributes() &#123; return [&#x27;disabled&#x27;]; &#125; connectedCallback() &#123; console.log(&#x27;insert into dom&#x27;) &#125; disconnectedCallback() &#123; console.log(&#x27;removed from dom&#x27;) &#125; attributeChangedCallback(attrName, oldVal, newVal) &#123; console.log(`$&#123;attrName&#125; changed from $&#123;oldVal&#125; to $&#123;newVal&#125;`) &#125; adoptedCallback() &#123; console.log(&#x27;move to new document&#x27;) &#125;&#125; 12345678910// main.mjsimport &#123; HTMLClockElement &#125; from &#x27;./clock.mjs&#x27;document.getElementById(&#x27;reg&#x27;).addEventListener(&#x27;click&#x27;, (e) =&gt; &#123; customElements.define(&#x27;x-clock&#x27;, HTMLClockElement);&#125;)customElements.whenDefined(&#x27;x-clock&#x27;).then(() =&gt; &#123; console.log(&#x27;x-clock defined&#x27;);&#125;); 刚开始的时候自定义元素没有注册，虽然我们使用了它，但是控制台没有任何打印任何信息，元素内容也没有渲染出来；当我们点击按钮时，元素被注册，内容也渲染出来了： 自定义元素的展示内容自定义元素默认是空的，没有内容也没有样式，这显然没啥卵用，我们第一步先填充点内容，最简单的方式是直接在标签里面指定内容，就像普通的div元素一样： 1&lt;x-clock&gt;i am a clock&lt;/x-clock&gt; 这个时候自定义元素的内容完全取决于使用者，一般我们是不会这样做的，因为使用自定义元素(进而是web component)就是为了封装，所以一般是自己控制里面的内容。 可以在constructor中直接设置innerHTML属性(注意：在constructor中能做的事有一定的限制spec)： 12345constructor() &#123; super(); this.innerHTML = &#x27;i am a clock&#x27; console.log(&#x27;custom element created&#x27;) &#125; 样式自定义标签和其他标签一样，可以为它设置任何样式，如： 12345678x-clock &#123; display: block; width: 100px; height: 40px; margin-top: 10px; color: red; border: 1px solid blue;&#125; 效果： 为了更好地控制元素注册前后的展示效果，我们可以利用:defined伪类，它可以用来选取一定注册了的自定义元素，所以我们可以给未注册的元素单独设置样式： 123x-clock:not(:defined) &#123; opacity: 0;&#125; 总结自定义元素作为web component的重要组成部分，使得我们可以定制新的标签，标签中的内容由自己定义，有一定的封装作用。但是一旦元素被渲染出来，它和其他内置元素完全一样：里面的dom结构完全暴露在外面(通过document.queryBy***直接获取)，它的内部dom样式也会受外部css的影响，这离我们想要的组件封装还有一定的距离。 web component另一个组成部分是shadow dom，它就是来解决上面提到的封装问题的，后面会单独讲","tags":[{"name":"html5","slug":"html5","permalink":"http://tomwang1013.github.io/tags/html5/"},{"name":"web component","slug":"web-component","permalink":"http://tomwang1013.github.io/tags/web-component/"}]},{"title":"随手练练：O(n)时间复杂度解决topk","date":"2018-10-19T01:02:28.000Z","path":"topk/","text":"基本思路利用快排中的partition算法对数组a[n]进行划分成：a[0..p-1], a[p], a[p+1..n-1], 如果p+1&#x3D;k，完成；如果p+1&gt;k, 问题转化为在a[0..p-1]中查找topk；否则，问题转化为在a[p+1..n-1]中查找top(k-p-1)。这样，我们利用减治的思路一步步对数组做原地划分，算法终止时，我们直接取数组的前k个元素即可 实现topK 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 查找数组的top K元素 * @param &#123;Array&#125; arr * @param &#123;Number&#125; k */function topK(arr, k) &#123; topKRange(arr, 0, arr.length - 1, k); return arr.slice(0, k);&#125;/** * 在arr[l..h]中查找top k * @param &#123;Array&#125; arr * @param &#123;Number&#125; l * @param &#123;Number&#125; h * @param &#123;Number&#125; k */function topKRange(arr, l, h, k) &#123; if (l &gt;= h) return; const m = partition(arr, l, h); if (m - l + 1 === k) &#123; return; &#125; if (m - l + 1 &gt; k) &#123; topKRange(arr, l, m - 1, k); &#125; else &#123; topKRange(arr, m + 1, h, k - (m - l + 1)); &#125;&#125;/** * partition arr by the last element * @param &#123;Array&#125; arr * @param &#123;Number&#125; l * @param &#123;Number&#125; h * @returns index of the partition element */function partition(arr, l, h) &#123; let i = l; let j = l; while (j &lt; h) &#123; if (arr[j] &gt; arr[h]) &#123; swapArrEle(arr, i++, j++); &#125; else &#123; j++; &#125; &#125; swapArrEle(arr, i, h); return i;&#125;function swapArrEle(arr, i, j) &#123; if (i === j) return; const tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;&#125;","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://tomwang1013.github.io/tags/algorithm/"}]},{"title":"行内布局的一点新的感悟","date":"2018-10-18T01:41:08.000Z","path":"inline-box-review/","text":"行内布局是css的难点，主要涉及line-height，vertical-align，font-size这几个属性，一个简单的”行内居中对齐”就常常让人抓狂，因为行内不止有文字，还有图片、icon font及inline-block元素，它们混在一起会导致各种像素偏差，如果不深入理解其中原理的话，调起来只有碰运气了。还好，已经有前辈帮我们做了很深入浅出的总结，最近又重温了一遍张鑫旭同学的《CSS世界》的第五章：内联元素与流，有了一些新的感悟，特此记录一下 几个基础概念 content area：内容区域 对文字来说，其选中的背景区域(蓝底白字)可以看成内容区域： 对图片来说，内容区域可以看成是它本身 inline-box：内联盒子 内联盒子是行内的一段文字构成的盒子，如果这段文字被内联元素(如em,span等)包含，就是”内联盒子”，否则就是”匿名内联盒子” line-box：行框 每一行就是就是一个行框，里面有多个内联盒子 containing box：包含盒子 包含盒子里面有多个行框 行内对齐我们几乎每天都在做行内对齐，都在用vertical-align，但是大家有没有想过：既然是对齐，那肯定有参照物和被参照物，即谁和谁对齐。结合书上的讲解及自己的测试，我得出了下面的结论： 谁和谁对齐？ 指的是内联盒子与行框内的默认基线对齐：每个内联盒子都属于某个行框，而每个行框都有一条默认基线，即行框内匿名内联盒子中x字母的下边沿： 如何对齐？ 首先，每个内联盒子都有自己的基线，即每个盒子中字母x的下边沿；行框内所有匿名内联盒子的基线在同一水平线上，我们把这条水平线作为整个行框的默认基线，即上面提到的”默认基线”。 默认情况下，所有内联盒子的vertical-align都是baseline，这时的对齐方式是内联盒子的基线和整个行框的”默认基线”对齐： 图中的实线是默认基线，虚线是每个内联盒子的基线 每个内联盒子可以设置不同的vertical-align，这会导致这个盒子在垂直方向上偏离默认基线： 下面举个例子： 12345678910111213141516171819202122232425262728&lt;div class=&quot;box&quot;&gt; zyx &lt;span class=&quot;span1&quot;&gt;span1 x&lt;/span&gt; &lt;span class=&quot;span2&quot;&gt;x span2&lt;/span&gt; &lt;span class=&quot;span3&quot;&gt;x span2&lt;/span&gt;&lt;/div&gt; &lt;style&gt; .box &#123; width: 600px; background-color: rgb(141, 118, 163); &#125; .span1 &#123; font-size: 20px; background-color: brown &#125; .span2 &#123; font-size: 40px; background-color: blue; &#125; .span3 &#123; font-size: 60px; background-color: yellowgreen; &#125;&lt;/style&gt; 默认情况下内联盒子都是按基线(baseline)对齐的： 可以看到它们确实是按基线对齐的。现在我们来调整一下它们的”对齐线”： 1234567891011.span1 &#123; vertical-align: -10px;&#125;.span2 &#123; vertical-align: 10px;&#125;.span3 &#123; vertical-align: -20px;&#125; 效果如下，都相对默认基线偏移了设置的值，正值往上偏移，负值往下偏移： 上面提到的是vertical-align设置成数值的效果，我们还可以使用关键字top，middle，bottom等。top和bottom比较好理解，它们会导致内连盒子的上边沿或下边沿和整个行框的上边沿或下边沿对齐，这2个值和baseline没啥关系。下面我们说下middle，首先是MDN上的正式定义： middle: ​ Aligns the middle of the element with the baseline plus half the x-height of the parent 可以看到，middle使得内联盒子的垂直中点和整个行框的默认基线以上1&#x2F;2个x字母的高度位置对齐，也就是和行框中匿名盒子中x字母的交叉点对齐： 图中span1的高度是40px，它的中线穿过外面x字母的交叉点 其他vertical-align值 百分比 和数值意思一样，但是需要和line-height的值相乘得到一个具体px数值 text-top Aligns the top of the element with the top of the parent element’s font text-bottom Aligns the bottom of the element with the bottom of the parent element’s font 用得不多，但是从字面意思应该不难理解","tags":[{"name":"css","slug":"css","permalink":"http://tomwang1013.github.io/tags/css/"}]},{"title":"随手练练 - 归并和快速排序","date":"2018-10-17T05:27:37.000Z","path":"merge-quick-sort/","text":"归并排序和快速排序比较归并和快速排序是两种常见的排序算法，基本思路都是分治，平均时间复杂度都是O(nlg(n))，下面是它们的一些特性比较： 归并排序 快速排序 平均时间复杂度 O(nlg(n)) O(nlg(n)) 最坏时间复杂度 O(nlg(n)) O(n^2) 稳定性 稳定 不稳定 空间复杂度 O(n) O(1) 归并排序实现merge-sort.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * marge an array arr * @param &#123;Array&#125; arr */function mergeSort(arr) &#123; mergeSortRange(arr, 0, arr.length - 1);&#125;/** * merge sort arr[l..h] * @param &#123;Array&#125; arr * @param &#123;Number&#125; l * @param &#123;Number&#125; h */function mergeSortRange(arr, l, h) &#123; if (l &gt;= h) return; const m = l + Math.floor((h - l) / 2); mergeSortRange(arr, l, m); mergeSortRange(arr, m + 1, h); merge(arr, l, m, h);&#125;/** * merge arr[p..q] and arr[q + 1..r] * @param &#123;Array&#125; arr * @param &#123;Number&#125; p * @param &#123;Number&#125; q * @param &#123;Number&#125; r */function merge(arr, p, q, r) &#123; const tmpArr = new Array(r - p + 1); let i = p; let j = q + 1; let k = 0; while (i &lt;= q &amp;&amp; j &lt;= r) &#123; if (arr[i] &lt;= arr[j]) &#123; tmpArr[k++] = arr[i++]; &#125; else &#123; tmpArr[k++] = arr[j++]; &#125; &#125; while (i &lt;= q) &#123; tmpArr[k++] = arr[i++]; &#125; while (j &lt;= r) &#123; tmpArr[k++] = arr[j++]; &#125; k = 0; while (k &lt;= r - p) &#123; arr[k + p] = tmpArr[k++]; &#125;&#125; 归并排序一个最大的缺点是它不能原地排序，需要分配一个临时的数组来存储归并结果并将归并结果写入原数组对应位置，这是它不那么流行的原因之一 快速排序实现quick sort 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * quick sort an array arr * @param &#123;Array&#125; arr */function quickSort(arr) &#123; quickSortRange(arr, 0, arr.length - 1);&#125;/** * quick sort arr[l..h] * @param &#123;Array&#125; arr * @param &#123;Number&#125; l * @param &#123;Number&#125; h */function quickSortRange(arr, l, h) &#123; if (l &gt;= h) return; const m = partition(arr, l, h); quickSortRange(arr, l, m - 1); quickSortRange(arr, m + 1, h);&#125;/** * partition arr by the last element * @param &#123;Array&#125; arr * @param &#123;Number&#125; l * @param &#123;Number&#125; h * @returns index of the partition element */function partition(arr, l, h) &#123; let i = l; let j = l; while (j &lt; h) &#123; if (arr[j] &lt; arr[h]) &#123; swapArrEle(arr, i++, j++); &#125; else &#123; j++; &#125; &#125; swapArrEle(arr, i, h); return i;&#125;function swapArrEle(arr, i, j) &#123; if (i === j) return; const tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;&#125; 快速排序的关键是partition函数，它能实现原地分隔，不需要分配临时数组，所以它比merge sort应用广泛一点 分治减治思想这2种排序都用到了分治思想，即把一个大问题拆成小问题，每个小问题都解决了，大问题也就解决了；还有一种思想是减治：把一个大问题化简为一个小问题，这个小问题解决了，大问题也就解决了，二分查找就是典型的减治思想的应用。这两种思想的时间复杂度不同，减治算法通常时间复杂度更小","tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://tomwang1013.github.io/tags/algorithm/"}]},{"title":"PWA之存储简介","date":"2018-10-12T13:20:44.000Z","path":"pwa-storage/","text":"浏览器端有多种存储方式，作为PWA程序该如何选择离线存储方式呢？首先我们看看典型的web程序有哪些数据需要存储。浏览器端的数据分两类： 静态资源：如html，css，js，image等和某个URL关联的请求资源 动态数据：如动态请求后端接口返回的一些状态信息等，通常是ajax请求返回的 总结来看： 对静态资源(URL addressable resources)，我们使用Cache Api 对动态数据，我们使用IndexDB 下面我们依次介绍并比较一下所有浏览器端的存储方式： Cookies sync 不支持web worker及service worker 储存量很有限，且只能存string类型 Session Storage &amp; Local Storage sync 不支持web worker及service worker 储存量很有限，且只能存string类型 Cache API async (Promise-based) 支持Windows, Workers, Service Workers key &#x3D; Request, value &#x3D; Response 储存类型不限 IndexDB async (event based) 支持Windows, Workers, Service Workers 支持索引(indexed)、事务(transactions)、游标(cursors) 储存类型不限 Not SQL，很低层，一般使用封装好的基于promised的库，如idb File System：只有chrome支持，不考虑 WebSQL：Rejected by Edge, Firefox，不考虑 App Cache：废弃 前面没有提到Cache API和IndexDB的储存大小限制，其实他们也有限制，只是上限远高于Cookies和LocalStorage，但是具体的限制却有点复杂，且每个浏览器都不一样，这里有个大概的数据： Browser Limit Chrome &lt;6% of free space Firefox &lt;10% of free space Safari &lt;50MB IE10 &lt;250MB Edge Dependent on volume size 参考： https://developers.google.com/web/fundamentals/instant-and-offline/web-storage/ https://docs.google.com/presentation/d/11CJnf77N45qPFAhASwnfRNeEMJfR-E_x05v1Z6Rh5HA/edit#slide=id.g146417e51d_0_113","tags":[{"name":"pwa","slug":"pwa","permalink":"http://tomwang1013.github.io/tags/pwa/"},{"name":"storage","slug":"storage","permalink":"http://tomwang1013.github.io/tags/storage/"}]},{"title":"offline-cookbook总结","date":"2018-10-12T04:49:24.000Z","path":"offline-cookbook/","text":"offline cookbook是关于service worker缓存及响应策略很好的文章，这里画个图总结一下： offline cookbook","tags":[{"name":"pwa","slug":"pwa","permalink":"http://tomwang1013.github.io/tags/pwa/"}]},{"title":"CSRF和XSS扫盲","date":"2018-09-02T04:49:24.000Z","path":"csrf-xss/","text":"关于CSRF和XSS的文章非常多，相信很多人也看过了，笔者也看了一些，但总是记不住，这个做个非常简单的总结，让大家有个直观的印象 CSRF全称：Cross-Site Request Forgery，以用户的名义发起一个恶意请求，简单过程如下： 用户登录正常网站A 用户同时不小心打开黑客的网站B 网站B自动或由用户触发发起一个恶意的指向A服务器的请求 A服务器处理这个恶意请求，坏事发生 这里有幅网上找的图可以看出这个过程： img 如何避免？ 让服务器只接受POST请求是无法避免的，普通的form提交同样可以发起cross-domain请求 严格限制CORS, 千万不要出现 1Access-Control-Allow-Origin: * 避免的关键是如何区分甄别出恶意请求：目前比较好的一种做法是为每个请求带上一个随机的token，这个token是服务器端和浏览器端通过某种方式约定好的，服务器端通过检查这个token来验证请求的合法性，这个很多后端框架都做了支持。 最新新的cookie规范添加了一个SameSite的属性，能有效遏制CSRF，其核心原理控制从第三方页面发起的请求是否能带上cookie。比如：从b页面访问a页面，将不会带上属于a页面的设置了SameSite的cookie XSS全称：Cross-site Scripting，想方设法在用户浏览的网页上植入恶意脚本，既然是脚本，就可以做任何事：获取隐私(cookie等)、打开其他网站、修改页面内容等等 怎么植入恶意脚本呢？举两个例子： 下面是一段JSP脚本，将来自当前页面url中的一个参数展示在页面上： 12&lt;% String eid = request.getParameter(&quot;eid&quot;); %&gt; Employee ID: &lt;%= eid %&gt; 攻击者可以先准备一个url，在eid参数中存入恶意脚本： 1http://webpage.com/?eid=&lt;script&gt;alert(1)&lt;/script&gt; 然后引诱用户点击这个url，引诱的方式很多，如email，SNS等。用户一点击，脚本执行 又是一段JSP脚本，在数据库中查找一个名称，然后展示出来： 12345678910&lt;% Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery(&quot;select * from emp where id=&quot; + id); if (rs != null) &#123; rs.next(); String name = rs.getString(&quot;name&quot;); &#125;%&gt;Employee Name: &lt;%= name %&gt; 如果这个名称是用户输入的，且正常情况下其他用户可以通过浏览网页看到这个信息，那么攻击者可以输入一段恶意脚本作为名称，这个名称被存入数据库中，所有用户都可能看到，所以很多用户都会受到攻击 由此可以看到，XSS一般是外部输入直接展示在页面上导致的，所以解决的办法就是对外部输入进行严格的验证，必要时对输入内容进行转码，如： 12&lt;!-- html entity encode --&gt;&lt;script&gt;alert(1)&lt;/script&gt; =&gt; &amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;","tags":[{"name":"安全","slug":"安全","permalink":"http://tomwang1013.github.io/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"javascript优化之code splitting","date":"2018-08-22T04:49:24.000Z","path":"code-splitting/","text":"tree shaking指的是去掉没用到的代码，减小js文件体积从而提高加载速度；而code splitting指的是如何将js代码分解成不同的js文件，使得页面在打开时只加载必要的js文件，从而提高页面加载速度。 大概有以下三种分解方式： Vendor splitting将第三方代码(vendor code)和应用程序的代码分开来，使用不用的缓存策略，使得它们互不影响。我们始终都应该这么做 Entry point splitting对于多页面应用，应该按页面打包js，并将各个页面的公共js提取出来作为单独的js文件进行加载 Dynamic splitting使用动态js加载语法，在页面首次打开后，在后面的操作过程中按需加载js，比如根据用户状态或模块切换动态加载相关js，提高页面首屏渲染速度","tags":[{"name":"performance","slug":"performance","permalink":"http://tomwang1013.github.io/tags/performance/"},{"name":"webpack","slug":"webpack","permalink":"http://tomwang1013.github.io/tags/webpack/"}]},{"title":"深入理解浏览器关键渲染路径(critical render path)及其优化","date":"2018-08-22T04:49:24.000Z","path":"crp/","text":"web性能分析通常都是基本理论+反复实践，没有一套统一的标准或方法。以我的经验来看，我们或多或少都知道一些或几点相关理论，但都是很片段很零碎的，不太好总结或关联起来。本文尝试在critical render path(后简称crp)上做一个分析总结。 什么是crp？crp是和浏览器首屏渲染有关的，指的是浏览器在渲染首屏之前需要经过哪些关键步骤。我们知道，首屏渲染速度是性能的一个重要指标，我们应该让用户在打开页面后尽快看到东西出来。要做到这一点，需要深入分析并优化crp，让这些关键步骤所花时间最小。第一步，我们先看看浏览器是如何渲染页面的 页面渲染流程这算是一个基本理论，每个浏览器渲染页面都要经过一个基本相同的过程： 1537495003079 解析html构建DOM 解析css构建CSSOM（和第一步同时进行） 将DOM和CSSOM合起来构建渲染树 根据渲染树，计算每个元素在窗口中的确切位置和大小 执行渲染 我们以一个例子来详细说明这几个步骤，考虑下面一段html： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;title&gt;Critical Path&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt; &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 第一步解析html，生成DOM： 1537495651317 第二步解析css，生成CSSOM： DOM告诉了我们页面的结构，但是没有样式信息，所以下一步就是解析css，也会生成一个树状结构，这是因为css具有继承特性，子元素或默认继承父元素的一些样式，我们假设页面中的css如下(可以inline或从外部文件导入)： 12345body &#123; font-size: 16px &#125;p &#123; font-weight: bold &#125;span &#123; color: red &#125;p span &#123; display: none &#125;img &#123; float: right &#125; 生成的CSSOM树如下： 1537495994924 灰色的font-size表示这是一个继承属性。这里需要注意的是，CSSOM树中只包含了我们显式设置样式的元素，因为浏览器还有自己的默认样式 第三步把DOM和CSSOM结合在一起，生成渲染树(render tree)： 渲染树包含所有可见的元素及其显式设置的**最终样式(computed style)**，所以head和p元素下面的span不会出现在渲染树中： 1537498465699 注：图中的渲染树应该少了一个body的植树span元素 第四步计算所有元素在视窗(viewport)中的位置和大小： 在最终渲染之前需要计算每个元素的位置和大小，即它的box model，所有的尺寸css属性都要转为为像素，这一步也叫回流(reflow) 最后一步就是渲染(pixel to screen)了，我们知道了元素的可见性及最终样式、大小、尺寸，剩下的事就是将它们画在屏幕上 这就是整个渲染过程，优化crp就是要尽量减少这5步所花的时间，让内容尽快呈现在用户面前。 css的render blocking特性从上面我们可以看到，只有html和css都解析完了，我们才能构建渲染树，它们都是渲染阻塞(render blocking)的。html不用说了，没有它我们的页面从何而来，我们来说下css。如果没有样式，使用系统默认的样式，页面是很难看且基本不可用的。如果浏览器解析完DOM就直接渲染，等后面css再解析完了再渲染，就会出现页面的闪动问题：”Flash of Unstyled Content” (FOUC)，所以我们必须尽快构建CSSOM。因为CSSOM与DOM的构建是并行的，所以一般将css放在head里面，让它尽快开始构建，这样能将渲染树的构建尽量提前。 javascript登场页面当然少不了js，关于js的故事也最多。当页面引入js后，问题变复杂了，因为js太强大了：既能修改DOM有能修改CSSOM，还有人人闻之变色敬而远之的document.write，所以大家都听到一个故事了：浏览器在parse html过程中只要一遇到js，就要停止parse，直接此js加载并运行完成，这就是html block on js。其实这个故事只讲了一半，另一半是js block on css：如果当前有css还没有下载或解析完，js必须等待它们完成后才能执行！ 前面说过，DOM和CSSOM是并行独立解析的，现在因为js的加入，它们之间发生了关联：DOM解析因js而阻塞，而js又因CSSOM而阻塞： 1537505638482 这也解释了为什么**css在上，js在下(Stylesheets at the top, scripts at the bottom)**：js放在body的末尾，这样就不会对DOM和CSSOM的构建进行干扰，让它们并行尽快完成；放在下面还有一个好处就是不通过document.ready事件也能直接引用所有DOM元素。 说说defer和async前面说的html block on js中的js值的是sync js，js可以加上defer或async属性，大家应该都听说过，这里我们详细比较下这2个属性，首先它们有一个共同点：不会阻塞html的解析，不同点如下： defer js的执行在DOM和CSSOM全部构建完之后立即按顺序执行，而async js在加载完后马上执行，但是不保证执行顺序 DOMContentLoaded(DCL)在defer js执行完后再触发，而async js的执行和DCL触发时机无关。使用async js的话，DCL一般在DOM构建完后马上触发 由此可见，如果不考虑js执行顺序，应该优先使用async js 使用chrome devtool中的Audits查看页面crp我们分别使用sync js，defer js，async js来测试下网页的渲染过程，特别是crp，页面如下： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; &lt;title&gt;crp test - async&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;/&gt;&lt;/head&gt;&lt;body onload=&quot;measureCRP()&quot;&gt; &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt; &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt; &lt;!-- 分别使用defer，async测试 --&gt; &lt;script src=&quot;timing.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; sync js(默认行为)： 可以看到js在crp中，且html经过了2次parse，中间被sync js阻塞了： DCL(蓝线)也在js之后触发 defer js js不在crp中，但是DCL依然在js之后触发： async js js不在crp中，和预想的一样，且DCL也在js执行之前触发： DCL在html parse完之后马上触发了 总结想要提高页面加载和渲染速度，让用户尽快看到内容并交互，必须尽量减少crp的总体时间，控制crp中的资源数量 参考： https://developers.google.com/web/fundamentals/performance/critical-rendering-path/ https://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/","tags":[{"name":"performance","slug":"performance","permalink":"http://tomwang1013.github.io/tags/performance/"}]},{"title":"浏览器渲染性能分析总结","date":"2018-08-22T04:49:24.000Z","path":"rendering/","text":"这篇文章的主要素材来源于google开发文档：https://developers.google.com/web/fundamentals/performance/rendering/，算是做一个总结再加上自己的一些理解，做一个备忘录 概述显示器是以一个固定速度刷新屏幕的，一般是每秒60帧，我们可以想象浏览器里面有一个保存当前浏览器内容的渲染缓存，有一个独立的线程每隔大约16.6ms从这个缓存中把浏览器内容刷新到屏幕上，而浏览器的渲染便是刷新这个缓存。 浏览器绘制一帧主要需要经过下面5步： 1537324920067 javascript 在javascript中可以做一些引起视觉变化的动作，如修改样式、操作dom等 style 这一步主要是根据选择器重新计算元素的最终的css样式，看哪些元素的样式发生了变化 layout 这个阶段计算元素几何布局的变化，如位置、大小等。值的注意的是，一个元素layout的变化可能会导致其他元素的连锁变化 paint 这一步就是绘制了：根据元素的位置、大小、样式进行绘制。一般来说，浏览器是分层(layer)绘制的，不同的元素可能被绘制到不同的层上 composite 这一步把绘制好的层根据层级关系(如z-index)组装起来 不是每次重绘(update rendering)都会经过这完整的5步，这又分三种情况： 修改layout相关属性，如width，这种情况下需要经过完整的步骤 修改的属性和layout无关，如边框颜色，这种情况下不需要重新计算layout，只需要重绘 有些属性的修改甚至都不需要重绘，直接组装即可 所以做视觉变化时我们应该优先使用这种属性 下面我们依次分析每一步在性能优化时该注意哪些东西 优化javascript的执行避免js执行时间太长提到js渲染优化，大家都知道一点，就是不要让js执行时间过长以免卡住主线程使得页面不能及时渲染更新，因为上面说的那几步都是在主线程中进行的。这个问题除了优化自身代码外有2种解决办法： web worker 比如你要做一个很费时的排序，可以扔给web worker去做，排好序了再返回： 123456789var dataSortWorker = new Worker(&quot;sort-worker.js&quot;);dataSortWorker.postMesssage(dataToSort);// The main thread is now free to continue working on other things...dataSortWorker.addEventListener(&#x27;message&#x27;, function(evt) &#123; var sortedData = evt.data; // Update data on screen...&#125;); 任务分解 如果你的任务实在是要在主线程中做(如需要操作dom)，那么可以把任务分解成很多小步，把每一小步放到requestAnimationRequest(简称raf，后面会讲到)中进行，这样就不会阻塞页面的响应与渲染，示例如下： 1234567891011121314151617181920var taskList = breakBigTaskIntoMicroTasks(monsterTaskList);requestAnimationFrame(processTaskList);function processTaskList(taskStartTime) &#123; var taskFinishTime; do &#123; // Assume the next task is pushed onto a stack. var nextTask = taskList.pop(); // Process nextTask. processTask(nextTask); // Go again if there’s enough time to do the next task. taskFinishTime = window.performance.now(); &#125; while (taskFinishTime - taskStartTime &lt; 3); if (taskList.length &gt; 0) requestAnimationFrame(processTaskList);&#125; 用requestAnimationRequest来做视觉变化前面提到了raf，这里我们正式介绍一下。简单地说，raf中注册的callback会在每一帧绘制开始的时候被调用。这里的每一帧开始可以理解为我们刚开始提到的屏幕以60帧每秒刷新的每一帧的开始，也是上一帧的结束点。就是说，从这个开始点开始，过大约16.6ms，屏幕会再次刷新。所以，你在raf中做的视觉变化(如样式修改，dom操作等)会在下一帧中得到展示(当然这些变化需要在16.6ms之内被浏览器更新)。 在raf出来之前，我们做视觉修改的时机和屏幕刷新时机是完全独立的，这会导致丢帧的情况，就是我我们的修改不会在下一帧显示出来，而是下下帧才显示出来，比如你用setTimeout在某个时间点做了修改，可能就会出现这种情形： 1537335693692 如果我们能把js中的视觉修改提前到当前帧的开始处，那就能在下一帧得到展示，而唯一能达到这个目的的做法就是使用raf 减少样式计算的作用范围及复杂性这一节没啥好说的，一是使用简单的选择器，尽量使用class： 123456789// bad.box:nth-last-child(-n+1) .title &#123; /* styles */&#125;// good.final-box-title &#123; /* styles */&#125; 二是尽量减少需要重新计算样式的元素数量 避免复杂的布局计算以及布局的反复计算(下面简称布局抖动) 尽量避免修改元素的布局 布局计算是重新计算元素的位置及大小，由于元素之间的排版关系紧密，布局计算的范围通常是整个文档：如果文档中的元素很多，这个过程需要花很长时间，所以第一原则是尽量避免修改元素的布局 避免强制布局同步(forced synchronous layouts) 前面提到，一般而言，我们渲染一帧需要经过以下5步： layout只会计算一次，但是如果我们不注意的话，可能在javascript中就会发生layout计算，这种情况叫强制布局计算，也就是通常所说的回流。 关于布局，我们首先要认识的一件事就是在javascript中可以毫无代价地得到前一帧的布局信息，问题在于，如果你在获取之前改变了元素的样式，这个时候浏览器为了得到元素的最新的布局信息，必须先进行布局计算： 12345678function logBoxHeight() &#123; // 改变元素样式 box.classList.add(&#x27;super-big&#x27;); // Gets the height of the box in pixels // and logs it out - 回流产生 console.log(box.offsetHeight);&#125; 避免布局抖动(layout thrashing) 比回流更可怕的是反复回流，看下以下代码： 123456function resizeAllParagraphsToMatchBlockWidth() &#123; // Puts the browser into a read-write-read-write cycle. for (var i = 0; i &lt; paragraphs.length; i++) &#123; paragraphs[i].style.width = box.offsetWidth + &#x27;px&#x27;; &#125;&#125; 每次循环中需要得到box的宽度，同时设置其他元素的宽度；在下一次循环时，由于有元素的样式发生了变化，所以为了得到box的新的宽度必须重新计算布局，导致每次循环都要进行回流，这对性能是影响很大的 简化绘制复杂性及减小绘制区域绘制一般是整个流程中最费时的一步，且除了transform和opacity属性外(下节会详细讲)，其他css属性的修改都会引起重绘。在重绘不可避免的情况下，可以考虑以下方法来减轻重绘的代价： 将重绘的元素提升到新的层 前面提到过，浏览器是按层绘制的，绘制好所有层之后再把它们叠加合成生成最终的渲染结果。将重绘的元素提升到单独的层，这样就不会影响其他元素，提高渲染效率，这对那种移动的元素尤其有效。提升到独立的层的最有效的办法是使用will-change属性： 123.moving-element &#123; will-change: transform;&#125; 如果浏览器不支持这个属性，可以使用下面的规则： 123.moving-element &#123; transform: translateZ(0);&#125; 当然，太多的层也不好，加了之后需要处理验证 减小绘制区域 减小绘制复杂性 不用的css样式效果绘制效率不一样，比如说阴影绘制就比背景耗时，在效果相差不大时尽量考虑使用简单的css样式 坚持使用只影响合成的css属性(下面简称”合成相关”)及合理使用渲染层上一节提过，有两个属性的修改不会引起重绘，这2个属性就是 transform 和 opacity： 1537350905247 1537351412290 所以在做动画时使用这2个属性是效率最高的：浏览器会把元素临时提升到独立层，不用绘制，直接合成。注意：如果需要将元素永久性地提升到独立层，需要使用上面提到的will-change或transform属性： 1537355072366 考虑在事件处理中使用防节流机制 避免在事件处理中改变样式 事件处理是在raf之前执行的，如果你在事件处理中修改了样式，然后在raf中读取了样式，就可能导致前面提到的回流： 所以始终应该在raf中修改样式 事件节流 想scroll，size这种事件触发频率远远大于屏幕刷新频率的，在这种事件处理中做一些视觉变化操作是很浪费资源的，并可能导致界面卡死，解决办法还是一样：使用raf： 12345678910111213function onScroll (evt) &#123; // Store the scroll value for laterz. lastScrollY = window.scrollY; // Prevent multiple rAF callbacks. if (scheduledAnimationFrame) return; scheduledAnimationFrame = true; requestAnimationFrame(readAndUpdatePage);&#125;window.addEventListener(&#x27;scroll&#x27;, onScroll);","tags":[{"name":"performance","slug":"performance","permalink":"http://tomwang1013.github.io/tags/performance/"}]},{"title":"javascript优化之tree shaking","date":"2018-08-22T04:49:24.000Z","path":"tree-shaking/","text":"简单地说，tree shaking就是不要将用不到的代码打包进来，举个例子，下面的文件定义了2个函数： 12345678// util.jsexport function f1() &#123; // ...&#125;export function f2() &#123; // ...&#125; 主模块只用到了其中一个函数： 1234// main.jsimport * as util from &#x27;util.js&#x27;util.f1() f2虽然没有被用到，但是打包的时候依然会包含进来，导致js文件变大。在webpack中，tree shaking是自动开启的，但是为了让它真正生效，需要你在其他方面稍微配合一下： 只import你需要的代码1234// main.jsimport &#123; f1 &#125; from &#x27;util.js&#x27;util.f1() 阻止babel将es6 module编译成commonJSwebpack的tree shaking只对es6 module其作用，所以我们要阻止babel先做转化： 1234567&#123; &quot;presets&quot;: [ [&quot;env&quot;, &#123; &quot;modules&quot;: false &#125;] ]&#125; 设置sideEffects标记有些模块的作用不是为了导出东西供其他模块使用，而是在被导入的时候做点其他事(如各种polyfills)，我们称这种模块是有副作用（side effects），这种模块是不能移除的，这就是sideEffects的作用，它用来告诉一个包或项目中哪些文件具有副作用，需要在模块或项目的package.json中指定： 所有文件都没有副作用 12345&#123; &quot;name&quot;: &quot;webpack-tree-shaking-example&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;sideEffects&quot;: false&#125; 某些文件具有副作用： 1234567&#123; &quot;name&quot;: &quot;your-project&quot;, &quot;sideEffects&quot;: [ &quot;./src/some-side-effectful-file.js&quot;, &quot;*.css&quot; ]&#125; 做到以上几点，webpack的tree shaking就会生效，所以建议一直这样做，可以说百利而无一害","tags":[{"name":"performance","slug":"performance","permalink":"http://tomwang1013.github.io/tags/performance/"},{"name":"webpack","slug":"webpack","permalink":"http://tomwang1013.github.io/tags/webpack/"}]},{"title":"Blob类型用法总结","date":"2018-08-12T04:49:24.000Z","path":"blob/","text":"Blob一般指的是二进制块Binary Large Object的简称，用来存储大块不透明的任何数据，如图片、视频、字符串等等。Blob作为一种js类型，只有下面很少的属性和方法： 属性 size：blob的字节大小 type：blob的MIME type 方法 slice：截取blob的一段返回一个新的blob，算是blob的一种创建方法 Blob的构建直接构建 Blob构造函数：var aBlob = new Blob( array[, options]); 123let aBlob = new Blob([&#x27;my name&#x27;, new Uint8Array([1, 2, 3])], &#123; type: &#x27;text/plain&#x27; &#125;)aBlob.size // 10aBlob.type // &#x27;text/plain&#x27; 通过BlobBuilder来构建(&#x3D;&#x3D;已废弃，优先选择Blob构造函数&#x3D;&#x3D;) 间接构建 从文件中读取：&lt;input type=&quot;file&quot;&gt; 用户选择文件之后input.files就是一个FileList，里面的元素是File，File是Blob的子类型，具有其他一些额外的属性，如name，lastModifiedDate等： 1234567891011121314&lt;script&gt; // Log information about a list of selected files function fileinfo(files) &#123; for(var i = 0; i &lt; files.length; i++) &#123; // files is an array-like object var f = files[i]; console.log(f.name, // Name only: no path f.size, f.type, // size and type are Blob properties f.lastModifiedDate); // another File property &#125; &#125;&lt;/script&gt;&lt;!-- Allow selection of multiple image files and pass them to fileinfo()--&gt;&lt;input type=&quot;file&quot; accept=&quot;image/*&quot; multiple onchange=&quot;fileinfo(this.files)&quot;/&gt; 从XHR下载 可以通过ajax从服务器请求blob类型数据： 1234567891011// GET the contents of the url as a Blob and pass it to the specified callback.// This code is untested: no browsers supported this API when it was written.function getBlob(url, callback) &#123; var xhr = new XMLHttpRequest(); // Create new XHR object xhr.open(&quot;GET&quot;, url); // Specify URL to fetch xhr.responseType = &quot;blob&quot; // We&#x27;d like a Blob, please xhr.onload = function() &#123; // onload is easier than onreadystatechange callback(xhr.response); // Pass the blob to our callback &#125; // Note .response, not .responseText xhr.send(null); // Send the request now&#125; Blob的使用得到一个blob后，该如何使用它呢？ 直接发送给服务器端1234var xhr = new XMLHttpRequest();xhr.open(&#x27;POST&#x27;, &#x27;/server&#x27;, true);xhr.onload = function(e) &#123; &#125;;xhr.send(blob); 转化为URL来使用blob这个对象不能直接使用，可以转为为一个url，格式为：blob:xxx，使用这个url来引用这个blob。这个格式和data:xxx有点像，但是blob url没有包含任何编码信息，仅仅是作为一个唯一的key来引用这个blob；而data url则是编码后的数据本身。我们使用URL.createObjectURL来做转化，转化后的url可以用在一般的url可以使用的地方，如img.src： 1234567var img = document.createElement(&quot;img&quot;); // Create an &lt;img&gt; elementimg.src = URL.createObjectURL(file); // Use Blob URL with &lt;img&gt;img.onload = function() &#123; // When it loads this.width = 100; // adjust its size and document.body.appendChild(this); // insert into document. URL.revokeBlobURL(this.src); // But don&#x27;t leak memory!&#125; 使用FileReader读取blob的真实内容上面提到的url只是一个blob的引用，并不是真实的内容，我们可以使用FileReader通过下面几个方法读取blob的真实内容： readAsArrayBuffer：将blob读取为ArrayBuffer readAsDataURL：将blob读取为data url(注意：不是blob url) readAsText：将blob读取为字符串 下面是一个读取图片预览的例子，通过readAsDataURL将图片转化为base64编码： 12345678910111213function previewFile() &#123; var preview = document.querySelector(&#x27;img&#x27;); var file = document.querySelector(&#x27;input[type=file]&#x27;).files[0]; var reader = new FileReader(); reader.addEventListener(&quot;load&quot;, function () &#123; preview.src = reader.result; &#125;, false); if (file) &#123; reader.readAsDataURL(file); &#125;&#125;","tags":[{"name":"html5","slug":"html5","permalink":"http://tomwang1013.github.io/tags/html5/"},{"name":"javascript","slug":"javascript","permalink":"http://tomwang1013.github.io/tags/javascript/"}]},{"title":"透视投影解析 - 从建模到像素（WebGL）","date":"2018-07-25T04:49:24.000Z","path":"webgl-perspect/","text":"我们知道，在计算机图形学中物体从建模到展示在屏幕上需要经过大概下面几个坐标变换： steps 我们以一个立方体的绘制来说明这一过程 建模这一步很简单，我们的立方体中心位于坐标系原点，默认情况下，相机也摆放在坐标系原点，和立方体处于同一个坐标系中，且使用的是右手坐标系： default cube 摆放相机立方体建好之后第二个问题就是从哪个方向来观察它，也就是相机的摆放。默认情况下相机位于原点，也就是立方体的中心，且是往Z轴的负方向进行观察，这个时候我们只能看到立方体的后面一面。为了便于观察，我们需要调整相机的位置。我们可以想象相机上面固定住xyz坐标轴，相机移动时，坐标轴也跟着移动。相机摆放完之后，我们要重新计算立方体在新的坐标系下的坐标，观察方向不变，还是沿着新的Z轴负方向： default-cube-2 已知原坐标系原点（O）、新坐标系原点（O’），及新坐标系y轴向量，就可以唯一确定这个变换，我们可以用一个函数调用表示： 12// 新原点：(nOx, nOy, nOz), y轴向量：(upx, upy, upz)lookAt(nOx, nOy, nOz, 0, 0, 0, upx, upy, upz) 我们把lookAt确定的矩阵记为Mv,则立方体在新的相机坐标系下的坐标为： 1np = Mv * p 投影并裁减为了清除地看到投影后的图形，我们考虑一种简单的投影情况：相机沿着原Z轴正方向移动10个单位： 1lookAt(0, 0, 10, 0, 0, 0, 0, 1, 0) 1537254455887 我们以新的原点为聚焦点做透视投影，以上下裁减面夹角、近裁减面宽高比、近远裁减面距离指定透视投影参数： 1537255932260 1setPerspective(60, 1, 1, 100) 大家想想，这个时候我们的立方体在哪里呢？移动相机之后，立方体的前面的z坐标应该变成1 - 10 &#x3D; 9，而后面的z坐标是-1 - 10 &#x3D; -11，下面我们就看看经过这个投影之后，立方体前面在近裁减面上的投影位置及大小，通过简单作图可以看到： 1537257435923 可以看出立方体前面的成像高度为1/9，而近裁减面的高度为tan(30)，即$\\sqrt{3}&#x2F;3$，所以成像高度与近裁减面的高度比为：$\\sqrt{3}&#x2F;9$。 输出到视口到最后一步了，我们假设视口是一个400x400的窗口，在WebGL中，即一个canvas： 123&lt;canvas id=&quot;webgl&quot; width=&quot;400&quot; height=&quot;400&quot;&gt; Please use a browser that supports &quot;canvas&quot;&lt;/canvas&gt; 我们需要把近裁减面映射到这个canvas，按照前面的推算，我们可以得到立方体的前面最终渲染到这个canvas上的高度为$\\sqrt{3}&#x2F;9*400$，大概为77个像素，最终的渲染结果如下： 1537258598407 黑色背景即为整个canvas，通过手动测量，确实是77个像素，说明以上的推算过程是正确的，完整的示例在这里。","tags":[{"name":"webgl","slug":"webgl","permalink":"http://tomwang1013.github.io/tags/webgl/"}]},{"title":"promise精髓","date":"2018-07-12T04:49:24.000Z","path":"promise/","text":"关于promise的教程很多了，个人也看了不少，但心中总是没有一个清晰的脉络，总感觉知识点有点杂乱，希望在这里做个记录，简单清晰全面地总结promise的用法及注意点，不废话不深入，便于查阅 创建及使用promise创建123456789const p = new Promise((resolve, reject) =&gt; &#123; // 此函数立即执行 ··· if (···) &#123; resolve(value); // success &#125; else &#123; reject(reason); // failure &#125;&#125;); promise创建的时候立即执行参数函数 promise的状态promise有三种状态： Pending：代表初始状态，结果未知 Resolved：结果成功返回(resolve被调用) Rejected：计算过程中发生错误(reject被调用或者参数函数执行过程中有异常抛出throw) 如果promise变成Resolved或Rejected，我们称promise已经稳定了(settled)，稳定之后promise的状态不再变化： 1538204868941 消费&#x2F;查询&#x2F;使用promise一般都要关心promise的执行结果： 1234567// onFulfilled处理resolved通知，onRejected处理rejected通知promise.then(onFulfilled, onRejected)promise.then(value =&gt; &#123; /* fulfillment */ &#125;, error =&gt; &#123; /* rejection */ &#125;)promise.then(null, error =&gt; &#123; /* rejection */ &#125;);// 等价于promise.catch(error =&gt; &#123; /* rejection */ &#125;); 我们可以随时查询promise，无论它当时的状态是否是稳定的 promise始终是异步的即使你查询promise的时候promise的状态已经是稳定的，你传递的通知函数也会被异步调用： 123456Promise.resolve(1).then(value =&gt; console.log(value))console.log(2)// 打印结果：21 其他创建promise的方法const p = Promise.resolve(x) x是普通值：p是一个处于Resolved状态且值为x的promise x也是通过resolve创建的promise：p &#x3D; x x是其他方式创建的promise：p的状态取决于x的状态，就是说你查询p和查询x是等价的 const p = Promise.reject(error)返回一个处于Rejected状态且错误为error的promise： 12const myError = new Error(&#x27;Problem!&#x27;);Promise.reject(myError).catch(err =&gt; console.log(err === myError)); // true promise链接(Chaining Promises)promise的一大优点是可以链接，因为Promise.then的返回值还是一个promise： 1const q = p.then(onFulfilled, onRejected) // q is a new promise 所以我们可以继续查询q： 1234p.then(onFulfilled, onRejected).then(value =&gt; &#123;&#125;) // resolved with what is returned by either onFulfilled or onRejected.catch(error =&gt;&#123;&#125;) // rejected if either onFulfilled or onRejected throw an exception 使用普通值来resolve q1234567p.then(function (value1) &#123; return 123; // q is a promise resolved with 123&#125;).then(function (value2) &#123; console.log(value2); // 123&#125;); 使用另一个promise来resolve q1234567p.then(function (value1) &#123; return r; // r is a promise, q = r&#125;).then(function (value2) &#123; console.log(value2);&#125;); resolve promise with normal value or another promise状态示意图： resolve q from onRejected从onRejected中返回的值一样可以用来resolve(不是reject) q： 12345678p.catch(function () &#123; // Something went wrong, use a default value return &#x27;Untitled.txt&#x27;;&#125;).then(function (fileName) &#123; ···&#125;); 通过抛出异常来reject q(这个时候没有reject方法可以调用)1234567p.then(function (value) &#123; throw new Error();&#125;).catch(function (reason) &#123; // Handle error here&#125;); 错误随链接传递直到catch123456asyncFunc1().then(asyncFunc2).then(asyncFunc3).catch(function (reason) &#123; // Something went wrong above&#125;); 错误处理要点不要使用then方法来捕获错误123456// Don’t do this// onRejected能捕获promise抛出的错误，但是不能捕获onFulfilled执行过程中抛出的异常promise.then(onFulfilled, onRejected)// 更好的做法promise.then(onFulfilled).catch(onRejected) 注意区分reject和throw一般来说reject抛出的是可预期的操作错误，如文件不存在、网络断开等；而throw抛出的是代码错误，如参数类型错误等 Promise中抛出的异常不能被try-catch捕获12345try &#123; Promise.resolve(1).then(a =&gt; &#123; throw &#x27;err&#x27; &#125;) &#125; catch (e) &#123; console.log(222, e) // 无法捕获上面的错误&#125; promise组合Promise.all([promise1, promise2, …])1234567891011Promise.all([ asyncFunc1(), asyncFunc2(),]).then(([result1, result2]) =&gt; &#123; ···&#125;).catch(err =&gt; &#123; // Receives first rejection among the Promises ···&#125;); Promise.race([promise1, promise2, …])12345678Promise.race([ httpGet(&#x27;http://example.com/file.txt&#x27;), delay(5000).then(function () &#123; throw new Error(&#x27;Timed out&#x27;) &#125;);]).then(function (text) &#123; ··· &#125;).catch(function (reason) &#123; ··· &#125;); 两个额外的promise函数done()前面说过promise中抛出的异常外界捕获不到，所以我们解决这个问题(始终加上catch也不行，catch中也可能抛出异常)，可以在promise上定义一个done方法，然后跟在promise链最后面： 1234567function doSomething() &#123; asyncFunc() .then(f1) .catch(r1) .then(f2) .done();&#125; 可以这样来定义done方法： 1234567Promise.prototype.done = function (onFulfilled, onRejected) &#123; this.then(onFulfilled, onRejected) .catch(function (reason) &#123; // Throw an exception globally setTimeout(() =&gt; &#123; throw reason &#125;, 0); &#125;);&#125;; finally()仿造try-catch-finally我们可以在promise上定义一个finally方法，使得无论最后promise状态如何，始终执行一个callback： 1234567891011Promise.prototype.finally = function (callback) &#123; const P = this.constructor; // We don’t invoke the callback in here, // because we want then() to handle its exceptions return this.then( // Callback fulfills =&gt; continue with receiver’s fulfillment or rejection // Callback rejects =&gt; pass on that rejection (then() has no 2nd parameter!) value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) );&#125;; async &amp; awaitasync &amp; await本质上是promise的语法糖，掌握了promise基本知道它们的用法了，这个需要注意的是async函数始终返回一个promise： 1234567891011121314151617181920212223242526272829303132333435363738async function asyncFunc() &#123; return 123;&#125;// 等价于：function asyncFunc() &#123; return Promise.resolve(123);&#125;asyncFunc().then(x =&gt; console.log(x)); // 123//////////////////////////////////////////////////////////////////async function asyncFunc() &#123; throw new Error(&#x27;Problem!&#x27;);&#125;// 等价于：function asyncFunc() &#123; return Promise.reject(new Error(&#x27;Problem!&#x27;));&#125;asyncFunc().catch(err =&gt; console.log(err)); // Error: Problem!/////////////////////////////////////////////////////////////////// async可可以直接返回另一个promiseasync function asyncFunc() &#123; return Promise.resolve(123);&#125;asyncFunc().then(x =&gt; console.log(x)) // 123async function asyncFunc() &#123; return Promise.reject(new Error(&#x27;Problem!&#x27;));&#125;asyncFunc().catch(err =&gt; console.error(err)); // Error: Problem! 12345678910111213async function asyncFunc() &#123; const result = await otherAsyncFunc(); console.log(result);&#125;// 等价于:function asyncFunc() &#123; return otherAsyncFunc() .then(result =&gt; &#123; console.log(result); &#125;);&#125; 12345678910111213141516171819async function asyncFunc() &#123; const result1 = await otherAsyncFunc1(); console.log(result1); const result2 = await otherAsyncFunc2(); console.log(result2);&#125;// 等价于:function asyncFunc() &#123; return otherAsyncFunc1() .then(result1 =&gt; &#123; console.log(result1); return otherAsyncFunc2(); &#125;) .then(result2 =&gt; &#123; console.log(result2); &#125;);&#125; 12345678910111213141516171819async function asyncFunc() &#123; const [result1, result2] = await Promise.all([ otherAsyncFunc1(), otherAsyncFunc2(), ]); console.log(result1, result2);&#125;// 等价于:function asyncFunc() &#123; return Promise.all([ otherAsyncFunc1(), otherAsyncFunc2(), ]) .then([result1, result2] =&gt; &#123; console.log(result1, result2); &#125;);&#125; 1234567891011121314151617async function asyncFunc() &#123; try &#123; // 当otherAsyncFunc reject时await语句会抛出异常 await otherAsyncFunc(); &#125; catch (err) &#123; console.error(err); &#125;&#125;// 等价于:function asyncFunc() &#123; return otherAsyncFunc() .catch(err =&gt; &#123; console.error(err); &#125;);&#125; 注意：一个async函数asyncFunc有下面4种调用方法： asyncFunc() await asyncFunc() return asyncFunc() return await asyncFunc() 它们的意义各不相同，参考下面的博文 参考： http://exploringjs.com/es6/ch_promises.html http://exploringjs.com/es2016-es2017/ch_async-functions.html https://jakearchibald.com/2017/await-vs-return-vs-return-await/","tags":[{"name":"es6","slug":"es6","permalink":"http://tomwang1013.github.io/tags/es6/"},{"name":"promise","slug":"promise","permalink":"http://tomwang1013.github.io/tags/promise/"}]},{"title":"Promise.race一种变形：any resolve => resolve, all reject => reject实现","date":"2018-05-12T04:49:24.000Z","path":"promise-race-transform/","text":"我们知道，pr = Promise.race[promises]的意思是promises中任何一个resolve会导致pr变成resolve，任何一个reject会导致pr变成reject，但是有时候我们需要这样的逻辑：resolve和race一样，但是必须是promises中所有的都是reject，pr才变成reject，该怎么办？偶然在网上看到一个实现，很精妙，估记录一下： 12345678910111213141516// Promise.race is no good to us because it rejects if// a promise rejects before fulfilling. Let&#x27;s make a proper// race function:function promiseAny(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; // make sure promises are all promises promises = promises.map(p =&gt; Promise.resolve(p)); // resolve this promise as soon as one resolves promises.forEach(p =&gt; p.then(resolve)); // reject if all promises reject promises.reduce((a, b) =&gt; a.catch(() =&gt; b)) .catch(() =&gt; reject(Error(&quot;All failed&quot;))); &#125;);&#125;; 这里的关键是reduce语句，假设我们传进来的promises是[a, b, c, d]，这条语句等价于： 12a.catch(() =&gt; b).catch(() =&gt; c).catch(() =&gt; d) .catch(() =&gt; reject(Error(&quot;All failed&quot;))); 如果最后一个catch被执行，说明前面所有的catch都被执行了，而前面的catch函数都是返回下一个promise，这说明每个promise都是reject状态","tags":[{"name":"es6","slug":"es6","permalink":"http://tomwang1013.github.io/tags/es6/"},{"name":"promise","slug":"promise","permalink":"http://tomwang1013.github.io/tags/promise/"}]}]