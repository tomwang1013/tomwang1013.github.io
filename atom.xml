<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tomwang1013的学习总结</title>
  <icon>https://www.gravatar.com/avatar/7bfb8a916a0cb49b1f039951a00a6094</icon>
  <subtitle>今歌爸爸的学习记录及生活点滴</subtitle>
  <link href="http://tomwang1013.github.io/atom.xml" rel="self"/>
  
  <link href="http://tomwang1013.github.io/"/>
  <updated>2023-07-27T00:18:42.813Z</updated>
  <id>http://tomwang1013.github.io/</id>
  
  <author>
    <name>wang xiantong</name>
    <email>174604588@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>distance-from-camera-computation-in-webgl</title>
    <link href="http://tomwang1013.github.io/distance-from-camera-computation-in-webgl/"/>
    <id>http://tomwang1013.github.io/distance-from-camera-computation-in-webgl/</id>
    <published>2023-07-26T23:15:53.000Z</published>
    <updated>2023-07-27T00:18:42.813Z</updated>
    
    <content type="html"><![CDATA[<p>When implementing fog in webgl, the key point is how to calculate the distance from the object to the eye&#x2F;camera. It depends on whether you want precise or approximate value for it.</p><ol><li><p>Precise value</p><p>It is just the distance between 2 points(one is camera) in 3D space. We have several ways to express it:</p><ul><li><p>Both the camera and object are in <code>world coordinate system</code></p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vertex shader</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec4</span> a_position;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> u_modelMatrix; <span class="comment">// model matrix for object</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec4</span> u_cameraWorldPos; <span class="comment">// camera pos in WC</span></span><br><span class="line">vary <span class="type">float</span> v_dist;</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">   <span class="built_in">gl_Position</span> = u_mvpMatrix * a_position;</span><br><span class="line">   v_dist = <span class="built_in">distance</span>(u_modelMatrix * a_position, u_cameraWorldPos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>The object is in <code>view coordinate system</code> whose origin is the camera</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vertex shader</span></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec4</span> a_position;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> u_modelMatrix; <span class="comment">// model matrix for object</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">mat4</span> u_viewMatrix;  <span class="comment">// view matrix for object</span></span><br><span class="line">vary <span class="type">float</span> v_dist;</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">   <span class="built_in">gl_Position</span> = u_mvpMatrix * a_position;</span><br><span class="line"></span><br><span class="line">   <span class="type">vec4</span> viewPos = u_viewMatrix.u_modelMatrix * a_position;</span><br><span class="line">   v_dist = <span class="built_in">length</span>(viewPos.xyz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Approximate value</p><p>We commonly use <code>z</code> value as the approximate value for the distance. We also have several ways to express it.</p><ul><li><p>In <code>VC(view coordinate system)</code></p> <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gl_Position</span> = u_mvpMatrix * a_position;</span><br><span class="line"><span class="comment">// z is negative in VC, the camera is looking in -z direction</span></span><br><span class="line"><span class="type">vec4</span> viewPos = u_viewMatrix.u_modelMatrix * a_position;</span><br><span class="line">v_dist = -viewPos.z;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OR if you review the perspective project matrix, </span></span><br><span class="line"><span class="comment">// you will find that the ultimate w value is just -z, so:</span></span><br><span class="line">v_dist = <span class="built_in">gl_Position</span>.w;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>In <code>window coordinate system</code>, <code>z</code> value is between 0 and 1 and we can just use it.</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fragment shader</span></span><br><span class="line">dist = <span class="built_in">gl_FragCoord</span>.z;</span><br></pre></td></tr></table></figure><p>This is the cheapest one!</p></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;When implementing fog in webgl, the key point is how to calculate the distance from the object to the eye&amp;#x2F;camera. It depends on whet</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="webgl" scheme="http://tomwang1013.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>webgl-camera-visualization</title>
    <link href="http://tomwang1013.github.io/webgl-camara-visualize/"/>
    <id>http://tomwang1013.github.io/webgl-camara-visualize/</id>
    <published>2023-07-24T03:30:43.000Z</published>
    <updated>2023-07-24T09:39:05.834Z</updated>
    
    <content type="html"><![CDATA[<p>3D viewing is a difficult problem to master for beginners of webgl like me. <strong>Model matrix</strong>, <strong>view matrix</strong>, <strong>projection matrix</strong>, <strong>camara position</strong>, <strong>local coordinates</strong>, <strong>world coordinates</strong>, <strong>view coordinates</strong>, <strong>windows coordinates</strong>, <strong>left-hand coordinates</strong>, <strong>right-hand coordinates</strong>, etc. So many buzz words exist just to paint a point on screen! The key point is how the scene looks like from the point view of camera. So if we can visualize it(camera looking at the scene) correctly, we can get some deep insight into the mysterious 3D viewing. Let’s do it <em>theoretically</em>.</p><p>At first, i want to show you a graph which contains the essence of 3D viewing.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/coordinates-transform.png" alt="coordinates transform" title="">                </div>                <div class="image-caption">coordinates transform</div>            </figure><p>That is the normal process of setting up 3D models and viewing it. We use <code>Mm</code>, <code>Mv</code>, <code>Mp</code> to represent <code>model matrix</code>, <code>view matrix</code>, <code>project matrix</code> respectively, then <code>gl_Position</code> can be computed as:</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gl_Position</span> = Mp * Mv * Mm * [original(local) position]</span><br></pre></td></tr></table></figure><p>The result of <code>Mp * Mv * Mm</code> is usually named as <code>MVP</code> matrix: <code>Mmvp</code>.</p><p>A clipping normalized cube with a range of <code>(-1, 1)</code> for each axis is used to cut out all the points whose <code>gl_Position</code> is outside of the cube. It is <strong>our</strong> job to compute <code>gl_Position</code> with all the matrices(or with no matrix as long as that gl_Position is inside the cube if you want to show your model). WebGL is responsible for the last step: get the final position in <code>window coordinate</code>, i.e. compute the <code>gl_FragCoord</code>. We normally just set the viewport and don’t care about it:</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.viewport(x, y, w, h);</span><br></pre></td></tr></table></figure><p>You can refer to the <a href="https://registry.khronos.org/OpenGL/specs/es/2.0/es_full_spec_2.0.pdf">spec</a> to figure out how it is computed.</p><p>Ok, preparatory work is done. Let’s shift to business. To visualize a camera looking at some objects, we need a second camera:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">camera2 looking at camera1 which is looking at some object</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/camera-view2.png" alt="2 cameras" title="">                </div>                <div class="image-caption">2 cameras</div>            </figure><p>Two major steps are taken to do it:</p><p><strong>Firstly</strong>, draw the left part: the object being looked at from <code>camera1</code>, use matrices as follows:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mmvp = Mp1 * Mv1 * Mm1</span><br></pre></td></tr></table></figure><p>This step is easy to understand.</p><p><strong>Secondly</strong>, draw the right part: the object &amp; camera1 being looked at from <code>camera2</code>:</p><ol><li><p>Draw the object:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mmvp = Mp2 * Mv2 * Mm2</span><br></pre></td></tr></table></figure><p>No much to say.</p></li><li><p>Draw camera1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mmvp = Mp2 * Mv2 * (inverse of Mv1)</span><br></pre></td></tr></table></figure><p>Why the <code>model matrix</code> of camera1 from the view of camera2 is <code>inverse of Mv1</code>? Well, when setting up the camera, we can move the camera or move the scene. Both are inverse process of each other:</p><p><img src="/../images/view-matrix.png" alt="view matrix"></p></li><li><p>Draw the frustum which is transformed to a normalized cube:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mmvp = Mp2 * Mv2 * (inverse of Mv1) * (inverse of Mp1)</span><br></pre></td></tr></table></figure><p>It is the most difficult part to understand. We want to know the cube’s position in <code>world coordinate</code> which the model matrix represents. We should firstly ask where does the normalized cube come from? Yes, it comes from a <code>MVP</code> transformation performed by <strong>camera1</strong>:</p><p><img src="/../images/frustum-cube.png" alt="frustum-cube"></p><p>So we deduce reversely and get model matrix: <code>(inverse of Mv1) * (inverse of Mp1)</code>.</p></li></ol><p>Game over theoretically! If you want a real and practical example, please refer to this <a href="https://webglfundamentals.org/webgl/lessons/webgl-visualizing-the-camera.html">great article</a>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;3D viewing is a difficult problem to master for beginners of webgl like me. &lt;strong&gt;Model matrix&lt;/strong&gt;, &lt;strong&gt;view matrix&lt;/strong&gt;, </summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
  </entry>
  
  <entry>
    <title>webgl-cullface</title>
    <link href="http://tomwang1013.github.io/webgl-cullface/"/>
    <id>http://tomwang1013.github.io/webgl-cullface/</id>
    <published>2023-07-20T03:04:07.000Z</published>
    <updated>2023-07-20T04:08:55.699Z</updated>
    
    <content type="html"><![CDATA[<p>Say we has a triangle as follows:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   v0</span><br><span class="line">  /  \</span><br><span class="line"> /    \</span><br><span class="line">v1————v2</span><br></pre></td></tr></table></figure><p>And we pass it to webgl in the order of <code>(v0, v1, v2)</code>, i.e. <code>counter-clockwise(CCW)</code>.</p><p>Whether this triangle is drawn(rasterized) depends on 3 factors:</p><ol><li><p>Whether the triangle is <code>front facing</code> or <code>back facing</code></p><p> To determine it, firstly we use the following formula to compute its area:</p><p> <img src="/../images/area-compute.png" alt="compute area"></p><p> <code>i⊕1</code> is <code>(i+1) mod n</code>. The interpretation of the sign of this value is controlled with:</p> <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> FrontFace( enum dir );</span><br></pre></td></tr></table></figure><p> Setting dir to CCW (corresponding to counter-clockwise orientation of the projected polygon in window coordinates) indicates that the sign of a should be reversed prior to use. Setting dir to CW (corresponding to clockwise orientation)uses the sign of a is as computed above. Front face determination requires one bit of state, and is <em>initially set to CCW</em>.</p><p> If the sign of the area computed by equation 3.4 (including the possible reversal of this sign as indicated by the last call to <code>FrontFace</code>) is <code>positive</code>, the polygon is <code>front facing</code>; otherwise, it is back facing</p></li><li><p>Whether face culling is turned on or off</p><p> This is controlled by <code>gl.enable/disable(gl.CULL_FACE)</code> which is disabled by default.</p></li><li><p>The mode of face culling</p><p> If face culling is turned on, we can controll which face to cull by calling:</p> <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> CullFace( enum mode );</span><br></pre></td></tr></table></figure><p> mode is a symbolic constant: one of FRONT, BACK or FRONT_AND_BACK, which is BACK by default.</p></li></ol><p>After all the above values are known, Front facing triangles are rasterized if either culling is disabled or the CullFace mode is BACK while back facing polygons are rasterized only if either culling is disabled or the CullFace mode is FRONT.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Say we has a triangle as follows:&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="webgl" scheme="http://tomwang1013.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>webgl-lighting</title>
    <link href="http://tomwang1013.github.io/webgl-lighting/"/>
    <id>http://tomwang1013.github.io/webgl-lighting/</id>
    <published>2023-07-18T07:38:47.000Z</published>
    <updated>2023-07-18T09:51:57.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="light-sources"><a href="#light-sources" class="headerlink" title="light sources"></a>light sources</h1><h2 id="directional-light"><a href="#directional-light" class="headerlink" title="directional light"></a>directional light</h2><p>  Light is coming uniformly from one direction independently of the object position. The object’s color depends on 3 parts:</p><ul><li>light color</li><li>light direction</li><li>surface direction(<code>normal</code>)</li><li>object’s original color</li></ul><p>  <img src="/../images/directional_light.png" alt="theta"></p><p>  let <code>theta</code> be the angle of <code>reverse of light direction</code> and <code>surface direction</code>, then:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflection color = light color x original color x cos(theta)</span><br></pre></td></tr></table></figure><h2 id="point-light"><a href="#point-light" class="headerlink" title="point light"></a>point light</h2><p>  Same as directional light with only one difference: the light direction is on longer fixed. It points from light’s position to object’s position. So we need to calculate each vertex’s light direction(usually do it in <code>fragment shader</code>). </p><p>  <img src="/../images/point-light.png" alt="point light"></p><h2 id="ambient-light"><a href="#ambient-light" class="headerlink" title="ambient light"></a>ambient light</h2><p>  In reality, we can see objects without point light or sunshine. That’s what ambient light do. Calculation of ambient reflection color is very simple:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflection color = light color x original color</span><br></pre></td></tr></table></figure><p>  We see the same color from all directions.</p><h2 id="spot-light"><a href="#spot-light" class="headerlink" title="spot light"></a>spot light</h2><p>  Point light goes in all directions from that point while spot light has a limit range. Within that range we light the same as point light otherwise we don’t light at all. We set a specific direction for the spot light with a angle range symmetrically distributing around it. From this angle limit, we compute a <code>dot</code> limit.</p><p>  <img src="/../images/spot-light.png" alt="spot light"></p>  <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dotFromDirection = <span class="built_in">dot</span>(surfaceToLight, -lightDirection)</span><br><span class="line"><span class="keyword">if</span> (dotFromDirection &gt;= limitInDotSpace) &#123;</span><br><span class="line">  <span class="comment">// do the lighting like point light</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="reflection-types"><a href="#reflection-types" class="headerlink" title="reflection types"></a>reflection types</h1><h2 id="diffuse-reflection"><a href="#diffuse-reflection" class="headerlink" title="diffuse reflection"></a>diffuse reflection</h2><p>  For rough surfaces, the light reflects uniformly in all directions, i.e. we see the same color from all directions. This is <code>diffuse reflection</code> which is used in <code>directional light</code> and <code>point light</code>.</p><h2 id="specular-reflection"><a href="#specular-reflection" class="headerlink" title="specular reflection"></a>specular reflection</h2><p>  As opposed to diffuse reflection, if the surface is shiny like a mirror, it looks brightest from a special direction:</p><p>  <img src="/../images/specular-highlights.png" alt="specular reflection"></p><p>  The computation of specular reflection color is as follows:</p><p>  <img src="/../images/specular-compute.png" alt="specular computation"></p>  <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> specular = <span class="built_in">dot</span>(normal, halfVector);</span><br><span class="line"><span class="built_in">gl_FragColor</span>.rgb += specular * specular_color;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;light-sources&quot;&gt;&lt;a href=&quot;#light-sources&quot; class=&quot;headerlink&quot; title=&quot;light sources&quot;&gt;&lt;/a&gt;light sources&lt;/h1&gt;&lt;h2 id=&quot;directional-light&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="webgl" scheme="http://tomwang1013.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>webgl-coordinate</title>
    <link href="http://tomwang1013.github.io/webgl-coordinate/"/>
    <id>http://tomwang1013.github.io/webgl-coordinate/</id>
    <published>2023-07-18T05:48:42.000Z</published>
    <updated>2023-07-18T05:51:37.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebGL-coordinates-tips"><a href="#WebGL-coordinates-tips" class="headerlink" title="WebGL coordinates tips"></a>WebGL coordinates tips</h1><ol><li><p>Fragment shader only accepts a normalized and <strong>left-handed</strong> cube. Each axis begins from <code>-1</code> to <code>1</code> and any contents out of it will be cut out. As to lefted-handed, it means positive z axis points into the screen and points with bigger z will be in the back of points with smaller z.<br> <img src="/../images/norm_cube.png" alt="cube"></p><p> So it is the vertex shader’s responsibility to output <em>positions</em> within this normalized cube with any way.</p></li><li><p>We(vertex shader) usually take 4 steps to output this normalized cube:</p><ol><li><p>modeling in <strong>local coordinate system</strong></p></li><li><p>transformation with <em>model matrix</em>(<code>translate(),rotate(),scale()</code>) to get positions in <strong>world coordinates</strong></p></li><li><p>set up the camara with <em>view matrix</em>(<code>lookAt()</code>) to get positions in <strong>view coordinate</strong></p></li><li><p>projection(orthogonal or perspective) with <em>projection matrix</em>(<code>setOrtho(), setPerspective()</code>) to get positions in <strong>clipping coordinate</strong>(i.e. <em><strong>the normalized cube</strong></em>)</p><p> For step 1 ~ step 3, we use <em>right-handed coordinate</em> in general. In step 4, positions are transformed from right-handed to left-handed clipping coordinate. From now on, WebGL takes in charge. It maps positions in the normalized cube(positions out of it will be cut out) to the cavans, using z-value(usually be re-mapped from (-1, 1) to (0, 1), i.e. 0 represents the device’s screen) for depth test:</p><p> <img src="/../images/final_step.png" alt="final display"></p></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WebGL-coordinates-tips&quot;&gt;&lt;a href=&quot;#WebGL-coordinates-tips&quot; class=&quot;headerlink&quot; title=&quot;WebGL coordinates tips&quot;&gt;&lt;/a&gt;WebGL coordinates ti</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="webgl" scheme="http://tomwang1013.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>webpack-hot-loader-react</title>
    <link href="http://tomwang1013.github.io/webpack-hot-loader-react/"/>
    <id>http://tomwang1013.github.io/webpack-hot-loader-react/</id>
    <published>2020-12-16T12:27:10.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本方式"><a href="#基本方式" class="headerlink" title="基本方式"></a>基本方式</h2><p>对webpack的hot loader机制，基本用法很简单，只需要把hot开启：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">  <span class="attr">hotOnly</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// hot: true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后以用<code>module.hot.accept</code>在根组件做重新渲染就行了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.tsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;hello&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      Hello, webpack!</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.tsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDom</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">render</span> = (<span class="params">Component: () =&gt; JSX.Element</span>) =&gt; &#123;</span><br><span class="line">  <span class="title class_">ReactDom</span>.<span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> /&gt;</span></span>,</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="title class_">App</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable language_">module</span>.<span class="property">hot</span>) &#123;</span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">hot</span>.<span class="title function_">accept</span>([<span class="string">&#x27;./App&#x27;</span>], <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">App</span> = <span class="built_in">require</span>(<span class="string">&#x27;./App&#x27;</span>).<span class="property">default</span>;</span><br><span class="line">    <span class="title function_">render</span>(<span class="title class_">App</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用react-hot-loader保持组件状态"><a href="#利用react-hot-loader保持组件状态" class="headerlink" title="利用react-hot-loader保持组件状态"></a>利用react-hot-loader保持组件状态</h2><p>上面的方式有个问题：组件hot load重新渲染之后状态丢失了，这个时候可以使用<code>react-hot-loader</code><br>这个包，用法如下，需要改动几个地方：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. babel.config.js</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;react-hot-loader/babel&quot;</span></span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. App.tsx</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; hot &#125; <span class="keyword">from</span> <span class="string">&#x27;react-hot-loader/root&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;hello&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      Hello, webpack!</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">hot</span>(<span class="title class_">App</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;react-hot-loader&quot;</span>: <span class="string">&quot;^4.13.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@hot-loader/react-dom&quot;</span>: <span class="string">&quot;^17.0.1&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. webpack.config.js</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;react-dom&#x27;</span>: <span class="string">&#x27;@hot-loader/react-dom&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基本方式&quot;&gt;&lt;a href=&quot;#基本方式&quot; class=&quot;headerlink&quot; title=&quot;基本方式&quot;&gt;&lt;/a&gt;基本方式&lt;/h2&gt;&lt;p&gt;对webpack的hot loader机制，基本用法很简单，只需要把hot开启：&lt;/p&gt;
&lt;figure class=&quot;hi</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
  </entry>
  
  <entry>
    <title>两个新API-requestIdleCallback和requestPostAnimationFrame的介绍</title>
    <link href="http://tomwang1013.github.io/requestIdleCallback-requestPostAnimationFrame/"/>
    <id>http://tomwang1013.github.io/requestIdleCallback-requestPostAnimationFrame/</id>
    <published>2020-04-29T06:22:50.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<p>新的html5中有一个以<em>request</em>开头的方法：*requestAnimationFrame(raf)*，这个大家都基本用过，至少听过：用于在渲染(rendering, i.e. style recalculation, layout change等)之前做一些事，一般是更新CSS或DOM。</p><p>最近又出来两个方法(可能还在提案中)，也是以<em>request</em>开头，一个是<strong>rquestIdelCallback</strong>(后面简称<em>ric</em>), 一个是<strong>requestPostAnimationFrame</strong>(后面简称<em>rpaf</em>)。这里我们就要简单地介绍一下它们：它们的调用时机及主要功能。</p><p>在<a href="https://tomwang1013.github.io/event-and-drawing/">前一篇</a>关于事件循环(event loop)的文章中，其实很我们已经说到了raf和ric的执行时机：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/event-loop2.png" alt="event loop2" title="">                </div>                <div class="image-caption">event loop2</div>            </figure><p>可以看到，ric是在浏览器空闲的时候，即task queue为空的时候执行的，这相当于是安排了一个低优先级的任务。一般来说，不建议在ric中修改css和dom，因为这时候浏览器可能已经做完了rendering，如果在ric中修改css和dom的话，那下一个task处理中对layout的读取(如clientWidth等)将触发强制layout同步(<a href="https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing#avoid-forced-synchronous-layouts">Forced Synchronous Layout</a>)，带来很大的性能问题。前面说过，这些事情应该放在raf中进行。</p><p>从名字可以猜到，正如raf是在rendering之前执行，rpaf是在rendering之后执行(post)，并且是<strong>正好</strong>在rendering之后，中间没有任何打扰！</p><p><strong>为什么需要rpaf？</strong> 有两个原因：</p><ol><li><p>更早为下一次页面渲染做准备</p><p>一般来说我们在raf中来更新dom及css来为下一次渲染做准备，但是如果raf中的代码耗时过长，页面可能无法在下一次显卡更新之前(vsync)及时完成渲染并将渲染结果发送到显卡上，毕竟从上图中可以看到，raf的执行时机是在一次事件循环(也叫<em>frame</em>)的后期。</p><p>rpaf提供了一种可能，使得我们可以在上一帧渲染完之后马上为下一帧做准备，不会有任何任务来打扰，这样更有可能将渲染结果及时呈现出来</p></li><li><p>阻止强制layout更新(forced relayout)</p><p>为了保证性能，我们始终要避免编写导致forced layout的代码(即先改变css然后马上读取dom的size)。但是，先阶段浏览器还没有提供一种机制来使得代码在页面完全干净之后运行。下面是一种可能的方法，但是仍然无法百分百保证：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">addEventListener</span>(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Query layout information here.</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">postMessage</span>(<span class="string">&quot;*&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>因为可能还会有其他事件在message事件之前被处理(如timeout，input等)。由于rpaf能保证立即在rendering之后、在所有其他代码之前执行，所以在rpaf中查询dom的size信息，所以这种查询不会引起forced relayout</p></li></ol><p>参考：</p><p><a href="https://github.com/WICG/requestPostAnimationFrame/blob/master/explainer.md">https://github.com/WICG/requestPostAnimationFrame/blob/master/explainer.md</a><br><a href="https://html.spec.whatwg.org/multipage/webappapis.html#processing-model-8">https://html.spec.whatwg.org/multipage/webappapis.html#processing-model-8</a><br><a href="https://developers.google.com/web/updates/2015/08/using-requestidlecallback">https://developers.google.com/web/updates/2015/08/using-requestidlecallback</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;新的html5中有一个以&lt;em&gt;request&lt;/em&gt;开头的方法：*requestAnimationFrame(raf)*，这个大家都基本用过，至少听过：用于在渲染(rendering, i.e. style recalculation, layout change等)之</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="html5" scheme="http://tomwang1013.github.io/tags/html5/"/>
    
    <category term="event loop" scheme="http://tomwang1013.github.io/tags/event-loop/"/>
    
  </entry>
  
  <entry>
    <title>event-and-drawing</title>
    <link href="http://tomwang1013.github.io/event-and-drawing/"/>
    <id>http://tomwang1013.github.io/event-and-drawing/</id>
    <published>2020-04-18T06:17:44.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解浏览器event-loop"><a href="#深入理解浏览器event-loop" class="headerlink" title="深入理解浏览器event loop"></a>深入理解浏览器event loop</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p>浏览器要做非常多的事情：解析html、渲染、用户交互(如点击)、网络请求等，它使用<strong>event loop</strong>来统一协调这些事务。每个<em>agent</em>(如window, web worker, service worker)都有一个event loop。</p><p>每个event loop都有一个或多个<strong>task queue</strong>, 它是<strong>task</strong>的集合(set of tasks)。每个task queue和一个或多个<strong>task source</strong>相关联，因为task来自于某个task source。</p><blockquote><p>Essentially, task sources are used within standards to separate logically-different types of tasks, which a user agent might wish to distinguish between. Task queues are used by user agents to coalesce task sources within a given event loop.</p></blockquote><blockquote><p>For example, a user agent could have one task queue for mouse and key events (to which the user interaction task source is associated), and another to which all other task sources are associated. Then, using the freedom granted in the initial step of the event loop processing model, it could give keyboard and mouse events preference over other tasks three-quarters of the time, keeping the interface responsive but not starving other task queues. Note that in this setup, the processing model still enforces that the user agent would never process events from any one task source out of order.</p></blockquote><p>简而言之，事件有很多来源，浏览器根据事件的来源将它们放入不同的处理队列，可以给予队列不同的处理优先级，从而尽可能保证好的用户体验。常见的事件来源有：</p><ul><li><p>The DOM manipulation task source</p><p>This task source is used for features that react to DOM manipulations, such as things that happen in a non-blocking fashion when an element is inserted into the document.</p></li><li><p>The user interaction task source</p><p>This task source is used for features that react to user interaction, for example keyboard or mouse input.</p></li><li><p>The networking task source</p><p>This task source is used for features that trigger in response to network activity</p></li><li><p>The history traversal task </p><p>This task source is used to queue calls to history.back() and similar APIs.</p></li></ul><p>每个event loop有一个当前执行任务(<strong>currently running task</strong>)，可能是null。<br>每个event loop还有一个微任务队列(<strong>microtask queue</strong>)，初始为空。</p><p>后面会讲到，microtask和task的区别在于它们执行的时机不同，microtask在当前task执行完之后，并在下一个task执行之前处理。</p><h2 id="任务入队-Queueing-tasks-or-microtasks"><a href="#任务入队-Queueing-tasks-or-microtasks" class="headerlink" title="任务入队(Queueing tasks or microtasks)"></a>任务入队(Queueing tasks or microtasks)</h2><p>浏览器主线程(main thread)只是负责不停地从任务队列中取出任务来执行，我们可以假设是其他线程将任务放入队列的。</p><h2 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h2><p>总体来说，主线程永不停止地从队列中取出任务并执行，如下所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/event-loop.png" alt="event loop" title="">                </div>                <div class="image-caption">event loop</div>            </figure><p>具体来说，每次任务迭代(<strong>event iteration</strong> OR “<strong>frame</strong>“)包含如下步骤:</p><ol><li><p>按一定的规则选出一个包含可执行任务的任务队列，我们称之为<em>taskqueue</em></p></li><li><p>从<em>taskQueue</em>中取出第一个可执行任务(<em>first runnable task</em>)，我们称之为<em>oldestTask</em>，将其移出队列</p></li><li><p>将当前运行任务(<em>currently running task</em>)设为<em>oldestTask</em></p></li><li><p>将当前时间设置为<em>taskStartTime</em></p></li><li><p>运行<em>oldestTask</em></p></li><li><p>将当前运行任务置为null</p></li><li><p>处理微任务(<em>microTasks</em>)，反复执行如下步骤，直到微任务队列(<em>microTask queue</em>)为空：</p><ul><li>从微任务队列中取出一个任务，设为<em>oldestMicroTask</em></li><li>将当前运行任务置为<em>oldestMicroTask</em></li><li>运行<em>oldestMicroTask</em></li><li>将当前运行任务置为null</li></ul></li><li><p>将<em>hasARenderingOpportunity</em>置为false</p></li><li><p>将当前时间设为<em>now</em></p></li><li><p>统计并报过任务执行时间：<em>taskStartTime</em>，<em>now</em></p></li><li><p><strong>更新渲染</strong>：如果当前是一个<em>window event loop</em>(worker event loop没有这一步)</p><p>这是很重要的一步，浏览器渲染页面就发生在这一步，即在当前task即所有mircoTask都处理完之后进行渲染更新。但是，更新不是一定会发生，浏览器先要做两个判断：</p><ol><li>当前有没有渲染机会(<em>rendering opportunity</em>)</li><li>当前有没有必要进行渲染</li></ol><p>如果浏览器判断当前没有渲染机会或者没有必要进行渲染，则不会执行任何渲染动作，页面也不会有任何更新，跳过这一步，直接进入下一步</p><p>关于渲染机会及渲染的必要性，可以参考规范中的两段话：</p><blockquote><p>This specification does not mandate any particular model for selecting rendering opportunities. But for example, if the browser is attempting to achieve a 60Hz refresh rate, then rendering opportunities occur at a maximum of every 60th of a second (about 16.7ms). If the browser finds that a browsing context is not able to sustain this rate, it might drop to a more sustainable 30 rendering opportunities per second for that browsing context, rather than occasionally dropping frames. Similarly, if a browsing context is not visible, the user agent might decide to drop that page to a much slower 4 rendering opportunities per second, or even less.</p></blockquote><blockquote><p>The step labeled Rendering opportunities prevents the user agent from updating the rendering when it is unable to present new content to the user (there’s no rendering opportunity). The step labeled Unnecessary rendering prevents the user agent from updating the rendering when there’s no new content to draw.This step enables the user agent to prevent the steps below from running for other reasons, for example, to ensure certain tasks are executed immediately after each other, with only microtask checkpoints interleaved (and without, e.g., animation frame callbacks interleaved). Concretely, a user agent might wish to coalesce timer callbacks together, with no intermediate rendering updates.</p></blockquote><p>如果浏览器判断当前有渲染机会，则将<em>hasARenderingOpportunity</em>置为true，再进一步，如果当前有必要进行渲染，则执行渲染相关的事情，包含但不限于：</p><ul><li>触发窗口的<em>resize</em>事件(如果有的话)</li><li>触发窗口的<em>scroll</em>事件(如果有的话)</li><li>执行所有<em>requestAnimationFrame</em>的callbacks</li><li>更新页面UI的渲染(我们平时所指的<em>rendering</em>)</li></ul><p>从这里我们可以看到raf(requestAnimationFrame)的执行时机：它总是在真正的渲染发生之前执行。所以，对页面和dom的改变类的操作尽量放在ref中。</p><p>既然event loop的每次任务迭代(task iteration)时渲染不一定会执行，所以ref也不一定会执行。</p></li><li><p>执行<strong>requestIdleCallback</strong>的callbacks，如果下面所有条件都满足：</p><ul><li>当前event loop是一个window event loop</li><li>任务队列为空</li><li>微任务队列为空</li><li>hasARenderingOpportunity为false</li></ul></li></ol><p>这篇文章本质上是对<a href="https://html.spec.whatwg.org/multipage/webappapis.html#processing-model">规范</a>的精简解读，规范中还包括大量的作者无法理解的细节，这里都没列出来，有兴趣的读者可以仔细研读一番，定有大的收获。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深入理解浏览器event-loop&quot;&gt;&lt;a href=&quot;#深入理解浏览器event-loop&quot; class=&quot;headerlink&quot; title=&quot;深入理解浏览器event loop&quot;&gt;&lt;/a&gt;深入理解浏览器event loop&lt;/h1&gt;&lt;h2 id=&quot;基本定义&quot;</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="chrome" scheme="http://tomwang1013.github.io/tags/chrome/"/>
    
    <category term="html" scheme="http://tomwang1013.github.io/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>our-qq-talk</title>
    <link href="http://tomwang1013.github.io/our-qq-talk/"/>
    <id>http://tomwang1013.github.io/our-qq-talk/</id>
    <published>2019-04-02T03:23:58.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<p>早上女儿上学又不肯起来，在她睡着的时候给她穿衣服也不配合，我一怒，用力在她大腿上打了两下，照例哇哇大哭之后乖乖配合把衣服穿上了。在父母看来，任何时候孩子的表现只有两种：听话或不听话。听话的时候小嘴巴说个不停，和你一本正经地对话，和你谈条件：他要照你说的做可以，但是必须如何如何，否则就不爱你，只爱妈妈或爸爸；还讲学校里同学的趣事，期间“爸爸”、“妈妈”从不停地从嘴里清脆地蹦出来，做父母的最快乐的时刻也莫过如此。不听话的时候呢把你气得要死，给他下个命令重复八遍都不理你，直到你把电视关了或把他手里的玩具收了才勉强应一下；他做得不对的地方，你见一次说一次，重复几个月还是一样，怎么都改不了。</p><p>育儿经多如牛毛，自己却不太相信，也没这个精力去看。我自己的想法是孩子健康快乐是最根本的，所以尽量多陪孩子，除了某些必要的地方，如吃饭睡觉等，其他事情都尽量由着他，不强迫他做不喜欢的事情。但是该教育还是得教育，所以也免不了斥责甚至动手。电视里面动不动就“从小到大，父母连手指都没碰我一下”我是不信的，至少是挨过父亲的打的。我小时候父母的打都挨过，还不少，长大后觉得真没什么。</p><p>多陪孩子玩，多耐心和他们对话，偶尔不听话打一下哭一下，这就是我和我的女儿的现状。有时候真不想吼她打她，但是真忍不住，我尽量改吧，希望女儿不要记仇</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;早上女儿上学又不肯起来，在她睡着的时候给她穿衣服也不配合，我一怒，用力在她大腿上打了两下，照例哇哇大哭之后乖乖配合把衣服穿上了。在父母看来，任何时候孩子的表现只有两种：听话或不听话。听话的时候小嘴巴说个不停，和你一本正经地对话，和你谈条件：他要照你说的做可以，但是必须如何如</summary>
      
    
    
    
    <category term="writing" scheme="http://tomwang1013.github.io/categories/writing/"/>
    
    
    <category term="diary" scheme="http://tomwang1013.github.io/tags/diary/"/>
    
  </entry>
  
  <entry>
    <title>老二看病小记</title>
    <link href="http://tomwang1013.github.io/sick/"/>
    <id>http://tomwang1013.github.io/sick/</id>
    <published>2019-04-01T05:48:22.000Z</published>
    <updated>2023-07-18T03:20:12.552Z</updated>
    
    <content type="html"><![CDATA[<p>快三周前，我的第二个小孩出生了，欢喜之余，总希望他没病没灾快点长大。前几天突然有点小症状：鼻塞，打喷嚏，打出来黄色的浓稠鼻涕，观察了两三天不见好转，就送医院了，这里要说的就是送医院后的事</p><p>第一次送的医院是他出生的医院，因为很近的缘故不想多走。一个年轻的女医生接待的：</p><p>“我的孩子鼻塞，打喷嚏，有黄鼻涕”</p><p>“几天了？咳嗽吗？”</p><p>“三四天了，基本不咳嗽”</p><p>我说完后她用听诊器在孩子的胸腔上的几个部位随意听了大概十秒钟吧，然后淡然说到：</p><p>“先去照个胸片吧，可能是肺炎”。</p><p>“肺炎？不会吧，孩子能吃能睡，大小便都正常的”，我惊了一跳回应到。</p><p>“这有什么？小孩子肺炎很常见。你如果不照的话签个字吧”，年轻医生简短说到。</p><p>“照这个胸片会不会对小孩子有影响，毕竟太小了，还不足月呢”，我有些顾忌。</p><p>“手机还有辐射呢。你们快点决定做不做”，年轻医生又不耐烦地催促到。</p><p>我心里想的是孩子的身体应该没什么大问题，但是抱着以防万一以求心安的心理，还是决定给小孩照个胸透。一个小时以后，结果拿到了，像是有点问题的结论：支气管炎症状，请结合临床。我们拿给年轻医生看。她虽然只瞄了一眼，但一出口便让我们无比恐慌：</p><p>“确是肺炎，准备住院吧，大概十到十四天的样子。”，她语气很快，且平淡得近乎漠然，丝毫没有医生在给病人传递坏消息时该有的同情甚至歉意</p><p>我一时蒙了，不太敢相信，说到：“结论准确吗？”。</p><p>“你不相信的话可以去其他医院看看，如果要在本院住院的话填下这个单子然后半小时后去住院部办理手续，预交四千元钱；如果不住院的话，在这里签个字就可以走了”。</p><p>这个决定对孩子意义重大，出生不到二十天，十多天的住院输液对孩子是多大的摧打，而这个医生却没有多一句解释，态度就像例行公事一样，还一个劲地催你签字，似乎病人签完字她作为医生的责任就算尽到了。</p><p>我随她的愿，签了字，打算换个大医院再看看。回到家，宝贝白天没什么异常，在妈妈怀里的时候鼻子很通顺，但是一放下就出现阻塞症状，并伴随着喷嚏偶尔加一两声咳嗽，我赶紧挂了省妇幼今天上午的号。省妇幼在市中心，里我们家很远，吃完早饭我们就打车过去了，赶上上班高峰，走了近一个小时才到。</p><p>和我们想的一样，这里的医生说宝贝没什么问题，是新生儿常见的鼻塞现象，经常清洗注意一下就行了，压根没谈到什么肺炎，也没让我们照片子，只开了点咳嗽的药。我们又打车回来了，一来一去看病的钱只是车费的零头。但是重要的是宝贝没事了。心里释然的同时，我们不住地骂那个冷漠且医术平庸的女医生，发誓以后不再到这个医院看儿科了，不，什么科都不看了。</p><p>上午送妻子和孩子到医院后我先回来上班了，由还未出月的妻子一个人带着孩子看的医生，出门时有热心的老阿姨以亲身例子要求妻子赶紧带上帽子，否则到老以后眼睛会迎风出泪，妻子说没事，还没想那么远，其实我们都不太相信。</p><p>快下班了，我迫不及待想回家看到丢丢（宝贝小名）和妻子！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;快三周前，我的第二个小孩出生了，欢喜之余，总希望他没病没灾快点长大。前几天突然有点小症状：鼻塞，打喷嚏，打出来黄色的浓稠鼻涕，观察了两三天不见好转，就送医院了，这里要说的就是送医院后的事&lt;/p&gt;
&lt;p&gt;第一次送的医院是他出生的医院，因为很近的缘故不想多走。一个年轻的女医生接</summary>
      
    
    
    
    <category term="writing" scheme="http://tomwang1013.github.io/categories/writing/"/>
    
    
    <category term="dairy" scheme="http://tomwang1013.github.io/tags/dairy/"/>
    
  </entry>
  
  <entry>
    <title>开始练习写作了</title>
    <link href="http://tomwang1013.github.io/begin-writing/"/>
    <id>http://tomwang1013.github.io/begin-writing/</id>
    <published>2019-03-29T01:45:31.000Z</published>
    <updated>2023-07-18T03:20:12.552Z</updated>
    
    <content type="html"><![CDATA[<p>经过很久的思虑，我决定开始练习写作了，有很多原因促成这一决定，而这些原因又可以归结成一个中心点：暂时没有其他事情可以提起自己永久或长远的兴趣了</p><p>对于大多数像自己这样平凡却不甘于平庸的人来说，总想找个地方发力一下。按理说在自己目前的岗位上发力是最好的选择：努力提高业务及专业能力以在公司博得一个好的发展前景。但是鉴于自己平庸的专业才能及公司的平台限制，总觉得这种努力没太大意义，人们常说选择比努力更重要，我此刻只能以此来安慰自己。但是，接下来怎么办呢？除了应付公司对自己所在岗位的要求以及自己应尽的家庭义务之外，还有些许时间，这些时间用来做点什么呢？我一有时间，脑子里就在想这个问题。作为技术人员，我尝试过创业（当然是在业余时间），做过两个小东西，但是几乎没人使用，看到别人做的东西之后，我觉得自己一个人根本没机会（我又在为自己找借口了，那些鼓吹坚持就是胜利的人该嘲笑我了）。我也想过钻研一种小吃，比如萝卜干啥的，然后把它卖火并以此谋生，但是实施起来很难（不排除以后会尝试的可能性）。想起自己中学曾经的作文被老师作为范文当堂念过，那时候也看过不少世界名著并做过将来当作家的梦，突然觉得自己可以尝试写写东西，不为当什么作家，权当抒发自己聊作兴趣而已。写得好坏不重要，重要的是写的过程。并且要写，当然得读，自己大学以前都是喜欢看文学类书的，只是后来工作了就很少看了。</p><p>万事开头难，这个决心早就下了，但是我今天才提笔记录下来。凡事都需要不断实践努力，写作也一样。今天在开篇的同时，也需要制定一个大概的计划：</p><ol><li>每天写一篇：题材不限，字数500以上</li><li>坚持阅读：阅读方向主要集中在两块：名著及古文，名著目前选了《围城》，《追忆似水年华》，古文目前还没有具体的学习计划</li></ol><p>最后，还是那两个字：坚持！所谓成功，就是做自己力所能及的事，并做到最好</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;经过很久的思虑，我决定开始练习写作了，有很多原因促成这一决定，而这些原因又可以归结成一个中心点：暂时没有其他事情可以提起自己永久或长远的兴趣了&lt;/p&gt;
&lt;p&gt;对于大多数像自己这样平凡却不甘于平庸的人来说，总想找个地方发力一下。按理说在自己目前的岗位上发力是最好的选择：努力提</summary>
      
    
    
    
    <category term="writing" scheme="http://tomwang1013.github.io/categories/writing/"/>
    
    
    <category term="draft" scheme="http://tomwang1013.github.io/tags/draft/"/>
    
  </entry>
  
  <entry>
    <title>几张图看懂元素几何尺寸</title>
    <link href="http://tomwang1013.github.io/geo-summary/"/>
    <id>http://tomwang1013.github.io/geo-summary/</id>
    <published>2019-03-28T02:00:41.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<p>元素和viewport的尺寸一直很迷惑，看到几张图，记录下来做个备份：</p><h2 id="窗口尺寸"><a href="#窗口尺寸" class="headerlink" title="窗口尺寸"></a>窗口尺寸</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1707/vw-layout-4.png" alt="viewport尺寸" title="">                </div>                <div class="image-caption">viewport尺寸</div>            </figure><h2 id="元素尺寸"><a href="#元素尺寸" class="headerlink" title="元素尺寸"></a>元素尺寸</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.stack.imgur.com/5AAyW.png" alt="element size" title="">                </div>                <div class="image-caption">element size</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://i.stack.imgur.com/Cl1IA.png" alt="element size 2" title="">                </div>                <div class="image-caption">element size 2</div>            </figure><p>参考文档：</p><p><a href="https://txd.alibaba-inc.com/post/znwpg9?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io">https://txd.alibaba-inc.com/post/znwpg9?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;元素和viewport的尺寸一直很迷惑，看到几张图，记录下来做个备份：&lt;/p&gt;
&lt;h2 id=&quot;窗口尺寸&quot;&gt;&lt;a href=&quot;#窗口尺寸&quot; class=&quot;headerlink&quot; title=&quot;窗口尺寸&quot;&gt;&lt;/a&gt;窗口尺寸&lt;/h2&gt;&lt;figure class=&quot;image-b</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="css" scheme="http://tomwang1013.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>这段时间的总结</title>
    <link href="http://tomwang1013.github.io/recent-time-summary/"/>
    <id>http://tomwang1013.github.io/recent-time-summary/</id>
    <published>2019-02-27T01:04:22.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<p>​        很久没有更新了，这段时间主要忙于做微信小程序，不是公司的事情，是自己想做。很久以来自己一直有一个产品梦，希望独立完成一款有价值的产品。不过一来自己懒，二来自己是个前端，不会做APP，web又需要兼顾后端，一个人说实话要完成很难（考虑到自己有家庭又在上班）。微信小程序的出现让我看到了希望，尤其是它推出的云开发大大简化了开发过程，使得开发者完全不用自己处理后端服务器了，所以自己立马选取了两个idea，并且马上开干，由于其中一个还牵涉到支付，自己还为此注册了公司，忙得不亦乐乎，两三个月的时间，两个小程序都基本开发完了。</p><p>​        结果如何呢？</p><p>​        不太好！这又要从两个方面说起：一是产品本身不够吸引人；做之前想的是如果有很多人用，肯定会给使用的人带来价值；但是做出来了发现，自己都不怎么想用，它的价值远远低于使用成本，特别是在这个人人都很忙的社会；二是微信小程序目前还有很多限制，无法满足产品功能的要求。举个明显的例子，它是无法主动给用户发送通知消息的：对于用户之间有交互行为的功能，一个用户的行为触动了另一个用户，我却无法及时通知给另一个用户，这是很致命的，因为小程序不像app，有事没事你会打开看看。如果不是必要，你是不会主动打开一个小程序来看的。</p><p>​        这些结果让我很沮丧，目前还没有找到什么好办法，也许会开发另外的小程序，并且等微信那边渐渐开放一些功能吧。总之，做产品不容易</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​        很久没有更新了，这段时间主要忙于做微信小程序，不是公司的事情，是自己想做。很久以来自己一直有一个产品梦，希望独立完成一款有价值的产品。不过一来自己懒，二来自己是个前端，不会做APP，web又需要兼顾后端，一个人说实话要完成很难（考虑到自己有家庭又在上班）。</summary>
      
    
    
    
    <category term="life" scheme="http://tomwang1013.github.io/categories/life/"/>
    
    
    <category term="thinking" scheme="http://tomwang1013.github.io/tags/thinking/"/>
    
  </entry>
  
  <entry>
    <title>web push notification精髓</title>
    <link href="http://tomwang1013.github.io/push-notification-intro/"/>
    <id>http://tomwang1013.github.io/push-notification-intro/</id>
    <published>2018-11-30T02:15:59.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<p>push notification是PWA的重要组成部分，它使得web程序也具有native app类似的”离线”通知功能：即使程序的页面被关掉了，用户依然可以收到服务端发送的通知消息。push notification机制建立在service worker之上，是以下几个部分共同作用的结果：</p><ul><li><p><strong>web server</strong></p><p>后端服务，将消息推送给push service</p></li><li><p><strong>push service</strong></p><p>和browser相关联的专门用来处理通知的服务，用来接受web server推送的消息。每个浏览器都有自己的push service</p></li><li><p><strong>browser</strong></p><p>浏览器，除了常规功能之外(毕竟离开浏览器什么都干不了)，它负责和push service通信，并在有消息时唤醒SW</p></li><li><p><strong>client</strong></p><p>web客户端代码，用来注册(register)SW</p></li><li><p><strong>SW</strong></p><p>service worker，最终由它来接受消息并展示给用户</p></li></ul><p>要完成消息推送并展示，需要经过下面几个步骤：</p><ol><li>client注册SW并向push service发起消息订阅请求，并将订阅信息(<strong>subscription</strong>)保存起来</li><li>web server从client处拿到subscription</li><li>web server向subscription中的目的地(<strong>endpoint</strong>，其中包含了push service的地址)发送消息</li><li>push service收到消息，转发给browser</li><li>browser唤醒SW，将消息发给它</li><li>SW收到消息，展示出来</li></ol><p>整个过程图示如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/push-noti.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>下面进入show me the code阶段，分步讲解每个步骤：</p><h2 id="client订阅消息"><a href="#client订阅消息" class="headerlink" title="client订阅消息"></a>client订阅消息</h2><ul><li><p>获得通知权限</p><p>要展示通知，首先我们需要获取系统通知权限，如果用户不允许通知，后面一切都没有意义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="title class_">Notification</span>.<span class="title function_">requestPermission</span>(<span class="function"><span class="params">status</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Notification permission status:&#x27;</span>, status);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行之后会弹出一个框，让用户选择：</p><p><img src="/../images/1543558967863.png"></p><p>用户的选择结果会保存在<code>Notification.permission</code>中，值为”granted”或”denied”</p></li><li><p>注册SW</p><p>订阅之前先要注册SW，因为所有的操作都是通过SW进行的，注册之后把注册对象保存起来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="function">() =&gt;</span> &#123;      </span><br><span class="line">  navigator.<span class="property">serviceWorker</span>.<span class="title function_">register</span>(<span class="string">&#x27;sw.js&#x27;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">swReg</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Service Worker is registered&#x27;</span>, swReg);</span><br><span class="line">    swRegistration = swReg;</span><br><span class="line">  &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Service Worker Error&#x27;</span>, err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>向push service发起消息订阅请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">swRegistration.<span class="property">pushManager</span>.<span class="title function_">subscribe</span>(&#123;</span><br><span class="line">  <span class="attr">userVisibleOnly</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">subscription</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;User is subscribed:&#x27;</span>, subscription);</span><br><span class="line">  <span class="comment">// 将subscription保存起来发给web server</span></span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Notification</span>.<span class="property">permission</span> === <span class="string">&#x27;denied&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;Permission for notifications was denied&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Failed to subscribe the user: &#x27;</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>订阅成功之后我们得到了订阅信息：subscription，这个信息包含两个关键部分：</p><ol><li>web server往哪里发送信息</li><li>browser收到push service信息后，唤醒那个SW，即里面包含了SW的标识</li></ol><p>在chrome上示例如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span> <span class="attr">&quot;endpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://fcm.googleapis.com/fcm/send/cc_aSQO9_gA:APA91bHLpiir8eZqvsMjRULQY16Pv8WXSlStr8G6Lrkyb-Qytxof_r6zZ0jPgViNMTZZgLZ5I4KVjXGiNex-pKnVKckaLdb9wW7_XwZeXT-LQUXHTppHBq7BP428BN_tiriyRRfuelYj&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;expirationTime&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span> <span class="attr">&quot;keys&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;p256dh&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BLy8MEBjYFnwnLH1yiiY9PkWC4o4-pq13G3nSwq8xsCVV_-RhVoPujEndmCwQTXJD32OSekJoHsn-7_eIsH387U&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;auth&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_jNmRauTLOXHLbV0Np2v0Q&quot;</span> <span class="punctuation">&#125;</span> <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>其中的<code>endpoint</code>就是web server发送消息的目的地</p><p>可以看到chrome的push service服务运行在<code>https://fcm.googleapis.com</code>，每个浏览器都不一样，firefox的是<code>https://updates.push.services.mozilla.com</code>， edge的是<code>https://sg2p.notify.windows.com</code></p></li></ul><h2 id="web-server往push-service推送消息"><a href="#web-server往push-service推送消息" class="headerlink" title="web server往push service推送消息"></a>web server往push service推送消息</h2><p>web server从client中原封不动拿到subscription，通过一个<a href="https://datatracker.ietf.org/doc/draft-thomson-webpush-protocol/">Web Push Protocol</a>给push service推送消息，这个协议非常复杂，所以我们一般使用第三方库去做这件事，在nodejs端我们使用<a href="https://github.com/web-push-libs/web-push">web-push</a>包</p><p>因为chrome端发送消息需要使用google的服务，而我们一般用不了， 所以我们以firefox为例。使用web-push库推送消息很简单，基本上只需要上一步的subscription就行了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node端</span></span><br><span class="line"><span class="keyword">const</span> webPush = <span class="built_in">require</span>(<span class="string">&#x27;web-push&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从client端拿到的subscription</span></span><br><span class="line"><span class="keyword">const</span> pushSubscription = &#123; <span class="string">&quot;endpoint&quot;</span>: <span class="string">&quot;https://updates.push.services.mozilla.com/wpush/v1/gAAAAABcAN9TNEnJkWUet1JCu0BFE4307sZ1e9RQaxs2x5ReXXcDxU-lRwb9t5B3TWKjSEEmgmJVPjqFDmfWSS2LFiTlynI1T4IVLVyVglR0uM6YYsUa07cUdwnkpwfFLQBCCWjsdgnS&quot;</span>, <span class="string">&quot;keys&quot;</span>: &#123; <span class="string">&quot;auth&quot;</span>: <span class="string">&quot;a-2f-JnVWOWyeic1pJNYNA&quot;</span>, <span class="string">&quot;p256dh&quot;</span>: <span class="string">&quot;BBgpcZSWJc_VsjQZphdWhADpoDwziiiI3650nG4FrOKrhgWJdMDtWBHDi_BpurksrJc2r-6P2r5BsJBMFGUhuMY&quot;</span> &#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要发送的信息</span></span><br><span class="line"><span class="keyword">const</span> payload = <span class="string">&#x27;Here is a payload!&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送选项：使用默认值</span></span><br><span class="line"><span class="keyword">const</span> options = &#123;&#125;</span><br><span class="line"></span><br><span class="line">webPush.<span class="title function_">sendNotification</span>(</span><br><span class="line">  pushSubscription,</span><br><span class="line">  payload,</span><br><span class="line">  options</span><br><span class="line">).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;send failed: &#x27;</span>, err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="SW处理浏览器通知"><a href="#SW处理浏览器通知" class="headerlink" title="SW处理浏览器通知"></a>SW处理浏览器通知</h2><p>push service收到消息后，会通知浏览器(如果浏览器当前关闭了，下一次打开时会收到通知)，浏览器唤醒相应的SW，具体就是给SW发送”push”事件，SW处理push事件，并弹个小框将消息展示出来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sw.js</span></span><br><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;push&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> body;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">data</span>) &#123;</span><br><span class="line">    body = event.<span class="property">data</span>.<span class="title function_">text</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    body = <span class="string">&#x27;Default body&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    <span class="attr">body</span>: body,</span><br><span class="line">    <span class="attr">icon</span>: <span class="string">&#x27;images/notification-flat.png&#x27;</span>,</span><br><span class="line">    <span class="attr">vibrate</span>: [<span class="number">100</span>, <span class="number">50</span>, <span class="number">100</span>],</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">dateOfArrival</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>(),</span><br><span class="line">      <span class="attr">primaryKey</span>: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">actions</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">action</span>: <span class="string">&#x27;explore&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;Go to the site&#x27;</span>,</span><br><span class="line">        <span class="attr">icon</span>: <span class="string">&#x27;images/checkmark.png&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">action</span>: <span class="string">&#x27;close&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;Close the notification&#x27;</span>,</span><br><span class="line">        <span class="attr">icon</span>: <span class="string">&#x27;images/xmark.png&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  event.<span class="title function_">waitUntil</span>(</span><br><span class="line">    <span class="comment">// Show notification</span></span><br><span class="line">    self.<span class="property">registration</span>.<span class="title function_">showNotification</span>(<span class="string">&#x27;Push Notification&#x27;</span>, options);</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们通过<code>showNotification(title, options)</code>展示通知，第一个参数是标题，第二个参数是一些控制弹窗的选项：</p><ul><li><p>body：消息内容</p></li><li><p>icon：展示在内容旁边的大图标</p></li><li><p>vibrate：振动控制</p></li><li><p>data</p><p>SW不但可以展示消息，还可以处理用户的点击事件，这个data可以存储一些传递给点击处理的信息</p></li><li><p>actions</p><p>在消息弹框上设置一些点击按钮，这样我们可以根据不同的点击做不同的处理</p></li></ul><p>根据上面的设置，在chrome上的效果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1543563022606.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>而在firefox上actions却没有生效：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1543563131893.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>可见，每个浏览器的支持还不一样</p><h3 id="处理用户点击"><a href="#处理用户点击" class="headerlink" title="处理用户点击"></a>处理用户点击</h3><p>用户看到通知之后，可以选择关闭弹窗(如果有关闭按钮)或点击上面的任何区域，如果有actions按钮的话还可以点击按钮，点击之后SW会收到<code>notificationclick</code>事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;notificationclick&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> notification = event.<span class="property">notification</span>;</span><br><span class="line">  <span class="keyword">const</span> primaryKey = notification.<span class="property">data</span>.<span class="property">primaryKey</span>;</span><br><span class="line">  <span class="keyword">const</span> action = event.<span class="property">action</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (action !== <span class="string">&#x27;close&#x27;</span>) &#123;</span><br><span class="line">    event.<span class="title function_">waitUntil</span>(</span><br><span class="line">      clients.<span class="title function_">openWindow</span>(<span class="string">&#x27;samples/page&#x27;</span> + primaryKey + <span class="string">&#x27;.html&#x27;</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  notification.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果用户选择关闭消息窗口而不是点击其他区域，SW会收到<code>notificationclose</code>事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;notificationclose&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> notification = event.<span class="property">notification</span>;</span><br><span class="line">  <span class="keyword">const</span> primaryKey = notification.<span class="property">data</span>.<span class="property">primaryKey</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Closed notification: &#x27;</span> + primaryKey);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="VAPID介绍"><a href="#VAPID介绍" class="headerlink" title="VAPID介绍"></a>VAPID介绍</h2><p>从前面的流程来看，任何web server只要它拿到了subscription信息都可以向我们push消息，因为push service没法判断谁是合法的pusher，这可能会导致某些安全问题，如DDOS攻击；另外，如果web server在push过程中出问题了，push service也没法和pusher取得联系。所以，我们有必要对web server做标识，区分出合法的pusher，这就是<a href="https://tools.ietf.org/html/draft-ietf-webpush-vapid-01">VAPID(Voluntary Application Server Identification</a>的来源</p><p>具体来说，我们为web server生成一个密匙对，包含公匙和私匙，并加上一个email地址，以便发生问题时push service可以联系server。加上VAPID后，在代码逻辑上需要做一点修改：</p><ul><li><p>在client订阅的时候需要加上VAPID中的public key</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> applicationServerPublicKey = <span class="string">&#x27;.........&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> applicationServerKey = <span class="title function_">urlB64ToUint8Array</span>(applicationServerPublicKey);</span><br><span class="line">swRegistration.<span class="property">pushManager</span>.<span class="title function_">subscribe</span>(&#123;</span><br><span class="line">  <span class="attr">userVisibleOnly</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">applicationServerKey</span>: applicationServerKey</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">subscription</span> =&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>server端push消息的时候要加上整个VAPID信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 密匙对：可以使用web-push生成</span></span><br><span class="line"><span class="keyword">const</span> vapidPublicKey = <span class="string">&#x27;...&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> vapidPrivateKey = <span class="string">&#x27;...&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> payload = <span class="string">&#x27;Here is a payload!&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  <span class="attr">TTL</span>: <span class="number">600</span>,</span><br><span class="line">  <span class="attr">vapidDetails</span>: &#123;</span><br><span class="line">    <span class="attr">subject</span>: <span class="string">&#x27;mailto: ********@***.com&#x27;</span>,</span><br><span class="line">    <span class="attr">publicKey</span>: vapidPublicKey,</span><br><span class="line">    <span class="attr">privateKey</span>: vapidPrivateKey</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">webPush.<span class="title function_">sendNotification</span>(</span><br><span class="line">  pushSubscription,</span><br><span class="line">  payload,</span><br><span class="line">  options</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><p>更多细节请参考一下文档：</p><p><a href="https://developers.google.com/web/ilt/pwa/introduction-to-push-notifications">https://developers.google.com/web/ilt/pwa/introduction-to-push-notifications</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;push notification是PWA的重要组成部分，它使得web程序也具有native app类似的”离线”通知功能：即使程序的页面被关掉了，用户依然可以收到服务端发送的通知消息。push notification机制建立在service worker之上，是以下几个</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="html5" scheme="http://tomwang1013.github.io/tags/html5/"/>
    
    <category term="push notification" scheme="http://tomwang1013.github.io/tags/push-notification/"/>
    
  </entry>
  
  <entry>
    <title>响应式图片设计的几个核心概念</title>
    <link href="http://tomwang1013.github.io/responsive-image-core-concepts/"/>
    <id>http://tomwang1013.github.io/responsive-image-core-concepts/</id>
    <published>2018-11-22T10:04:11.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<p>提到响应式图片设计，我们脑海中首先闪现的是<code>picture</code>, <code>source</code>, <code>secret</code>, <code>sizes</code>这些新的标签或属性，内容很多，且似乎都不是一看就能明白的道理，关于此方面的文章也多，一般看了过段时间就忘了，今天自己也来总结一下，做个备忘</p><p>初衷是这样的：由于设备的多样性，我们希望在不同的设备上，从图片大小和质量上选择最合适的图片！比如说屏幕只有300px，我们肯定不希望加载1000px的原图；比如说在高分辨率的设备上，我们希望提供比普通分辨率上更大的图片。所以我们设置多种条件以及每种条件下的图片，用来<strong>引导浏览器</strong>根据设备的情况和我们设定的条件选择最好的图片。这种选择是浏览器做出的，只要信息足够多，它就能选出最合适的图片</p><p>在具体讨论这些新的标签或属性之前，我们先搞清楚几个基本的概念：</p><ul><li><p><strong>device pixel radio(dpr)</strong>: 设备像素比</p><p>一个css像素对应多少个设备像素：如果dpr是2，则一个css像素对应2个物理像素</p></li><li><p><strong>image real width</strong>: 图片的真实宽度</p><p>就是图片文件里面记录的图片的真实宽度，单位是<em>物理px</em></p></li><li><p><strong>image display width</strong>: 图片的展示宽度</p><p>就是我们通过css或width属性给图片设置的宽度，单位是<em>css px</em></p></li><li><p><strong>window width</strong>: 浏览器窗口宽度</p><p>就是浏览器viewport的宽度，单位是<em>css px</em></p></li></ul><p>有了这些基础概念，我们再思考一个简单的问题：</p><blockquote><p>假设当前设备的dpr是2，一个图片的真实宽度是400px，我们没有给图片设置展示宽度，那么图片的默认展示宽度是多少？</p></blockquote><p>答案是200 (css)px，也就是<code>物理宽度/dpr</code></p><p>好了，准备工作差不多了，我们开始讨论具体情况，首先考虑一种最简单最常见的情况：</p><h1 id="fixed-size-varying-density-在不同分辨率下展示不同的图片，而图片的展示宽度固定"><a href="#fixed-size-varying-density-在不同分辨率下展示不同的图片，而图片的展示宽度固定" class="headerlink" title="fixed size, varying density: 在不同分辨率下展示不同的图片，而图片的展示宽度固定"></a>fixed size, varying density: 在不同分辨率下展示不同的图片，而图片的展示宽度固定</h1><p>简单，只需要在img的srcset中指定不同dpr对应的图片url即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">&quot;320&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;pic-2x.png 2x, pic-3x.png 3x&quot;</span> <span class="attr">src</span>=<span class="string">&quot;pic.png&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器自动会根据当前dpr去加载对应的图片，如果所有dpr都不匹配，就会取src中的图片。</p><p>我们甚至都不需要指定width，只要我们的图片是按dpr等比例设置尺寸的，直接按默认宽度展示即可，因为在任何分辨率下展示的宽度都是一样的</p><h1 id="varying-size-varying-density：图片的展示大小不固定，分辨率也不固定"><a href="#varying-size-varying-density：图片的展示大小不固定，分辨率也不固定" class="headerlink" title="varying size, varying density：图片的展示大小不固定，分辨率也不固定"></a>varying size, varying density：图片的展示大小不固定，分辨率也不固定</h1><p>如果展示大小不固定，而在图片下载完之前浏览器是无法知道图片的的真实大小的，所以我们可以提供这些信息给浏览器：在srcset中指定图片的真实大小，在sizes指定我们期望图片的展示大小，浏览器会根据这些条件，并考虑当前dpr，去加载最合适的图片，所谓<em>最合适的图片</em>，就是尺寸最小的符合展示大小的图片。</p><p>举个例子：</p><p>假设当前dpr是2，当前窗口大小是700px，我们设置如下img：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;default.png&quot;</span> </span></span><br><span class="line"><span class="tag">     <span class="attr">srcset</span>=<span class="string">&quot;small.png 500w, medium.png 800w, large.png 1400w&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">sizes</span>=<span class="string">&quot;(min-width: 1000) 800px，(min-width: 800) 600px, (min-width: 500) 400px， 50vm&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>srcset中的宽度是图片的<strong>真实宽度</strong>，而sizes中的单位都是css像素</p><p>由于当前窗口宽度是700，所以满足sizes中的第三个条件：<code>(min-width: 500) 400px</code>，这样浏览器认为图片的展示宽度是400px，而当前dpr是2，所以它会去加载真实宽度大于或等于400*2&#x3D;800的最小的图片，从srcset中我们得知，满足这个条件的最合适的图片是medium.png，所以浏览器只会去加载这张图片</p><h1 id="更强大的picture"><a href="#更强大的picture" class="headerlink" title="更强大的picture"></a>更强大的picture</h1><p>上面提到的sizes中包含了media query，如<code>(min-width: 1000)</code>等，但是sizes中能使用的media query是有限制的，比如如果你想实现在横屏竖屏下使用不用的图片，用sizes就没法做，这时我们可以使用更强大的picture元素，它的source子元素可以使用真正的css media query，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">picture</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">&quot;(min-width: 750px)&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">srcset</span>=<span class="string">&quot;images/horses-1600_large_2x.jpg 2x,</span></span></span><br><span class="line"><span class="string"><span class="tag">                      images/horses-800_large_1x.jpg&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">source</span> <span class="attr">media</span>=<span class="string">&quot;(min-width: 500px)&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">srcset</span>=<span class="string">&quot;images/horses_medium.jpg&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/horses_small.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Horses in Hawaii&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">picture</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>Horses in Hawaii<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器会找到第一个满足media条件的source，否则使用后面的img元素。source和img中的srcset和sizes和前面将的一样处理，唯一值得注意的是source中不能使用src属性来指定默认图片，但是可以在srcset中指定默认图片</p><p>我们还可是使用picture来选择图片格式，如对新的浏览器使用webp等高级图片格式：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1542889563147.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>参考文档：</p><p><a href="https://jakearchibald.com/2015/anatomy-of-responsive-images/">https://jakearchibald.com/2015/anatomy-of-responsive-images/</a></p><p><a href="https://developers.google.com/web/ilt/pwa/lab-responsive-images">https://developers.google.com/web/ilt/pwa/lab-responsive-images</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;提到响应式图片设计，我们脑海中首先闪现的是&lt;code&gt;picture&lt;/code&gt;, &lt;code&gt;source&lt;/code&gt;, &lt;code&gt;secret&lt;/code&gt;, &lt;code&gt;sizes&lt;/code&gt;这些新的标签或属性，内容很多，且似乎都不是一看就能明白的道理，关于此</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="html5" scheme="http://tomwang1013.github.io/tags/html5/"/>
    
    <category term="responsive design" scheme="http://tomwang1013.github.io/tags/responsive-design/"/>
    
  </entry>
  
  <entry>
    <title>对webpack的几个核心概念的理解</title>
    <link href="http://tomwang1013.github.io/webpack-core-concepts/"/>
    <id>http://tomwang1013.github.io/webpack-core-concepts/</id>
    <published>2018-11-22T02:08:42.000Z</published>
    <updated>2023-07-18T03:20:12.568Z</updated>
    
    <content type="html"><![CDATA[<p>webpack是公认的功能强大但是难用的工具，虽然文档很全，但是由于各种配置太多且很多配置只有经过测试才能发现其意义，虽然自己从两年前就开始使用了，但是也只是勉强能给出符合项目要求的配置而已。最近webpack4发布了，自己又从头开始仔细读了一下它的guide文档，并按照文档的示例跑了一遍，对webpack的几个核心概念终于有了稍微清晰的认识，这里记录一下</p><ul><li><p><strong>chunk</strong></p><p>chunk大概是文档中出现最频繁的单词，它指的是webpack最终输出的文件。chunk有两种类型：</p><ul><li><p>entry chunk</p><p>就是在entry配置中的入口文件，最终输出的文件名由另一个配置项<code>output.filename</code>决定</p></li><li><p>其他chunk</p><p>除了entry chunk外，webpack会根据我们的配置及代码情况自动输出很多文件，如<code>optimization.splitChunks</code>提取出的公共文件，<code>dynamic.import</code>生成的延迟加载文件</p><p>这种chunk的输出文件名由配置项<code>output.chunkFilename</code>决定</p></li></ul></li><li><p><strong>module</strong></p><p>module就是我们代码中通过import或require引入的一个文件，可以是js，css或图片等等。注意它和chunk的不同：chunk是最终的输出文件，而module是编码时的内部引用</p></li><li><p><strong>runtime &amp; manifest</strong></p><p>为了使得这一套打包系统能够正常工作，也就是浏览器引入我们最终生成的chunk文件后能运转起来，包括module的解析引用能顺利进行，webpack提供了一段支撑代码，就是runtime。runtime最主要的工作就是module依赖关系的解析及module的导入，所以，在runtime中我们还需要所有module的一些meta信息，如各个module的唯一标识id及关系等等，这些信息称为manifest</p><p>这个runtime代码可以包含在entry chunk中，或者单独提取出来作为独立的<strong>runtime chunk</strong>；在html文件中，runtime chunk一般放在entry chunk前面</p></li><li><p><strong>caching</strong></p><p>提到caching，标准的做法是做<a href="https://webpack.js.org/guides/code-splitting/">code splitting</a>，将runtime代码, 第三方库代码及自己的代码分离开来打成独立的chunk并在chunk的输出文件名中带上chunkhash：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">output</span>: &#123;</span><br><span class="line">  <span class="attr">filename</span>: <span class="string">&#x27;[name].bundle.[contenthash].js&#x27;</span>,</span><br><span class="line">  <span class="attr">chunkFilename</span>: <span class="string">&#x27;[name].bundle.[contenthash].js&#x27;</span>,</span><br><span class="line">  <span class="attr">path</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">optimization</span>: &#123;</span><br><span class="line">  <span class="attr">runtimeChunk</span>: <span class="string">&#x27;single&#x27;</span>,</span><br><span class="line">  <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">    <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">      <span class="attr">vender</span>: &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;vendors&#x27;</span>,</span><br><span class="line">        <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样会打出三个chunk文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">                           Asset       Size  Chunks                    Chunk Names</span><br><span class="line">  vendor.a7561fb0e9a071baadb9.js     541 kB       0  [emitted]  [big]  vendor</span><br><span class="line">    main.b746e3eb72875af2caa9.js    1.22 kB       1  [emitted]         main</span><br><span class="line">manifest.1400d5af64fc1b7b3a45.js    5.85 kB       2  [emitted]         manifest</span><br><span class="line">                      index.html  352 bytes          [emitted]</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但是<em>这还不够</em>：如果这时候我们增加或删除一个module，这三个chunk的内容都可能发生变化；原因是<strong>默认情况下module的id是按照引用顺序从0递增</strong>，所以增加或删除module会导致其他module的id发生变化。要避免这种情况，就要让module的id只和自己有关，这个时候就要用到<a href="https://webpack.js.org/plugins/hashed-module-ids-plugin">HashedModuleIdsPlugin</a>，它使得module的id和自己内容的hash绑定，只要内容不变，id就不变：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line"><span class="keyword">new</span> webpack.<span class="title class_">HashedModuleIdsPlugin</span>()</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>待续…</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;webpack是公认的功能强大但是难用的工具，虽然文档很全，但是由于各种配置太多且很多配置只有经过测试才能发现其意义，虽然自己从两年前就开始使用了，但是也只是勉强能给出符合项目要求的配置而已。最近webpack4发布了，自己又从头开始仔细读了一下它的guide文档，并按照文</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="webpack" scheme="http://tomwang1013.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Same-origin policy(SOP)和Content Security Policy(CSP)拾遗</title>
    <link href="http://tomwang1013.github.io/sop-csp-intro/"/>
    <id>http://tomwang1013.github.io/sop-csp-intro/</id>
    <published>2018-11-21T02:46:40.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SOP"><a href="#SOP" class="headerlink" title="SOP"></a>SOP</h1><p>浏览器的同源策略(Same-origin policy，下面简称<strong>SOP</strong>)用来控制document及其里面的script如何访问不同域的资源，政策大家都听过，但是细节很多，这里做个总结备忘</p><h2 id="cross-site-ajax-request"><a href="#cross-site-ajax-request" class="headerlink" title="cross-site ajax request"></a>cross-site ajax request</h2><p>跨域ajax请求，毫无疑问是被阻止的，这也是我们对SOP的第一印象</p><h2 id="cross-site-script-API-access"><a href="#cross-site-script-API-access" class="headerlink" title="cross-site script API access"></a>cross-site script API access</h2><p>跨域访问另一个文档的内容，也是被阻止的</p><p>但是，我们可以拿到另一个文档的window对象，这个对象暴露了很有限的属性或方法可以访问：</p><p>The following cross-origin access to these <code>Window</code> properties is allowed:</p><table><thead><tr><th>Methods</th></tr></thead><tbody><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/blur"><code>window.blur</code></a></td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/close"><code>window.close</code></a></td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/focus"><code>window.focus</code></a></td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage"><code>window.postMessage</code></a></td></tr></tbody></table><table><thead><tr><th>Attributes</th><th></th></tr></thead><tbody><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/closed"><code>window.closed</code></a></td><td>Read only.</td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/frames"><code>window.frames</code></a></td><td>Read only.</td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/length"><code>window.length</code></a></td><td>Read only.</td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/location"><code>window.location</code></a></td><td>Read&#x2F;write.</td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/opener"><code>window.opener</code></a></td><td>Read only.</td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/parent"><code>window.parent</code></a></td><td>Read only.</td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/self"><code>window.self</code></a></td><td>Read only.</td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/top"><code>window.top</code></a></td><td>Read only.</td></tr><tr><td><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/window"><code>window.window</code></a></td><td>Read only.</td></tr></tbody></table><h2 id="Cross-origin-network-access"><a href="#Cross-origin-network-access" class="headerlink" title="Cross-origin network access"></a>Cross-origin network access</h2><p>和js发起的请求不一样，浏览器自动发起的跨域请求很多情况下是允许的，如：</p><ul><li>Cross-origin <em>writes</em>：如链接(link)、重定向(redirect)及表单提交(form submission)</li><li>Cross-origin <em>embedding</em>：资源嵌套，如：<ul><li><code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code></li><li><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;…&quot;&gt;</code></li><li><code>&lt;img&gt;</code></li><li><code>&lt;video&gt;</code>和<code>&lt;audio&gt;</code></li><li>插件嵌入：<code>&lt;object&gt;</code>, <code>&lt;embed&gt;</code>, <code>&lt;applet&gt;</code></li><li><code>@font-face</code>引入的字体文件(有些浏览器不允许)</li><li><code>&lt;iframe src=&quot;...&quot;&gt;</code>(可以使用<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options">X-Frame-Options</a>来阻止页面被嵌入其他网站)</li></ul></li><li>Cross-origin <em>reads</em>：和embedding不一样，这个不是为了将资源展示出来，而是为了读取资源的内容，比如说我在img标签中将src设置为一个html或json文档。现在浏览器已经做了<a href="https://www.chromium.org/Home/chromium-security/corb-for-developers">一些事</a>来阻止这种行为</li></ul><h3 id="如何允许跨域访问"><a href="#如何允许跨域访问" class="headerlink" title="如何允许跨域访问"></a>如何允许跨域访问</h3><p> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">CORS</a></p><h3 id="如何阻止跨域访问"><a href="#如何阻止跨域访问" class="headerlink" title="如何阻止跨域访问"></a>如何阻止跨域访问</h3><p>CSRF token</p><h2 id="Cross-origin-data-storage-access"><a href="#Cross-origin-data-storage-access" class="headerlink" title="Cross-origin data storage access"></a>Cross-origin data storage access</h2><ol><li><p>对localStorage(包括sessionStorage)和indexDB来说，它们是严格按origin划分的。一个origin中的js不能访问另一个origin中的存储</p></li><li><p>对cookie来说，情况稍微有点不同：</p><ol><li><p>我们创建一个cookie时，cookie.domain可以设置成当前domain或当前domain的父domain</p></li><li><p>我们给cookie设置一个domain，这个cookie对所有子domain也是可见的：For example, if <code>Domain=mozilla.org</code> is set, then cookies are included on subdomains like <code>developer.mozilla.org</code>。</p><p>If domain is not unspecified, it defaults to the host of the current document location, <strong>excluding subdomains</strong>. If <code>Domain</code> <em>is</em> specified, then subdomains are always included.</p></li></ol></li></ol><h1 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h1><p>Content Security Policy(下面简称CSP)是浏览器用来控制页面上所有资源(js, css, img, etc)的来源，初衷是为了减少页面受攻击的可能性。比如XSS攻击是用户不小心执行了攻击者放入页面的脚本，用CSP我们可以限制页面上js的来源，这样我们只能执行特定来源的js从而使得这种攻击不会发生</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用CSP很简单，只需由web server在响应头中指定<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy">Content-Security-Policy</a>头，格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Content</span>-<span class="title class_">Security</span>-<span class="title class_">Policy</span>: policy</span><br></pre></td></tr></table></figure><p>这里的policy就可以控制各个资源的加载，举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src &#x27;self&#x27;; img-src *; media-src media1.com </span><br><span class="line">media2.com; script-src userscripts.example.com</span><br></pre></td></tr></table></figure><p>这个policy说明了：</p><ul><li>默认情况下，资源只能从本地加载(default-src ‘self’)</li><li>图片能从任何地方加载(img-src *)</li><li>音视频只能从media1.com media2.com这两个地方加载</li><li>只执行从userscripts.example.com加载的js脚本(script-src userscripts.example.com)</li></ul><p>参考文档：</p><p><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy">https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP">https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies">https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SOP&quot;&gt;&lt;a href=&quot;#SOP&quot; class=&quot;headerlink&quot; title=&quot;SOP&quot;&gt;&lt;/a&gt;SOP&lt;/h1&gt;&lt;p&gt;浏览器的同源策略(Same-origin policy，下面简称&lt;strong&gt;SOP&lt;/strong&gt;)用来控制document及</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="security" scheme="http://tomwang1013.github.io/tags/security/"/>
    
    <category term="http" scheme="http://tomwang1013.github.io/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>webpack sideEffects选项简介</title>
    <link href="http://tomwang1013.github.io/webpack-sideEffects/"/>
    <id>http://tomwang1013.github.io/webpack-sideEffects/</id>
    <published>2018-11-20T08:51:45.000Z</published>
    <updated>2023-07-18T03:20:12.568Z</updated>
    
    <content type="html"><![CDATA[<p>webpack的<code>sideEffects</code>选项和<a href="https://webpack.js.org/guides/tree-shaking/">tree shaking</a>有关，按照官方文档我测试了下这个选项对打包代码的影响，示例代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;math has side effects&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">cube</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; cube, square &#125; <span class="keyword">from</span> <span class="string">&#x27;./math.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">component</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;pre&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  element.<span class="property">innerHTML</span> = [</span><br><span class="line">    <span class="string">&#x27;Hello webpack!&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;5 cubed is equal to 125&#x27;</span><span class="comment">/*  + cube(5) */</span></span><br><span class="line">  ].<span class="title function_">join</span>(<span class="string">&#x27;\n\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="title function_">component</span>());</span><br></pre></td></tr></table></figure><p>index.js虽然import了math.js，但是没有用到import进来的方法，按我们的理解最终math.js的代码最终会打包进来，下面分三种情况做下测试：</p><ol><li><p>sideEffects不设置，看默认情况</p><p>只有<code>console.log(&quot;math has side effects&quot;);</code>这句代码被打包进来，math.js中的其他两个函数都没有打包</p><p>看来webpack已经很智能了：即使你引入了，只要没使用都不会打包进来</p></li><li><p>sideEffects: false</p><p>math中的任何代码都没有打进来，和预期的一致：这个选项告诉webpack，我的文件没有任何<em>副作用</em></p></li><li><p>sideEffects: [“.&#x2F;src&#x2F;math.js”]</p><p>和第一种情况一样：这里显式指明有副作用的文件，这样webpack会把文件中没有用到的代码也打包进来</p></li></ol><p><strong>总结：</strong></p><p>即使你不做任何事情，webpack的tree shaking机制也已经在起作用了，并且作用得很好</p><p>注意：此处我们用的是webpack 4，它在production环境下会自动开启minification和tree shaking机制</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;webpack的&lt;code&gt;sideEffects&lt;/code&gt;选项和&lt;a href=&quot;https://webpack.js.org/guides/tree-shaking/&quot;&gt;tree shaking&lt;/a&gt;有关，按照官方文档我测试了下这个选项对打包代码的影响，示例代码如</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="webpack" scheme="http://tomwang1013.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>module javascript(mjs)介绍</title>
    <link href="http://tomwang1013.github.io/mjs-intro/"/>
    <id>http://tomwang1013.github.io/mjs-intro/</id>
    <published>2018-11-15T05:38:19.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<p>作为前端工程师，我们基本都被<code>webpack</code>和<code>babel</code>蹂躏过，并且将继续被蹂躏。<strong>module javascript</strong>(下面简称mjs)带来了一点点曙光，本文简单介绍一下mjs</p><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>我们知道，一个js模块是封闭的：它里面定义的所有顶层变量的作用范围都是在模块之内；它对外的接口需要手动导出(export)，模块是我们写代码的正确姿势。但是普通的js文件被浏览器引入之后它里面的代码都是在全局作用域运行的，这才导致了各种模块加载方式的出现，如commonJS，AMD, es6 Module等。</p><p>mjs指的是在浏览器端可以直接引用es6 module模块，和普通的js一样，可以引入一个文件，也可以直接inline：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;main.mjs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">&#x27;./bar.mjs&#x27;</span></span></span><br><span class="line"><span class="language-javascript">  ...</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>模块文件一般以<code>mjs</code>作为后缀，里面可以使用import和export，和平时的写法一样</p><h1 id="mjs和普通js的区别"><a href="#mjs和普通js的区别" class="headerlink" title="mjs和普通js的区别"></a>mjs和普通js的区别</h1><p>加上<code>type=&quot;module&quot;</code>之后，引入的js变成了mjs，它和普通的js有很多区别：</p><ol><li><p>mjs默认使用<code>strict mode</code></p></li><li><p>mjs中定义的顶层变量不再是全局变量</p></li><li><p>新的import和export语法只能在mjs中使用，不能再普通js中使用</p></li><li><p>不管被加载多少次，同一个mjs只执行一次；而普通的js每次加载都会执行</p></li><li><p>mjs通过CORS的方式加载，需要服务端的配合；而普通js直接可以跨域加载</p></li><li><p>mjs默认是defer，而普通js需要指定defer属性</p></li><li><p>inline mjs默认也是defer，而普通inline js无法defer</p></li><li><p>inline mjs可以设置async属性，而普通inline js无法async</p><p>这里有张经典的图可以说明上面几条性质：</p><p><img src="/../images/1542269076755.png"></p></li></ol><h2 id="其他注意点"><a href="#其他注意点" class="headerlink" title="其他注意点"></a>其他注意点</h2><ol><li><p>mjs文件的路径(import * from <strong>modulePath</strong>)的限制：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Not supported (yet):</span></span><br><span class="line"><span class="keyword">import</span> &#123;shout&#125; <span class="keyword">from</span> <span class="string">&#x27;jquery&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;shout&#125; <span class="keyword">from</span> <span class="string">&#x27;lib.mjs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;shout&#125; <span class="keyword">from</span> <span class="string">&#x27;modules/lib.mjs&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Supported:</span></span><br><span class="line"><span class="keyword">import</span> &#123;shout&#125; <span class="keyword">from</span> <span class="string">&#x27;./lib.mjs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;shout&#125; <span class="keyword">from</span> <span class="string">&#x27;../lib.mjs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;shout&#125; <span class="keyword">from</span> <span class="string">&#x27;/modules/lib.mjs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;shout&#125; <span class="keyword">from</span> <span class="string">&#x27;https://simple.example/modules/lib.mjs&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>对于CORS请求，如果是同域的话，需要注意是否发送credentials(cookies, etc)</p><p>大部分和CORS相关的api如果是请求同域的话，默认都会发送credentials的，但是fetch和mjs是个例外，你可能需要设置<code>crossorigin </code>才能发送：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- <span class="title class_">Fetched</span> <span class="keyword">with</span> credentials (cookies etc) --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="title class_">Fetched</span> without credentials --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;1.mjs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="title class_">Fetched</span> <span class="keyword">with</span> credentials --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">&quot;1.mjs?&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="title class_">Fetched</span> without credentials --&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">&quot;https://other-origin/1.mjs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- <span class="title class_">Fetched</span> <span class="keyword">with</span> credentials--&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;use-credentials&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://other-origin/1.mjs?&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>但是这个例外未来很可能会变成不例外：</p><p>Both <code>fetch()</code> and module scripts will send credentials to same-origin URLs by default. <a href="https://github.com/whatwg/fetch/pull/585">Issue</a></p></li><li><p>要使mjs生效，服务端必须明确在对mjs文件的响应中把<code>content-type</code>设置为js格式：推荐为<code>text/javascript</code></p></li></ol><h1 id="有了mjs，还需要打包吗？"><a href="#有了mjs，还需要打包吗？" class="headerlink" title="有了mjs，还需要打包吗？"></a>有了mjs，还需要打包吗？</h1><p>简单答案是：要</p><p>但是mjs提供了一些想象的优化空间，值得注意一下。</p><p>TODO</p><p>参考文档：</p><p><a href="https://developers.google.com/web/fundamentals/primers/modules">https://developers.google.com/web/fundamentals/primers/modules</a></p><p><a href="https://jakearchibald.com/2017/es-modules-in-browsers/">https://jakearchibald.com/2017/es-modules-in-browsers/</a></p><p><a href="https://philipwalton.com/articles/deploying-es2015-code-in-production-today/">https://philipwalton.com/articles/deploying-es2015-code-in-production-today/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作为前端工程师，我们基本都被&lt;code&gt;webpack&lt;/code&gt;和&lt;code&gt;babel&lt;/code&gt;蹂躏过，并且将继续被蹂躏。&lt;strong&gt;module javascript&lt;/strong&gt;(下面简称mjs)带来了一点点曙光，本文简单介绍一下mjs&lt;/p&gt;
&lt;h1</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="html5" scheme="http://tomwang1013.github.io/tags/html5/"/>
    
    <category term="es6" scheme="http://tomwang1013.github.io/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>使用preload &amp; prefetch提高加载速度</title>
    <link href="http://tomwang1013.github.io/preload-prefetch/"/>
    <id>http://tomwang1013.github.io/preload-prefetch/</id>
    <published>2018-11-15T02:33:47.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述：提前加载资源，用的时候直接从本地取"><a href="#概述：提前加载资源，用的时候直接从本地取" class="headerlink" title="概述：提前加载资源，用的时候直接从本地取"></a>概述：提前加载资源，用的时候直接从本地取</h1><p>对一些资源，如css，js，font，img等，我们可以不必等到<strong>用的时候</strong>再按常规加载，而可以提前加载好(注意：<strong>只是先准备好，并不会马上生效</strong>)，等到需要用的时候直接取就行了，举两个例子：</p><ol><li><p>我们通常把js放在底部：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样这个js必须等到页面解析完才能被加载并执行。其实我们可以先把这个js下载到本地，等页面解析到这里时直接从本地去，这样就省去了一部分网络加载时间：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">ref</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;script&quot;</span> <span class="attr">href</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>一些资源是动态加载的，我们可以把这些资源提前加载好，假设页面的管家加载路径如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├─┬ / (initial HTML file)  </span><br><span class="line">  └── fetch-css.js</span><br><span class="line">    └── main.css  </span><br><span class="line">      └── K2D.woff2</span><br></pre></td></tr></table></figure><p>这时网络加载顺序如下：</p><p><img src="/../images/1542250691369.png"></p><p>我们可以把<code>main.css</code>和<code>k2D.woff2</code>提前加载好：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;main.css&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;fonts/K2D.woff2&quot;</span> <span class="attr">as</span>=<span class="string">&quot;font&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改之后这两个文件提前加载了：</p><p><img src="/../images/1542250734658.png"></p><p>这样节省了不少时间，提高了首屏渲染速度</p></li></ol><h1 id="preload-vs-prefetch"><a href="#preload-vs-prefetch" class="headerlink" title="preload vs prefetch"></a>preload vs prefetch</h1><p>它们的区别就是资源加载的优先级不同：preload的优先级更高，所以它加载的资源一般是本页面要用到的；而prefetch的优先级很低，浏览器只有在空闲的时候才回去加载，它加载的资源一般会在其他页面用到</p><p>对于preload，如果加载的资源在一定时间内没有用到(就是没有再去加载)，浏览器就会报出警告：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1542251177102.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="其他注意点"><a href="#其他注意点" class="headerlink" title="其他注意点"></a>其他注意点</h1><ol><li><p>cross-origin fetch</p><p>可以设置<code>crossorigin</code>属性加载跨域资源：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;other-site/main.css&quot;</span> <span class="attr">as</span>=<span class="string">&quot;style&quot;</span> <span class="attr">crossorigin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>字体比较特殊，即使同域也需要加上：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;fonts/K2D.woff2&quot;</span> <span class="attr">as</span>=<span class="string">&quot;font&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>动态加载preload资源</p><p>可以用js来加载preload资源：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preloadLink = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;link&quot;</span>);</span><br><span class="line">preloadLink.<span class="property">href</span> = <span class="string">&quot;myscript.js&quot;</span>;</span><br><span class="line">preloadLink.<span class="property">rel</span> = <span class="string">&quot;preload&quot;</span>;</span><br><span class="line">preloadLink.<span class="property">as</span> = <span class="string">&quot;script&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(preloadLink);</span><br></pre></td></tr></table></figure><p>然后像平时一样使用它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preloadedScript = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">preloadedScript.<span class="property">src</span> = <span class="string">&quot;myscript.js&quot;</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(preloadedScript);</span><br></pre></td></tr></table></figure></li><li><p>webpack提供支持</p><p>webpack提供了code splitting的机制，可以让我们动态加载js文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">form.<span class="title function_">addEventListener</span>(<span class="string">&quot;submit&quot;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  e.<span class="title function_">preventDefault</span>()</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">&#x27;lodash.sortby&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">module</span> =&gt;</span> <span class="variable language_">module</span>.<span class="property">default</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="title function_">sortInput</span>())</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="title function_">alert</span>(err) &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们也可以把这个文件preload &amp; prefetch：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">form.<span class="title function_">addEventListener</span>(<span class="string">&quot;submit&quot;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  e.<span class="title function_">preventDefault</span>()</span><br><span class="line">  <span class="keyword">import</span>(<span class="comment">/* webpackPrefetch: true */</span> <span class="string">&#x27;lodash.sortby&#x27;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">module</span> =&gt;</span> <span class="variable language_">module</span>.<span class="property">default</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="title function_">sortInput</span>())</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="title function_">alert</span>(err) &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="/../images/1542251898245.png"></p><p>webpack会自动将prefetch link标签插入到head中</p></li><li><p>和浏览器内置的preloader的区别</p><p>我们知道浏览器可能有内置的对我们不可见的preloader会提前解析html文件找出需要加载，但是这个机制是没有标准的，每个浏览器都不一样，况且不是所有资源都写在html脚本中的，所以本篇说的preload和这个是完全不同的两件事</p></li></ol><h1 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h1><p>目前只有chrome支持，但是其他浏览器都在积极实现中，考虑到chrome No.1的市场地位，值得一试</p><p>参考文档：</p><p><a href="https://web.dev/fast/preload-critical-assets/codelab-preload-critical-assets">https://web.dev/fast/preload-critical-assets/codelab-preload-critical-assets</a></p><p><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Preloading_content">https://developer.mozilla.org/en-US/docs/Web/HTML/Preloading_content</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述：提前加载资源，用的时候直接从本地取&quot;&gt;&lt;a href=&quot;#概述：提前加载资源，用的时候直接从本地取&quot; class=&quot;headerlink&quot; title=&quot;概述：提前加载资源，用的时候直接从本地取&quot;&gt;&lt;/a&gt;概述：提前加载资源，用的时候直接从本地取&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="html5" scheme="http://tomwang1013.github.io/tags/html5/"/>
    
    <category term="performance" scheme="http://tomwang1013.github.io/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>PWA的一种fetch模式：cache then network</title>
    <link href="http://tomwang1013.github.io/pwa-cache-then-network/"/>
    <id>http://tomwang1013.github.io/pwa-cache-then-network/</id>
    <published>2018-11-14T07:12:08.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>PWA中处理请求有很多种模式，比如：</p><ul><li><p>Cache falling back to network</p><p>先查询缓存，有的话取缓存的数据；没有的话再请求服务端数据</p></li><li><p>Network falling back to cache</p><p>和上面一种刚好相反</p></li></ul><p>这是比较常见的两种，还有一种，就是今天我们要介绍的：<code>cache then network</code>，什么意思呢？就是同时发请求及查询缓存，如果缓存中有数据的话先用缓存的数据；当请求返回数据后再用返回的数据覆盖。这种方式适合内容更新比较频繁的请求，先让用户尽快看到内容，然后看到最新的内容</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1542333273980.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>代码实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> networkDataReceived = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">startSpinner</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. fetch fresh data</span></span><br><span class="line"><span class="keyword">var</span> networkUpdate = <span class="title function_">fetch</span>(<span class="string">&#x27;/data.json&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  networkDataReceived = <span class="literal">true</span>;</span><br><span class="line">  <span class="title function_">updatePage</span>(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. fetch cached data</span></span><br><span class="line">caches.<span class="title function_">match</span>(<span class="string">&#x27;/data.json&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!response) <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&quot;No data&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="comment">// don&#x27;t overwrite newer network data</span></span><br><span class="line">  <span class="keyword">if</span> (!networkDataReceived) &#123;</span><br><span class="line">    <span class="title function_">updatePage</span>(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// we didn&#x27;t get cached data, the network is our last hope:</span></span><br><span class="line">  <span class="keyword">return</span> networkUpdate;</span><br><span class="line">&#125;).<span class="title function_">catch</span>(showErrorMessage).<span class="title function_">then</span>(<span class="title function_">stopSpinner</span>());</span><br></pre></td></tr></table></figure><p>一般来说缓存中的数据先被取出来展示，网络请求完成后再用最新的数据刷新页面。</p><p>这种方式需要sw配合，sw收到fetch时就不能直接读缓存了，需要直接向服务端发起请求，并将返回的数据写入缓存：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sw.js</span></span><br><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;fetch&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="title function_">respondWith</span>(</span><br><span class="line">    caches.<span class="title function_">open</span>(<span class="string">&#x27;mysite-dynamic&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">cache</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fetch</span>(event.<span class="property">request</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">        cache.<span class="title function_">put</span>(event.<span class="property">request</span>, response.<span class="title function_">clone</span>());</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>大概就这样了，这种模式可能不太常用，但是碰到特殊场景时还是不错的</p><h1 id="和Stale-while-revalidate的区别"><a href="#和Stale-while-revalidate的区别" class="headerlink" title="和Stale-while-revalidate的区别"></a>和Stale-while-revalidate的区别</h1><p><code>stale-while-revalidate</code>是另外一种模式：还是从缓存中取，取完之后再在后台发起一个请求得到最新的数据来刷新缓存，这样可以保持缓存的数据是比较新的(虽然不是最新的)。在这种模式下，客户端不用直接读缓存，一切逻辑都在sw里面：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1542333368951.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>sw的实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;fetch&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="title function_">respondWith</span>(</span><br><span class="line">    caches.<span class="title function_">open</span>(<span class="string">&#x27;mysite-dynamic&#x27;</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">cache</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cache.<span class="title function_">match</span>(event.<span class="property">request</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">response</span>) &#123;</span><br><span class="line">        <span class="comment">// 得到缓存之后发起一个后台请求去拿最新的数据</span></span><br><span class="line">        <span class="keyword">var</span> fetchPromise = <span class="title function_">fetch</span>(event.<span class="property">request</span>).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">networkResponse</span>) &#123;</span><br><span class="line">          cache.<span class="title function_">put</span>(event.<span class="property">request</span>, networkResponse.<span class="title function_">clone</span>());</span><br><span class="line">          <span class="keyword">return</span> networkResponse;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> response || fetchPromise;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;详解&quot;&gt;&lt;a href=&quot;#详解&quot; class=&quot;headerlink&quot; title=&quot;详解&quot;&gt;&lt;/a&gt;详解&lt;/h1&gt;&lt;p&gt;PWA中处理请求有很多种模式，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Cache falling back to network&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="html5" scheme="http://tomwang1013.github.io/tags/html5/"/>
    
    <category term="pwa" scheme="http://tomwang1013.github.io/tags/pwa/"/>
    
  </entry>
  
  <entry>
    <title>vue patch算法解读之二：自定义组件的实例化及首次渲染</title>
    <link href="http://tomwang1013.github.io/vue-patch-2/"/>
    <id>http://tomwang1013.github.io/vue-patch-2/</id>
    <published>2018-11-12T01:08:46.000Z</published>
    <updated>2023-07-18T03:20:12.568Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://jinge.red/vue-patch-1/">上一篇</a>中我们介绍了根组件root的初始化渲染过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>当时我们提到，root的_vnode的<code>componentInstance</code>中存储了App组件的实例(后面称为app)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> child = vnode.<span class="property">componentInstance</span> = <span class="title function_">createComponentInstanceForVnode</span>(</span><br><span class="line">  vnode,</span><br><span class="line">  activeInstance</span><br><span class="line">)</span><br><span class="line">child.$mount(hydrating ? vnode.<span class="property">elm</span> : <span class="literal">undefined</span>, hydrating)</span><br></pre></td></tr></table></figure><p>在app这个实例mount之后，我们把app.$el插入到页面上整个root就渲染出来了，其中的数据结构如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1541987629081.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>本篇中我们详细看看<code>app</code>的创建及首次渲染过程，我们从createComponentInstanceForVnode开始，在本例中，我们传给你它的2个参数依次为<code>root._vnode</code>和<code>root</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createComponentInstanceForVnode</span> (</span><br><span class="line">  <span class="attr">vnode</span>: any, <span class="comment">// we know it&#x27;s MountedComponentVNode but flow doesn&#x27;t</span></span><br><span class="line">  <span class="attr">parent</span>: any, <span class="comment">// activeInstance in lifecycle state</span></span><br><span class="line">): <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">options</span>: <span class="title class_">InternalComponentOptions</span> = &#123;</span><br><span class="line">    <span class="attr">_isComponent</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">_parentVnode</span>: vnode,</span><br><span class="line">    parent</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> vnode.<span class="property">componentOptions</span>.<span class="title class_">Ctor</span>(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>App的构造函数是<code>Vue.extend</code>中定义的，最终会调用<code>Vue.prototype._init</code>进行初始化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/init.js</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">  vm.<span class="property">_uid</span> = uid++</span><br><span class="line">  vm.<span class="property">_isVue</span> = <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// merge options</span></span><br><span class="line">  <span class="keyword">if</span> (options &amp;&amp; options.<span class="property">_isComponent</span>) &#123;</span><br><span class="line">    <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">    <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">    <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">    <span class="title function_">initInternalComponent</span>(vm, options)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vm.<span class="property">$options</span> = <span class="title function_">mergeOptions</span>(</span><br><span class="line">      <span class="title function_">resolveConstructorOptions</span>(vm.<span class="property">constructor</span>),</span><br><span class="line">      options || &#123;&#125;,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  vm.<span class="property">_renderProxy</span> = vm</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// expose real self</span></span><br><span class="line">  vm.<span class="property">_self</span> = vm</span><br><span class="line">  <span class="title function_">initLifecycle</span>(vm)</span><br><span class="line">  <span class="title function_">initEvents</span>(vm)</span><br><span class="line">  <span class="title function_">initRender</span>(vm)</span><br><span class="line">  <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">  <span class="title function_">initInjections</span>(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">  <span class="title function_">initState</span>(vm)</span><br><span class="line">  <span class="title function_">initProvide</span>(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">  <span class="title function_">callHook</span>(vm, <span class="string">&#x27;created&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$options</span>.<span class="property">el</span>) &#123;</span><br><span class="line">    vm.$mount(vm.<span class="property">$options</span>.<span class="property">el</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个初始化方法主要有三个步骤：</p><ol><li><p>得到vm的最终的$options</p><p>主要是把参数中的options和构造函数的options合并起来作为最终的<code>$options</code>，这里我们options._isComponent是true，所以走的是initInternalComponent，这个细节不讨论，有兴趣大家可以看看参考文档(<a href="http://hcysun.me/vue-design/art/">http://hcysun.me/vue-design/art/</a>)</p></li><li><p>做各种初始化</p><p>有兴趣参考(<a href="http://hcysun.me/vue-design/art/)%EF%BC%8C%E8%BF%99%E9%87%8C%E6%88%91%E4%BB%AC%E5%8F%AA%E5%88%97%E5%87%BA%E4%B8%80%E7%82%B9%EF%BC%9A%E5%9C%A8initLifecycle%E4%B8%AD%E6%88%91%E4%BB%AC%E8%AE%BE%E7%BD%AE%E4%BA%86%60vm.$parent%60%E5%8F%8A%60vm.$root%60">http://hcysun.me/vue-design/art/)，这里我们只列出一点：在initLifecycle中我们设置了`vm.$parent`及`vm.$root`</a>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/lifecycle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">initLifecycle</span> (<span class="attr">vm</span>: <span class="title class_">Component</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> options = vm.<span class="property">$options</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> parent = options.<span class="property">parent</span></span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; !options.<span class="property">abstract</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    parent.<span class="property">$children</span>.<span class="title function_">push</span>(vm)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vm.<span class="property">$parent</span> = parent</span><br><span class="line">  vm.<span class="property">$root</span> = parent ? parent.<span class="property">$root</span> : vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里的options里面是传了parent选项的，这里的值是root</p></li><li><p>mount</p><p>这里if条件不成立，所以没有mount，mount发生在实例被创建之后</p></li></ol><p>app创建之后，我们马上进行了mount：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child.$mount(hydrating ? vnode.<span class="property">elm</span> : <span class="literal">undefined</span>, hydrating)</span><br></pre></td></tr></table></figure><p>第一个参数是<code>undefined</code>，第二个参数是false。我们知道，mount会重新走<code>_render</code>及<code>_update</code>的过程，我们先看看_render，简化如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/render.js  </span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_render</span> = <span class="keyword">function</span> (<span class="params"></span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.<span class="property">$options</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*if (_parentVnode) &#123;</span></span><br><span class="line"><span class="comment">    vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject</span></span><br><span class="line"><span class="comment">  &#125;*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set parent vnode. this allows render functions to have access</span></span><br><span class="line">  <span class="comment">// to the data on the placeholder node.</span></span><br><span class="line">  vm.<span class="property">$vnode</span> = _parentVnode</span><br><span class="line">  <span class="comment">// render self</span></span><br><span class="line">  <span class="keyword">let</span> vnode</span><br><span class="line">  vnode = render.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set parent</span></span><br><span class="line">  vnode.<span class="property">parent</span> = _parentVnode</span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在render之前我们设置了实例的<code>$vnode</code>属性，render之后又设置了vnode.parent属性，<code>_render</code>函数返回的vnode传入<code>_update</code>，我们看看update：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/lifecycle.js</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_update</span> = <span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">const</span> prevEl = vm.<span class="property">$el</span></span><br><span class="line">  <span class="keyword">const</span> prevVnode = vm.<span class="property">_vnode</span></span><br><span class="line">  <span class="keyword">const</span> prevActiveInstance = activeInstance</span><br><span class="line">  activeInstance = vm</span><br><span class="line">  vm.<span class="property">_vnode</span> = vnode</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">  <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">    <span class="comment">// initial render</span></span><br><span class="line">    vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(vm.<span class="property">$el</span>, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// updates</span></span><br><span class="line">  &#125;</span><br><span class="line">  activeInstance = prevActiveInstance</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">  <span class="keyword">if</span> (vm.<span class="property">$vnode</span> &amp;&amp; vm.<span class="property">$parent</span> &amp;&amp; vm.<span class="property">$vnode</span> === vm.<span class="property">$parent</span>.<span class="property">_vnode</span>) &#123;</span><br><span class="line">    vm.<span class="property">$parent</span>.<span class="property">$el</span> = vm.<span class="property">$el</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">  <span class="comment">// updated in a parent&#x27;s updated hook.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>prevEl</code>和<code>prevVnode</code>分别保存之前的根元素(<code>$el</code>)和<code>_vnode</code>，在首次渲染之前，它们都是空的。然后设置新的<code>_vnode</code>，并在patch之后设置新的<code>$el</code>，并且在patch之前修改全局变量<code>activeInstance</code>，设置为自己，这里即app实例，patch完之后再还原成root。最后是一个if语句，在本例中是满足的，所以把root的根元素置为和app的一样，所以经过<code>_render</code>和<code>_update</code>时候数据结构变成：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1542000170374.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>理解了大概的数据结构之后，我们再详细看看app的render和update过程</p><h1 id="render"><a href="#render" class="headerlink" title="render"></a>render</h1><p>App组件的html模板为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&quot;Vue logo&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./assets/logo.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello, world!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它生产的render函数如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack:///./src/App.vue?5b21</span></span><br><span class="line"><span class="keyword">var</span> render = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> _vm = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">var</span> _h = _vm.<span class="property">$createElement</span></span><br><span class="line">  <span class="keyword">var</span> _c = _vm.<span class="property">_self</span>.<span class="property">_c</span> || _h</span><br><span class="line">  <span class="keyword">return</span> _vm.<span class="title function_">_m</span>(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> staticRenderFns = [</span><br><span class="line">  <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> _vm = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">var</span> _h = _vm.<span class="property">$createElement</span></span><br><span class="line">    <span class="keyword">var</span> _c = _vm.<span class="property">_self</span>.<span class="property">_c</span> || _h</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">_c</span>(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">id</span>: <span class="string">&quot;app&quot;</span> &#125; &#125;, [</span><br><span class="line">      <span class="title function_">_c</span>(<span class="string">&quot;img&quot;</span>, &#123;</span><br><span class="line">        <span class="attr">attrs</span>: &#123; <span class="attr">alt</span>: <span class="string">&quot;Vue logo&quot;</span>, <span class="attr">src</span>: <span class="built_in">require</span>(<span class="string">&quot;./assets/logo.png&quot;</span>) &#125;</span><br><span class="line">      &#125;),</span><br><span class="line">      <span class="title function_">_c</span>(<span class="string">&quot;div&quot;</span>, [_vm.<span class="title function_">_v</span>(<span class="string">&quot;hello, world!&quot;</span>)])</span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">render.<span class="property">_withStripped</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; render, staticRenderFns &#125;</span><br></pre></td></tr></table></figure><p>我们在<code>_render</code>中是这么调用的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnode = render.<span class="title function_">call</span>(vm.<span class="property">_renderProxy</span>, vm.<span class="property">$createElement</span>)</span><br></pre></td></tr></table></figure><p><code>vm._renderProxy</code>在生产环境下就是vm，<code>_vm._m</code>其实就是<code>staticRenderFns</code>，<code>_c</code>定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="property">_c</span> = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> <span class="title function_">createElement</span>(vm, a, b, c, d, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>最终执行的是下面这段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="title function_">_c</span>(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">id</span>: <span class="string">&quot;app&quot;</span> &#125; &#125;, [</span><br><span class="line">  <span class="title function_">_c</span>(<span class="string">&quot;img&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">attrs</span>: &#123; <span class="attr">alt</span>: <span class="string">&quot;Vue logo&quot;</span>, <span class="attr">src</span>: <span class="built_in">require</span>(<span class="string">&quot;./assets/logo.png&quot;</span>) &#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="title function_">_c</span>(<span class="string">&quot;div&quot;</span>, [_vm.<span class="title function_">_v</span>(<span class="string">&quot;hello, world!&quot;</span>)])</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>最终执行的是<code>_createElement</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/create-element.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">_createElement</span> (</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span>,</span><br><span class="line">  tag?: string | <span class="title class_">Class</span>&lt;<span class="title class_">Component</span>&gt; | <span class="title class_">Function</span> | <span class="title class_">Object</span>,</span><br><span class="line">  data?: <span class="title class_">VNodeData</span>,</span><br><span class="line">  children?: any,</span><br><span class="line">  normalizationType?: number</span><br><span class="line">): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对顶层的div来说，传递给这个函数的参数为：</p><ul><li><p>context：当前实例，即app</p></li><li><p>tag：”div”</p></li><li><p>data：<code>&#123; attrs: &#123; id: &quot;app&quot; &#125; &#125;</code></p></li><li><p>children:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="title function_">_c</span>(<span class="string">&quot;img&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">attrs</span>: &#123; <span class="attr">alt</span>: <span class="string">&quot;Vue logo&quot;</span>, <span class="attr">src</span>: <span class="built_in">require</span>(<span class="string">&quot;./assets/logo.png&quot;</span>) &#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="title function_">_c</span>(<span class="string">&quot;div&quot;</span>, [_vm.<span class="title function_">_v</span>(<span class="string">&quot;hello, world!&quot;</span>)])</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>其实就是包含2个vnode元素的数组</p></li><li><p>normalizationType：undefined</p></li></ul><p>根据这些参数，这个函数的执行路径为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/create-element.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">_createElement</span> (</span><br><span class="line">  ...</span><br><span class="line">): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> vnode, ns</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (config.<span class="title function_">isReservedTag</span>(tag)) &#123;</span><br><span class="line">      <span class="comment">// platform built-in elements</span></span><br><span class="line">      vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">        config.<span class="title function_">parsePlatformTagName</span>(tag), data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接是以内置div标签new一个vnode出来</p><h1 id="update"><a href="#update" class="headerlink" title="update"></a>update</h1><p>得到这个vnode之后，我们调用patch：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="title function_">__patch__</span>(vm.<span class="property">$el</span>, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br></pre></td></tr></table></figure><p>这是<code>vm.$el</code>是undefined，因为这是首次渲染，我看把视角转向patch函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/patch.js</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">patch</span> (oldVnode, vnode, hydrating, removeOnly) &#123;</span><br><span class="line">  <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldVnode)) &#123;</span><br><span class="line">    <span class="comment">// empty mount (likely as component), create new root element</span></span><br><span class="line">    isInitialPatch = <span class="literal">true</span></span><br><span class="line">    <span class="title function_">createElm</span>(vnode, insertedVnodeQueue)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vnode.<span class="property">elm</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次很简单，因为<code>oldVnode</code>是空的，所以直接调用<code>createElm</code>基本就结束了，这次只传了2个参数，我们看看这个函数这次的执行路径：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/patch.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createElm</span> (</span><br><span class="line">  vnode,</span><br><span class="line">  insertedVnodeQueue,</span><br><span class="line">  parentElm,</span><br><span class="line">  refElm,</span><br><span class="line">  nested,</span><br><span class="line">  ownerArray,</span><br><span class="line">  index</span><br><span class="line">) &#123;</span><br><span class="line">  vnode.<span class="property">isRootInsert</span> = !nested <span class="comment">// for transition enter check</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">createComponent</span>(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> data = vnode.<span class="property">data</span></span><br><span class="line">  <span class="keyword">const</span> children = vnode.<span class="property">children</span></span><br><span class="line">  <span class="keyword">const</span> tag = vnode.<span class="property">tag</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(tag)) &#123;</span><br><span class="line">    vnode.<span class="property">elm</span> = nodeOps.<span class="title function_">createElement</span>(tag, vnode)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (__WEEX__) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">createChildren</span>(vnode, children, insertedVnodeQueue)</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isDef</span>(data)) &#123;</span><br><span class="line">        <span class="title function_">invokeCreateHooks</span>(vnode, insertedVnodeQueue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isTrue</span>(vnode.<span class="property">isComment</span>)) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次createComponent是不会返回true的，且调用之后没有任何效果，因为这里的vnode只是一个div的包装而已。代码直接进入第一个if执行下面这行代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnode.<span class="property">elm</span> = nodeOps.<span class="title function_">createElement</span>(tag, vnode)</span><br></pre></td></tr></table></figure><p>它直接创建一个div元素！因为children还有2个vnode，所以再调用<code>createChildren</code>创建子元素，这样app的整个dom就创建好了，然后patch直接返回根元素。最后回到<code>_update</code>把这个元素赋给<code>vm.$el</code>，整个数据结构变成：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1542003332390.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>在上一篇我们知道，这个根元素最终会被root插入到文档中从而展示在页面上。至此，下面这两三行简单的代码基本分析完了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>可以看到，这后面其实牵涉到很多逻辑，何况我们还省略了很多细节，但是更复杂的情况也能从这里推导出来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;http://jinge.red/vue-patch-1/&quot;&gt;上一篇&lt;/a&gt;中我们介绍了根组件root的初始化渲染过程：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gut</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="vue" scheme="http://tomwang1013.github.io/tags/vue/"/>
    
    <category term="read-source-code" scheme="http://tomwang1013.github.io/tags/read-source-code/"/>
    
  </entry>
  
  <entry>
    <title>vue patch算法解读之一：根组件的初始化</title>
    <link href="http://tomwang1013.github.io/vue-patch-1/"/>
    <id>http://tomwang1013.github.io/vue-patch-1/</id>
    <published>2018-11-10T15:52:03.000Z</published>
    <updated>2023-07-18T03:20:12.568Z</updated>
    
    <content type="html"><![CDATA[<p>vue的渲染过程是由vnode驱动的，当数据发生变化时，根据前后vnode的差异使用patch算法只重新渲染变化的部分。这里说的渲染其实就是重新调整组件的DOM结构：复用、移动、删除dom节点使得真实dom和vdom保持一致。这个过程其实是很复杂的，这里我尝试一边读源码调试，一边记录对这个过程的理解，在完全理解之前，这里记录的都是一些片段，希望最后能将这些片段串联起来组成一篇真正的有条理的解读</p><h1 id="根组件的初始化"><a href="#根组件的初始化" class="headerlink" title="根组件的初始化"></a>根组件的初始化</h1><p>我们以一个简单的例子开始：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// app.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;</span><br><span class="line">    &lt;div&gt;hello, world!&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;app&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// index.html</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们把最顶层组件(new Vue出来的)称为root，程序的运行以root的渲染开始。vue实例的渲染分两步：第一步是render，得到代表它的结构的vnode；第二部根据vnode，渲染出真实的dom。整个渲染过程为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/lifecycle.js</span></span><br><span class="line">updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  vm.<span class="title function_">_update</span>(vm.<span class="title function_">_render</span>(), hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="render"><a href="#render" class="headerlink" title="_render"></a>_render</h2><p><code>_render</code>会调用vm的<code>render</code>函数，root的render函数很简单：<code>h =&gt; h(App)</code>。这里的h其实就是实例方法<code>vm.$createElement</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/instance/render.js</span></span><br><span class="line"><span class="comment">// normalization is always applied for the public version, used in</span></span><br><span class="line"><span class="comment">// user-written render functions.</span></span><br><span class="line">vm.<span class="property">$createElement</span> = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> <span class="title function_">createElement</span>(vm, a, b, c, d, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>App就是import <code>App.vue</code>得到的一个表示组件的对象</p><p><code>createElement</code>这个函数返回一个vnode：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/create-element.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createElement</span> (</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span>,</span><br><span class="line">  <span class="attr">tag</span>: any,</span><br><span class="line">  <span class="attr">data</span>: any,</span><br><span class="line">  <span class="attr">children</span>: any,</span><br><span class="line">  <span class="attr">normalizationType</span>: any,</span><br><span class="line">  <span class="attr">alwaysNormalize</span>: boolean</span><br><span class="line">): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">_createElement</span>(context, tag, data, children, normalizationType)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是简单包装了一下，最终调用的是<code>_createElement</code>，这个函数很复杂，我们截出骨干部分：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/create-element.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">_createElement</span> (</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span>,</span><br><span class="line">  tag?: string | <span class="title class_">Class</span>&lt;<span class="title class_">Component</span>&gt; | <span class="title class_">Function</span> | <span class="title class_">Object</span>,</span><br><span class="line">  data?: <span class="title class_">VNodeData</span>,</span><br><span class="line">  children?: any,</span><br><span class="line">  normalizationType?: number</span><br><span class="line">): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">let</span> vnode, ns</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">Ctor</span></span><br><span class="line">    ns = (context.<span class="property">$vnode</span> &amp;&amp; context.<span class="property">$vnode</span>.<span class="property">ns</span>) || config.<span class="title function_">getTagNamespace</span>(tag)</span><br><span class="line">    <span class="keyword">if</span> (config.<span class="title function_">isReservedTag</span>(tag)) &#123;</span><br><span class="line">      <span class="comment">// platform built-in elements</span></span><br><span class="line">      vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">        config.<span class="title function_">parsePlatformTagName</span>(tag), data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!data || !data.<span class="property">pre</span>) &amp;&amp; <span class="title function_">isDef</span>(<span class="title class_">Ctor</span> = <span class="title function_">resolveAsset</span>(context.<span class="property">$options</span>, <span class="string">&#x27;components&#x27;</span>, tag))) &#123;</span><br><span class="line">      <span class="comment">// component</span></span><br><span class="line">      vnode = <span class="title function_">createComponent</span>(<span class="title class_">Ctor</span>, data, context, children, tag)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// direct component options / constructor</span></span><br><span class="line">    vnode = <span class="title function_">createComponent</span>(tag, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> vnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看这个函数的参数：</p><ul><li>context：表示当前的vue实例，因为所有的方法最开始都是由某个vue实例调用方法引起的，就这里来说是调用<code>$createElement</code>引起的</li><li>tag：表示这个vnode的类型，它可以是以下几种类型：<ul><li>html内置的标签名，如”div”</li><li>vue组件名称，如<code>&lt;cmpName&gt;&lt;/cmpName&gt;</code>中的”cmpName”</li><li>代表vue组件的对象，如这里的App，是从app.vue import进来的</li><li>代表vue组件的构造函数，本质上和对象是一致的</li></ul></li><li>data：vnode的数据，如各种属性</li><li>children：子元素</li><li>normalizationType：暂时不管</li></ul><p>就我们这个例子来说，<code>App</code>是一个对象，所以走的是下面这句代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// direct component options / constructor</span></span><br><span class="line">vnode = <span class="title function_">createComponent</span>(tag, data, context, children)</span><br></pre></td></tr></table></figure><p>由函数<code>createComponent</code>返回vnode，这个函数也比较复杂，我们看看关键部分：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/create-component.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createComponent</span> (</span><br><span class="line">  <span class="title class_">Ctor</span>: <span class="title class_">Class</span>&lt;<span class="title class_">Component</span>&gt; | <span class="title class_">Function</span> | <span class="title class_">Object</span> | <span class="keyword">void</span>,</span><br><span class="line">  <span class="attr">data</span>: ?<span class="title class_">VNodeData</span>,</span><br><span class="line">  <span class="attr">context</span>: <span class="title class_">Component</span>,</span><br><span class="line">  <span class="attr">children</span>: ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;,</span><br><span class="line">  tag?: string</span><br><span class="line">): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; | <span class="keyword">void</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> baseCtor = context.<span class="property">$options</span>.<span class="property">_base</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// plain options object: turn it into a constructor</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isObject</span>(<span class="title class_">Ctor</span>)) &#123;</span><br><span class="line">    <span class="title class_">Ctor</span> = baseCtor.<span class="title function_">extend</span>(<span class="title class_">Ctor</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  data = data || &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// extract props</span></span><br><span class="line">  <span class="keyword">const</span> propsData = <span class="title function_">extractPropsFromVNodeData</span>(data, <span class="title class_">Ctor</span>, tag)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// install component management hooks onto the placeholder node</span></span><br><span class="line">  <span class="title function_">installComponentHooks</span>(data)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return a placeholder vnode</span></span><br><span class="line">  <span class="keyword">const</span> name = <span class="title class_">Ctor</span>.<span class="property">options</span>.<span class="property">name</span> || tag</span><br><span class="line">  <span class="keyword">const</span> vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">    <span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span><span class="subst">$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>,</span><br><span class="line">    data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">    &#123; <span class="title class_">Ctor</span>, propsData, listeners, tag, children &#125;,</span><br><span class="line">    asyncFactory</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数主要就是根据App这个组件来构造一个vnode出来，它首先做了一件最关键的事：创建组件的构造函数。我们知道，所有的组件实例最终都是通过某个构造函数new出来的：<code>new Ctor(options)</code>，这个Ctor可以是Vue这个顶层内置构造函数，也可以是从Vue继承下来的组件构造函数。</p><p>这里的<code>baseCtor</code>就是<code>Vue</code>，<code>Ctor</code>就是<code>App</code>这个对象，我们通过<code>Vue.extend</code>函数将App对象转化为构造函数：<code>Ctor = baseCtor.extend(Ctor)</code>，extend函数构建原型链并返回创建的构造函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/global-api/extend.js</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">extend</span> = <span class="keyword">function</span> (<span class="params">extendOptions: <span class="built_in">Object</span></span>): <span class="title class_">Function</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Super</span> = <span class="variable language_">this</span></span><br><span class="line">  extendOptions = extendOptions || &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Sub</span> = <span class="keyword">function</span> <span class="title function_">VueComponent</span> (options) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_init</span>(options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Super</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">  <span class="title class_">Sub</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Sub</span></span><br><span class="line">  <span class="title class_">Sub</span>.<span class="property">cid</span> = cid++</span><br><span class="line">  <span class="title class_">Sub</span>.<span class="property">options</span> = <span class="title function_">mergeOptions</span>(</span><br><span class="line">    <span class="title class_">Super</span>.<span class="property">options</span>,</span><br><span class="line">    extendOptions</span><br><span class="line">  )</span><br><span class="line">  <span class="title class_">Sub</span>[<span class="string">&#x27;super&#x27;</span>] = <span class="title class_">Super</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Sub</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里特别要注意的是构造函数的<code>options</code>属性，它是由自己的属性和父类的属性合并而成的。在通过构造函数new一个vue实例的时候，我们还会传另一个options对象进来，这个对象和构造函数本身的options一起构成vue实例最终的<code>$options</code>属性值。</p><p>我们继续回到createComponent函数，得到构造函数之后我们提取<code>propsData</code>，即传给组件的props的数据；然后调用<code>installComponentHooks</code>在data上面增加一个hook属性，属性里面包含四个函数，它们将会在patch过程中分别在不同的时机被调用到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data.<span class="property">hook</span> = &#123;</span><br><span class="line">  <span class="title function_">init</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">prepatch</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">insert</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">  <span class="title function_">destroy</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们后面会讲到其中的init，其他的先不管。最后就是vnode的创建了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vnode = <span class="keyword">new</span> <span class="title class_">VNode</span>(</span><br><span class="line">  <span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span><span class="subst">$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>,</span><br><span class="line">  data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">  &#123; <span class="title class_">Ctor</span>, propsData, listeners, tag, children &#125;,</span><br><span class="line">  asyncFactory</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>大家可以对照下VNode的构造函数看看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span> (</span><br><span class="line">  tag?: string,</span><br><span class="line">  data?: <span class="title class_">VNodeData</span>,</span><br><span class="line">  children?: ?<span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt;,</span><br><span class="line">  text?: string,</span><br><span class="line">  elm?: <span class="title class_">Node</span>,</span><br><span class="line">  context?: <span class="title class_">Component</span>,</span><br><span class="line">  componentOptions?: <span class="title class_">VNodeComponentOptions</span>,</span><br><span class="line">  asyncFactory?: <span class="title class_">Function</span></span><br><span class="line">) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，构造函数保存在<code>componentOptions</code>中，并且tag值是类似vue-component-1-app这种字符串。</p><p>这样，root实例的vnode就得到了</p><h2 id="update"><a href="#update" class="headerlink" title="_update"></a>_update</h2><p><code>_render</code>返回vnode之后，<code>_update</code>将vnode转化为真正的DOM：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_update</span> = <span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: boolean</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="attr">vm</span>: <span class="title class_">Component</span> = <span class="variable language_">this</span></span><br><span class="line">   <span class="keyword">const</span> prevEl = vm.<span class="property">$el</span></span><br><span class="line">   <span class="keyword">const</span> prevVnode = vm.<span class="property">_vnode</span></span><br><span class="line">   <span class="keyword">const</span> prevActiveInstance = activeInstance</span><br><span class="line">   activeInstance = vm</span><br><span class="line">   vm.<span class="property">_vnode</span> = vnode</span><br><span class="line">   <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">     <span class="comment">// initial render</span></span><br><span class="line">     vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(vm.<span class="property">$el</span>, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// updates</span></span><br><span class="line">     vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(prevVnode, vnode)</span><br><span class="line">   &#125;</span><br><span class="line">   activeInstance = prevActiveInstance</span><br><span class="line">   ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>返回的vnode保存在<code>_vnode</code>中，然后看之前的_vnode是否存在，不存在的话表示第一次渲染，否则只是更新。无论如何都是调用<code>__path__</code>函数，<code>__path__</code>函数定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/platforms/web/runtime/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; patch &#125; <span class="keyword">from</span> <span class="string">&#x27;./patch&#x27;</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__patch__</span> = inBrowser ? patch : noop</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/platforms/web/runtime/patch.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> nodeOps <span class="keyword">from</span> <span class="string">&#x27;web/runtime/node-ops&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPatchFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;core/vdom/patch&#x27;</span></span><br><span class="line"><span class="keyword">import</span> baseModules <span class="keyword">from</span> <span class="string">&#x27;core/vdom/modules/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> platformModules <span class="keyword">from</span> <span class="string">&#x27;web/runtime/modules/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the directive module should be applied last, after all</span></span><br><span class="line"><span class="comment">// built-in modules have been applied.</span></span><br><span class="line"><span class="keyword">const</span> modules = platformModules.<span class="title function_">concat</span>(baseModules)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="attr">patch</span>: <span class="title class_">Function</span> = <span class="title function_">createPatchFunction</span>(&#123; nodeOps, modules &#125;)</span><br></pre></td></tr></table></figure><p>可以看到最终的patch函数是src&#x2F;core&#x2F;vdom&#x2F;patch.js中的<code>createPatchFunction</code>的返回值，整个这个文件就是来生成真正的DOM的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/patch.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createPatchFunction</span> (backend) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; modules, nodeOps &#125; = backend</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 定义了一大堆内部函数 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">patch</span> (oldVnode, vnode, hydrating, removeOnly) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们以这个例子看看首次渲染是如何进行的，首次渲染调用如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(vm.<span class="property">$el</span>, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br></pre></td></tr></table></figure><p>在渲染之前<code>vm.$el</code>的值是html中div#app元素(<code>$mount(&#39;#app&#39;)</code>)，<code>vnode</code>是当前_vnode，hydrating只有在SSR时才是true，其他情况都是false，以这些参数，我们看看patch函数是如何执行的，为简单起见，我们只保留这个例子要执行的代码路径：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/patch.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">patch</span> (oldVnode, vnode, hydrating, removeOnly) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="title function_">isUndef</span>(vnode)) &#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">   <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldVnode)) &#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> isRealElement = <span class="title function_">isDef</span>(oldVnode.<span class="property">nodeType</span>)</span><br><span class="line">     <span class="keyword">if</span> (!isRealElement &amp;&amp; <span class="title function_">sameVnode</span>(oldVnode, vnode)) &#123;</span><br><span class="line">       ...</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">         <span class="comment">// mounting to a real element</span></span><br><span class="line">         oldVnode = <span class="title function_">emptyNodeAt</span>(oldVnode)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// replacing existing element</span></span><br><span class="line">       <span class="keyword">const</span> oldElm = oldVnode.<span class="property">elm</span></span><br><span class="line">       <span class="keyword">const</span> parentElm = nodeOps.<span class="title function_">parentNode</span>(oldElm)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// create new node</span></span><br><span class="line">       <span class="title function_">createElm</span>(</span><br><span class="line">         vnode,</span><br><span class="line">         insertedVnodeQueue,</span><br><span class="line">         <span class="comment">// extremely rare edge case: do not insert if old element is in a</span></span><br><span class="line">         <span class="comment">// leaving transition. Only happens when combining transition +</span></span><br><span class="line">         <span class="comment">// keep-alive + HOCs. (#4590)</span></span><br><span class="line">         oldElm.<span class="property">_leaveCb</span> ? <span class="literal">null</span> : parentElm,</span><br><span class="line">         nodeOps.<span class="title function_">nextSibling</span>(oldElm)</span><br><span class="line">       )</span><br><span class="line">      </span><br><span class="line">       <span class="comment">// destroy old node</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="title function_">isDef</span>(parentElm)) &#123;</span><br><span class="line">         <span class="title function_">removeVnodes</span>(parentElm, [oldVnode], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode.<span class="property">tag</span>)) &#123;</span><br><span class="line">         ...</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">return</span> vnode.<span class="property">elm</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>因为这里的oldVnode是一个dom元素，<code>isRealElement</code>为true，所以会调用<code>createElm</code>来创建vnode对应的根元素并保存在vnode的<code>elm</code>属性中，整个patch函数返回的也是这个根元素。我们来看看createElm的实现，和之前一样，只列出关键代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createElm</span> (</span><br><span class="line">   vnode,</span><br><span class="line">   insertedVnodeQueue,</span><br><span class="line">   parentElm,</span><br><span class="line">   refElm,</span><br><span class="line">   nested,</span><br><span class="line">   ownerArray,</span><br><span class="line">   index</span><br><span class="line"> ) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="title function_">createComponent</span>(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</span><br><span class="line">     <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> data = vnode.<span class="property">data</span></span><br><span class="line">   <span class="keyword">const</span> children = vnode.<span class="property">children</span></span><br><span class="line">   <span class="keyword">const</span> tag = vnode.<span class="property">tag</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="title function_">isDef</span>(tag)) &#123;</span><br><span class="line">     vnode.<span class="property">elm</span> = vnode.<span class="property">ns</span></span><br><span class="line">       ? nodeOps.<span class="title function_">createElementNS</span>(vnode.<span class="property">ns</span>, tag)</span><br><span class="line">       : nodeOps.<span class="title function_">createElement</span>(tag, vnode)</span><br><span class="line">     <span class="title function_">setScope</span>(vnode)</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">     <span class="keyword">if</span> (__WEEX__) &#123;</span><br><span class="line">       ...</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="title function_">createChildren</span>(vnode, children, insertedVnodeQueue)</span><br><span class="line">       <span class="keyword">if</span> (<span class="title function_">isDef</span>(data)) &#123;</span><br><span class="line">         <span class="title function_">invokeCreateHooks</span>(vnode, insertedVnodeQueue)</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="title function_">insert</span>(parentElm, vnode.<span class="property">elm</span>, refElm)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isTrue</span>(vnode.<span class="property">isComment</span>)) &#123;</span><br><span class="line">     vnode.<span class="property">elm</span> = nodeOps.<span class="title function_">createComment</span>(vnode.<span class="property">text</span>)</span><br><span class="line">     <span class="title function_">insert</span>(parentElm, vnode.<span class="property">elm</span>, refElm)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     vnode.<span class="property">elm</span> = nodeOps.<span class="title function_">createTextNode</span>(vnode.<span class="property">text</span>)</span><br><span class="line">     <span class="title function_">insert</span>(parentElm, vnode.<span class="property">elm</span>, refElm)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这个函数接受七个参数，我们先只关注第一、三、四个，vnode不用说；parentElm和refElm表示将要创建的根节点的父元素和后面的兄弟元素，我们需要将根节点插入到指定位置。函数开头先用前四个参数调用<code>createComponent</code>，并且如果返回值为true的话直接结束，后面那一大段代码都不用执行了，就我们的例子来说，返回值确实是true。实际上在<code>vm.$createElement</code>中所有由<code>createComponent</code>(不是这里的createComponent)创建的vnode调用这里的createComponent都会返回true：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/create-element.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">_createElement</span> (</span><br><span class="line">  ...</span><br><span class="line">): <span class="title class_">VNode</span> | <span class="title class_">Array</span>&lt;<span class="title class_">VNode</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (config.<span class="title function_">isReservedTag</span>(tag)) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;</span><br><span class="line">      <span class="comment">// component</span></span><br><span class="line">      vnode = <span class="title function_">createComponent</span>(<span class="title class_">Ctor</span>, data, context, children, tag)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// direct component options / constructor</span></span><br><span class="line">    vnode = <span class="title function_">createComponent</span>(tag, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看patch中的createComponent：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/patch.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createComponent</span> (vnode, insertedVnodeQueue, parentElm, refElm) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = vnode.<span class="property">data</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(i)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(i = i.<span class="property">hook</span>) &amp;&amp; <span class="title function_">isDef</span>(i = i.<span class="property">init</span>)) &#123;</span><br><span class="line">      <span class="title function_">i</span>(vnode, <span class="literal">false</span> <span class="comment">/* hydrating */</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// after calling the init hook, if the vnode is a child component</span></span><br><span class="line">    <span class="comment">// it should&#x27;ve created a child instance and mounted it. the child</span></span><br><span class="line">    <span class="comment">// component also has set the placeholder vnode&#x27;s elm.</span></span><br><span class="line">    <span class="comment">// in that case we can just return the element and be done.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(vnode.<span class="property">componentInstance</span>)) &#123;</span><br><span class="line">      <span class="title function_">initComponent</span>(vnode, insertedVnodeQueue)</span><br><span class="line">      <span class="title function_">insert</span>(parentElm, vnode.<span class="property">elm</span>, refElm)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里判断vnode中的data属性是否存在，然后在判断data中的hook及hook中的init函数是否存在，根据我们之前的分析，这些都是存在的，所以会调用<code>vnode.data.hook.init</code>函数，这个函数定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/create-component.js</span></span><br><span class="line">init (<span class="attr">vnode</span>: <span class="title class_">VNodeWithData</span>, <span class="attr">hydrating</span>: boolean): ?boolean &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    vnode.<span class="property">componentInstance</span> &amp;&amp;</span><br><span class="line">    !vnode.<span class="property">componentInstance</span>.<span class="property">_isDestroyed</span> &amp;&amp;</span><br><span class="line">    vnode.<span class="property">data</span>.<span class="property">keepAlive</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> child = vnode.<span class="property">componentInstance</span> = <span class="title function_">createComponentInstanceForVnode</span>(</span><br><span class="line">      vnode,</span><br><span class="line">      activeInstance</span><br><span class="line">    )</span><br><span class="line">    child.$mount(hydrating ? vnode.<span class="property">elm</span> : <span class="literal">undefined</span>, hydrating)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>if不满足，进入else，这里就是App这个组件实例化的地方。我们知道，这里的vnode保存了App的构造函数，我们通过<code>createComponentInstanceForVnode</code>创建一个App实例，并将它保存在componentInstance属性中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/create-component.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">createComponentInstanceForVnode</span> (</span><br><span class="line">  <span class="attr">vnode</span>: any, <span class="comment">// we know it&#x27;s MountedComponentVNode but flow doesn&#x27;t</span></span><br><span class="line">  <span class="attr">parent</span>: any, <span class="comment">// activeInstance in lifecycle state</span></span><br><span class="line">): <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">options</span>: <span class="title class_">InternalComponentOptions</span> = &#123;</span><br><span class="line">    <span class="attr">_isComponent</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">_parentVnode</span>: vnode,</span><br><span class="line">    parent</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> vnode.<span class="property">componentOptions</span>.<span class="title class_">Ctor</span>(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>App的构造函数我们之前讲过了，这里我们给构造函数再传了一个options，注意options中包含的值，这些值最终都会被合并到被创建的vm实例的<code>$options</code>属性中。</p><p>创建完App的实例后再调用$mount将这个实例渲染出来，<strong>这又会重新走一次<code>_render</code>和<code>_update</code>的过程</strong>，只不过当前实例变成了刚创建的App组件实例，而不是我们现在正在分析的根组件实例。这个重新的过程我们暂时按下不表，我们先假设它们已经走完了，这样我们从hook.init返回了重新来到了这里：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/patch.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createComponent</span> (vnode, insertedVnodeQueue, parentElm, refElm) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = vnode.<span class="property">data</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(i)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(i = i.<span class="property">hook</span>) &amp;&amp; <span class="title function_">isDef</span>(i = i.<span class="property">init</span>)) &#123;</span><br><span class="line">      <span class="title function_">i</span>(vnode, <span class="literal">false</span> <span class="comment">/* hydrating */</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回了，vnode.componentInstance已经保存了App实例</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// after calling the init hook, if the vnode is a child component</span></span><br><span class="line">    <span class="comment">// it should&#x27;ve created a child instance and mounted it. the child</span></span><br><span class="line">    <span class="comment">// component also has set the placeholder vnode&#x27;s elm.</span></span><br><span class="line">    <span class="comment">// in that case we can just return the element and be done.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(vnode.<span class="property">componentInstance</span>)) &#123;</span><br><span class="line">      <span class="title function_">initComponent</span>(vnode, insertedVnodeQueue)</span><br><span class="line">      <span class="title function_">insert</span>(parentElm, vnode.<span class="property">elm</span>, refElm)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再往下的if为真，我们先执行<code>initComponent</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/patch.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">initComponent</span> (vnode, insertedVnodeQueue) &#123;</span><br><span class="line">  ...</span><br><span class="line">  vnode.<span class="property">elm</span> = vnode.<span class="property">componentInstance</span>.<span class="property">$el</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关键的代码就上面一句，App实例(vnode.componentInstance)mount之后，实例中的<code>$el</code>就是它的根元素，我们把它赋给<code>vnode.elm</code>。</p><p>接下来就是insert操作，这才是真正的dom操作，把这个渲染好的根元素插入到指定位置：<code>insert(parentElm, vnode.elm, refElm)</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/patch.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">insert</span> (parent, elm, ref) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isDef</span>(parent)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isDef</span>(ref)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nodeOps.<span class="title function_">parentNode</span>(ref) === parent) &#123;</span><br><span class="line">        nodeOps.<span class="title function_">insertBefore</span>(parent, elm, ref)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nodeOps.<span class="title function_">appendChild</span>(parent, elm)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，根组件就展示在页面上面了：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1541864549578.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>由于createComponent返回true，createElm直接返回，这样patch继续：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/core/vdom/patch.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">patch</span> (oldVnode, vnode, hydrating, removeOnly) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="title function_">isUndef</span>(oldVnode)) &#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (!isRealElement &amp;&amp; <span class="title function_">sameVnode</span>(oldVnode, vnode)) &#123;</span><br><span class="line">       ...</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// create new node</span></span><br><span class="line">       <span class="title function_">createElm</span>(</span><br><span class="line">         vnode,</span><br><span class="line">         insertedVnodeQueue,</span><br><span class="line">         <span class="comment">// extremely rare edge case: do not insert if old element is in a</span></span><br><span class="line">         <span class="comment">// leaving transition. Only happens when combining transition +</span></span><br><span class="line">         <span class="comment">// keep-alive + HOCs. (#4590)</span></span><br><span class="line">         oldElm.<span class="property">_leaveCb</span> ? <span class="literal">null</span> : parentElm,</span><br><span class="line">         nodeOps.<span class="title function_">nextSibling</span>(oldElm)</span><br><span class="line">       )</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 继续</span></span><br><span class="line">      </span><br><span class="line">       <span class="comment">// destroy old node</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="title function_">isDef</span>(parentElm)) &#123;</span><br><span class="line">         <span class="title function_">removeVnodes</span>(parentElm, [oldVnode], <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="title function_">isDef</span>(oldVnode.<span class="property">tag</span>)) &#123;</span><br><span class="line">         ...</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> vnode.<span class="property">elm</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们新创建了一个根元素(vnode.elm)，所以需要把以前的删掉：<code>removeVnodes(parentElm, [oldVnode], 0, 0)</code>。然后就返回新的根元素，重新回到<code>_update</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="property">$el</span> = vm.<span class="title function_">__patch__</span>(vm.<span class="property">$el</span>, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br></pre></td></tr></table></figure><p>至此，故事告一段落，下次继续讲解App实例是怎么mount的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;vue的渲染过程是由vnode驱动的，当数据发生变化时，根据前后vnode的差异使用patch算法只重新渲染变化的部分。这里说的渲染其实就是重新调整组件的DOM结构：复用、移动、删除dom节点使得真实dom和vdom保持一致。这个过程其实是很复杂的，这里我尝试一边读源码调试</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="vue" scheme="http://tomwang1013.github.io/tags/vue/"/>
    
    <category term="read-source-code" scheme="http://tomwang1013.github.io/tags/read-source-code/"/>
    
  </entry>
  
  <entry>
    <title>property descriptor的几个疑难点</title>
    <link href="http://tomwang1013.github.io/property-attribtes-tips/"/>
    <id>http://tomwang1013.github.io/property-attribtes-tips/</id>
    <published>2018-10-29T02:18:05.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<p><code>property descriptor</code>是javascript对象中属性的描述对象，包括了这个属性的meta信息，基本知识大家都知道，这里总结一些很隐晦的容易忽略的注意点</p><h1 id="writable-vs-configurable"><a href="#writable-vs-configurable" class="headerlink" title="writable vs configurable"></a>writable vs configurable</h1><ol><li><code>writable</code>控制<code>value</code>能否更改：<ul><li>如果writable &#x3D; true, value可以(通过赋值直接)修改，和configurable无关</li><li>如果writable &#x3D; false, value不可以(通过赋值直接)修改，但是如果此时configurable为true，则仍然可以通过<code>defineProperty</code>修改value的值</li></ul></li><li><code>configurable</code>控制能否修改descriptor的所有属性<strong>以及</strong>能否删除属性(delete o.foo)<ul><li>如果configurable为true，没啥说的，descriptor中什么都能改</li><li>如果configurable为false，按理说，descriptor中什么都不能改，但是有一个例外：<strong>writable</strong>能从true改成false</li></ul></li></ol><h1 id="defineProperty-vs-assignment"><a href="#defineProperty-vs-assignment" class="headerlink" title="defineProperty vs assignment"></a>defineProperty vs assignment</h1><p><code>defineProperty</code>和直接赋值(assignment)都能定义或修改属性，但是它们还是有很多不同点的：</p><ol><li><p>descriptor中的默认值不一样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(o, <span class="string">&#x27;foo&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &#123; value: 1, writable: false, enumerable: false, configurable: false&#125;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(o, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line">o.<span class="property">bar</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// &#123; value: 1, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(o, <span class="string">&#x27;bar&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>是否需要考虑原型链的情况不一样</p><ul><li><p>defineProperty和原型链完全无关：它只会定义一个新的属性或修改现有的own property</p></li><li><p>assignment情况有点复杂：</p><ul><li>如果这个属性存在setter(own or inherited)，直接调用setter</li><li>如果这个属性是只读的(own or inherited)，抛出异常或静静地失败</li><li>如果这个属性是own(可写)的，修改这个属性的值</li><li>如果这个属性不存在(own or inherited)，定义一个新的own属性</li><li>如果这个属性是inherited且是writable，也是一个新的own属性(覆盖掉inherited的属性)</li></ul><p>应该包含了所有情况吧！</p></li></ul></li></ol><h1 id="保护对象：preventExtensions-vs-seal-vs-freeze"><a href="#保护对象：preventExtensions-vs-seal-vs-freeze" class="headerlink" title="保护对象：preventExtensions vs seal vs freeze"></a>保护对象：preventExtensions vs seal vs freeze</h1><p>为了防止对象被修改，javascript也提供了三种方法，它们的不同点在于对对象的保护程度，按保护程度从小到大依次为：<code>preventExtensions</code> &lt; <code>seal</code> &lt; <code>freeze</code>，freeze的保护程度是最强的。我们在使用的时候按照自己的需求选择合适的方法，下面依次介绍一下：</p><ul><li><p>preventExtensions</p><p>防止往对象上添加新的属性(defineProperty or assignment)</p></li><li><p>seal</p><p>除了preventExtensions之外，还把所有属性置为”unconfigurable”</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// before sealing: &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(o, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">seal</span>(o)</span><br><span class="line"><span class="comment">// after sealing: &#123;value: 1, writable: true, enumerable: true, configurable: false&#125;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(o, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依然可以修改属性的值</span></span><br><span class="line">o.<span class="property">foo</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>freeze</p><p>除了seal之外，还把所有属性置为”unwritable”，就是说属性的值也不能修改了，这是最彻底的：不能增&#x2F;删&#x2F;改，也不能修改descriptor</p></li></ul><p>注意：上面所有的保护措施只针对对象本身，和它的原型链无关</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;property descriptor&lt;/code&gt;是javascript对象中属性的描述对象，包括了这个属性的meta信息，基本知识大家都知道，这里总结一些很隐晦的容易忽略的注意点&lt;/p&gt;
&lt;h1 id=&quot;writable-vs-configurable&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="javascript" scheme="http://tomwang1013.github.io/tags/javascript/"/>
    
    <category term="es5" scheme="http://tomwang1013.github.io/tags/es5/"/>
    
  </entry>
  
  <entry>
    <title>一文读懂vue响应式系统实现过程</title>
    <link href="http://tomwang1013.github.io/vue-reactive/"/>
    <id>http://tomwang1013.github.io/vue-reactive/</id>
    <published>2018-10-28T10:45:11.000Z</published>
    <updated>2023-07-18T03:20:12.568Z</updated>
    
    <content type="html"><![CDATA[<p>和众多前端框架一样，vue的数据驱动系统是它的核心，很多人都大概知道它是通过<code>Object.defineProperty</code>将普通属性变成<code>get</code>,<code>set</code>实现的，但知道这一点其实没啥用，因为实际情况远比这个复杂、精巧，本文尝试对整个响应式系统做一个简短、清晰、全面而不失深度的总结。以我自己这两年来使用vue的经验，了解这个系统是如何运作的对用好vue是非常有帮助的</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>数据驱动系统用一句话来概括就是：当数据变化时，自动通知监听者(也叫观察者、依赖者等)，这里面有两个主体：一是数据(data)，二是监听者(watcher)。它们两个是多对多的关系：一个数据可以有多个监听者，同时一个监听者可以同时监听多个数据：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1540791924393.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>既然要通知，就牵涉到两个问题：</p><ul><li>怎么知道数据变化了？</li><li>通知谁？</li></ul><p>我们先看下第一个问题：怎么知道数据变化了？</p><p>这个问题很简单，当我们改变对象某个属性的值，如<code>obj.foo = 1</code>时，如果<code>foo</code>是一个<code>setter</code>属性，那这个赋值操作就会调用setter函数，所以在setter函数中我们就可以知道属性的值变了。所以数据驱动的第一步便是要将数据对象的普通属性转为化<code>accessor</code>属性，我们称这一步为<strong>将数据变成响应式</strong>。</p><p>再来看第二个问题：数据变化时，通知谁？</p><p>很简单：谁依赖于我就通知谁啊。所以问题变成如何收集所有的对此数据的监听者。所谓监听者依赖于数据，指的是监听者在自身的执行过程中<strong>访问了数据</strong>，所以当其所访问的数据发生变化时，我们需要通知他重新执行一下。所以，我们可以在数据被访问的时候(getter)将当前的访问者(假设我们知道)保存起来，然后在数据变化的时候依次通知他们更新, 伪代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="keyword">const</span> watchers = []; <span class="comment">// 对foo字段的监听者</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">foo</span>() &#123;</span><br><span class="line">    <span class="comment">// 假设当前的访问者是currentWatcher</span></span><br><span class="line">    watchers.<span class="title function_">push</span>(currentWatcher)</span><br><span class="line">  &#125;，</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">foo</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="comment">// 数据变化，通知所有监听者更新</span></span><br><span class="line">    watchers.<span class="title function_">forEach</span>(<span class="function"><span class="params">w</span> =&gt;</span> w.<span class="title function_">update</span>())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以整个数据驱动系统可以用下面的图简单概括：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1540794060376.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>下面我们依次从源码分析图中的各个步骤是如何实现的。vue中响应式模块的代码如下，后面我们会直接引用文件名而忽略路径信息：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1540797011499.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="将数据变成响应式"><a href="#将数据变成响应式" class="headerlink" title="将数据变成响应式"></a>将数据变成响应式</h1><p>要构建响应式数据系统，首先要把数据变成响应式，准确地说是把一个<strong>对象</strong>变成响应式，这样我们就能知道何时访问或修改了这个对象的属性。根据前面的描述，这个过程很简单，就是遍历对象的所有属性，利用<code>defineProperty</code>把它们变成<code>accessor</code>(getter &amp; setter)，但是需要注意以下几点：</p><ul><li>对象的每个属性都是单独收集自己的watcher的，所以在遍历的过程中需要为每个属性准备一个专属于它的容器来保存将来要收集的监听者</li><li>根据情况我们需要深度遍历：属性的值可能也是个对象，我们需要把这个子对象也变成响应式</li><li>如果这个<strong>对象</strong>是一个数组，我们需要把数组的每个元素变成响应式</li></ul><p>根据这几点，我们来看看源码，把对象变成响应式的入口在<code>index.js</code>的<code>observe</code>中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">observe</span> (<span class="attr">value</span>: any, <span class="attr">asRootData</span>: ?boolean): <span class="title class_">Observer</span> | <span class="keyword">void</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  ob = <span class="keyword">new</span> <span class="title class_">Observer</span>(value)</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> ob;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个入口函数主要是做了一些判断，看看value能否转成响应式以及是否已经是响应式了，真正的入口是<code>Observer</code>这个class的构造函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js: 省略了一些代码</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="attr">value</span>: any; <span class="comment">// 需要转成响应式的对象</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (<span class="attr">value</span>: any) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">      <span class="comment">// 如果是数组，把数组的每个元素变成响应式</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">observeArray</span>(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果是普通对象，遍历它的每个属性，将其变成accessor属性</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">walk</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  walk (<span class="attr">obj</span>: <span class="title class_">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="title function_">defineReactive</span>(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  observeArray (<span class="attr">items</span>: <span class="title class_">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="title function_">observe</span>(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，真正把对象的某个属性变成<code>accessor</code>的是<code>defineReactive</code>，对于每个属性，都需要调用一次这个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js: 省略部分代码</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">defineReactive</span> (</span><br><span class="line">  <span class="attr">obj</span>: <span class="title class_">Object</span>,</span><br><span class="line">  <span class="attr">key</span>: string,</span><br><span class="line">  <span class="attr">val</span>: any,</span><br><span class="line">  customSetter?: ?<span class="title class_">Function</span>,</span><br><span class="line">  shallow?: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="comment">// 这个属性(key)专有的用来收集watcher的容器</span></span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 深度遍历：将所有子对象也变成响应式</span></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(val)</span><br><span class="line">  </span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span> () &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="comment">// 如果当前存在监听者，将它收集起来</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span><span class="comment">/*当前监听者*/</span>) &#123;</span><br><span class="line">        dep.<span class="title function_">depend</span>() <span class="comment">// 收集动作</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span> (newVal) &#123;</span><br><span class="line">      <span class="comment">// 如果数据发生变化，通知所有收集到的监听者</span></span><br><span class="line">      dep.<span class="title function_">notify</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些代码实现完全印证了我们前面的思路：当后面有watcher访问响应式对象的属性时，getter被调用，访问者被对应属性收集</p><h2 id="扩充及边界：再看Observer"><a href="#扩充及边界：再看Observer" class="headerlink" title="扩充及边界：再看Observer"></a>扩充及边界：再看Observer</h2><p>前面我们讲的是主体思想及实现，我们贴的代码也是精简过的，真实实现要比这个复杂一些，有很多边界条件及系统的健壮性可用性需要考虑，考虑以下两个问题：</p><ul><li><p>如果一个watcher依赖于对象o的属性a，而a本身是一个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照我们前面贴出的代码，我们直接赋给<code>o.a</code>一个新的值是可以触发watcher的更新操作的，但是给<code>o.a</code>对象新增或删除一个属性却不会通知watcher：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以触发watcher更新</span></span><br><span class="line">o.<span class="property">a</span> = &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增或删除字段都不会触发</span></span><br><span class="line">o.<span class="property">a</span>.<span class="property">c</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">delete</span> o.<span class="property">b</span></span><br></pre></td></tr></table></figure><p>而一般情况下，后面2种操作我们也是需要触发的，所以需要提供给用户某种接口，使得新增或删除字段时也能触发更新</p></li><li><p>如果一个watcher依赖于对象o的属性a，而a本身是一个数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">  <span class="attr">a</span>: [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，按照我们前面贴出的代码，我们直接赋给<code>o.a</code>一个新的值是可以触发watcher的更新操作的，但是给<code>o.a</code>对象新增或删除数组元素时却不会触发：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以触发watcher更新</span></span><br><span class="line">o.<span class="property">a</span> = [<span class="number">3</span>, <span class="number">4</span>] </span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增或删除字段都不会触发</span></span><br><span class="line">o.<span class="property">a</span>.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">o.<span class="property">a</span>.<span class="title function_">push</span>(<span class="number">3</span>)</span><br><span class="line">o.<span class="property">a</span>.<span class="title function_">pop</span>()</span><br><span class="line">...</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>而一般情况下，我们是希望触发的，所以vue也需要对数组做些特殊处理，使得我们对数组的改动也能触发watcher的更新</p></li></ul><p>这两种情况，vue作者都做了考虑，答案就在<code>Observer</code>中，我们重新看下它的构造函数未贴出的部分：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">  <span class="attr">dep</span>: <span class="title class_">Dep</span>; <span class="comment">// 收集依赖于整个value对象的watcher</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (<span class="attr">value</span>: any) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dep</span> = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">    <span class="title function_">def</span>(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="variable language_">this</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">      <span class="keyword">const</span> augment = hasProto</span><br><span class="line">        ? protoAugment</span><br><span class="line">        : copyAugment</span><br><span class="line">      <span class="title function_">augment</span>(value, arrayMethods, arrayKeys)</span><br><span class="line">      ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面有两个重要的变化：</p><ol><li><p>Observer对象定义了一个dep字段，我们知道dep对象是用来收集watcher的，但是这里的dep不是和value对象的某个属性绑在一起，而是和整个value相关联，它起的作用正是<strong>收集依赖于整个value对象的所有watcher，当value增加删除字段(如果value是纯对象)或元素(如果value是数组)自动通知watcher更新</strong>。那什么叫<em>依赖于整个value对象呢</em>？很简单，就是value作为其他响应式对象的一个属性的值，而watcher依赖于这个属性，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果w依赖于<code>o.a</code>，那么我们就说w依赖于o.a对应的整个对象：<code>&#123; b: 1 &#125;</code>。假设value &#x3D; o.a，则经过Observer构造函数后，value的值变成如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">__ob__</span>: &#123; </span><br><span class="line">      dep <span class="comment">// 收集依赖于外层a字段的watcher，即这里的w</span></span><br><span class="line">      value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">b</span>: &#123;</span><br><span class="line">      dep <span class="comment">// 收集依赖于b字段的watcher</span></span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123; &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params"></span>) &#123; &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对数组的特殊处理</p><p>同理，如果w依赖于一个数组字段value，那么这个数组经过observe之后，<code>value.__ob__.dep</code>也会收集这个w：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="comment">// w依赖于o.a，value = o.a</span></span><br><span class="line">  <span class="attr">a</span>: [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// observe(value)之后, value上多了__ob__这个属性：</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">__ob__</span>: &#123;</span><br><span class="line">    dep, <span class="comment">// 收集依赖于外层a字段的watcher，即这里的w</span></span><br><span class="line">    value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此外，我们还需要监听数组元素的变化，即当用户调用push，pop等修改数组的方法时会自动通知watcher，vue实现的原理是改写这些数组方法，并拦截调用，这就是下面这几行代码做的事：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> augment = hasProto</span><br><span class="line">        ? protoAugment</span><br><span class="line">        : copyAugment</span><br><span class="line">      <span class="title function_">augment</span>(value, arrayMethods, arrayKeys)</span><br></pre></td></tr></table></figure></li></ol><p>讲到这里，我们可以知道，一个对象是否是响应式的，只要看看它有没有<code>__ob__</code>属性。另外，有时还需要关注它是否是另一个响应式对象的某个属性的值，即这个对象是不是顶层对象，如果是顶层对象的话，它的<code>__ob__.dep</code>中是没有监听者的，vue组件中的<code>data</code>对象就是一个顶层对象</p><h1 id="收集监听者"><a href="#收集监听者" class="headerlink" title="收集监听者"></a>收集监听者</h1><p>前面我们反复提到了<code>Dep</code>类(上面的dep都是它的实例)就是用来收集watcher的，这节我们仔细看看它和数据及watcher三者的关系，我们先看看较为简单的Dep</p><h2 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h2><p>一个dep从属于某个响应式属性，里面包含了所有依赖于该属性的watcher，它的实现比较简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="attr">target</span>: ?<span class="title class_">Watcher</span>; <span class="comment">// 当前监听者：任何时刻最多只有一个监听者</span></span><br><span class="line">  <span class="attr">id</span>: number; <span class="comment">// dep的唯一标识</span></span><br><span class="line">  <span class="attr">subs</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Watcher</span>&gt;; <span class="comment">// 收集到的所有watcher</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = uid++</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span> = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (<span class="attr">sub</span>: <span class="title class_">Watcher</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub (<span class="attr">sub</span>: <span class="title class_">Watcher</span>) &#123;</span><br><span class="line">    <span class="title function_">remove</span>(<span class="variable language_">this</span>.<span class="property">subs</span>, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 收集watcher</span></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">      <span class="comment">// 收集watcher动作：将当前watcher收集起来</span></span><br><span class="line">      <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">addDep</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知watcher更新</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">slice</span>()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].<span class="title function_">update</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本没啥说的，唯一要注意的地方是在<code>depend</code>中，我们不是直接调用<code>addSub</code>将当前watcher收集起来，而是调用watcher的<code>addDep</code>方法，其实<code>watcher.addDep</code>内部最终也是调用<code>dep.addSub(this)</code>的，只是它还做了一些其他处理，这个我们后面会说。</p><p>这里再强调一点：dep和watcher是多对多的关系：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1540886749054.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>dep需要管理自己的watchers，通过<code>addSub</code>和<code>removeSub</code>随时更新watchers，但是这两个动作都是由watcher发起的。watcher也需要管理自己当前正在监听的所有数据，即管理和这些数据关联的deps。</p><h2 id="watcher"><a href="#watcher" class="headerlink" title="watcher"></a>watcher</h2><p>终于讲到watcher了，我们把数据变成响应式之后，需要访问数据(调用数据属性的getter)才能将当前的访问者收集起来，这个访问动作就是由watcher发起的。简单地说，这个访问动作就是调用一个求值函数。所以构建一个watcher需要至少提供：</p><ul><li>求值函数</li><li>回调函数：求值函数返回的值发生变化时回调</li></ul><p>另外，任何一个watcher都属于某个vue组件实例，</p><p>此外，watcher还需要保存所依赖的所有deps，我们看看简化的源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watcher.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="attr">vm</span>: <span class="title class_">Component</span>; <span class="comment">// 所属的vue实例</span></span><br><span class="line">  <span class="attr">cb</span>: <span class="title class_">Function</span>; <span class="comment">// 当value发生变化时的回调函数</span></span><br><span class="line">  <span class="attr">id</span>: number; <span class="comment">// 标识watcher的唯一id</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需要维护的依赖集</span></span><br><span class="line">  <span class="attr">deps</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Dep</span>&gt;; </span><br><span class="line">  <span class="attr">newDeps</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Dep</span>&gt;;</span><br><span class="line">  <span class="attr">depIds</span>: <span class="title class_">SimpleSet</span>;</span><br><span class="line">  <span class="attr">newDepIds</span>: <span class="title class_">SimpleSet</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attr">getter</span>: <span class="title class_">Function</span>; <span class="comment">// 求值函数</span></span><br><span class="line">  <span class="attr">value</span>: any; <span class="comment">// 求值函数返回结果</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span> (</span><br><span class="line">    <span class="attr">vm</span>: <span class="title class_">Component</span>,</span><br><span class="line">    <span class="attr">expOrFn</span>: string | <span class="title class_">Function</span>,</span><br><span class="line">    <span class="attr">cb</span>: <span class="title class_">Function</span>,</span><br><span class="line">    options?: ?<span class="title class_">Object</span>,</span><br><span class="line">    isRenderWatcher?: boolean</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// vm把自己的watchers保存起来</span></span><br><span class="line">    vm.<span class="property">_watchers</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span> = cb</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">id</span> = ++uid <span class="comment">// uid for batching</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deps</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDeps</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">depIds</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDepIds</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">getter</span> = <span class="title function_">parsePath</span>(expOrFn)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求值：触发收集操作</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Subscriber interface.</span></span><br><span class="line"><span class="comment">   * Will be called when a dependency changes.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  update () &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>精简后的watcher实现应该比较好理解了，<code>getter</code>保存了我们的求值函数，构造函数末尾我们通过<code>watcher.get</code>函数的调用触发求值函数，从而将watcher收集到所有的求值过程中遇到的dep中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Evaluate the getter, and re-collect dependencies.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">get () &#123;</span><br><span class="line">  <span class="title function_">pushTarget</span>(<span class="variable language_">this</span>) <span class="comment">// 将此watcher设置为当前watcher</span></span><br><span class="line">  <span class="keyword">let</span> value</span><br><span class="line">  <span class="keyword">const</span> vm = <span class="variable language_">this</span>.<span class="property">vm</span></span><br><span class="line">  <span class="comment">// 调用求值函数，启动收集过程</span></span><br><span class="line">  value = <span class="variable language_">this</span>.<span class="property">getter</span>.<span class="title function_">call</span>(vm, vm)</span><br><span class="line">  </span><br><span class="line">  <span class="title function_">popTarget</span>() <span class="comment">// 还原当前watcher</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">cleanupDeps</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数开始我们先将自己设置为当前watcher，然后调用求值函数，启动收集过程，这个过程中每次访问到响应式属性都会触发下面的调用过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.getter() =&gt; dep.depend() =&gt; watcher.addDep() =&gt; (可选)dep.addSub()</span><br></pre></td></tr></table></figure><p>我们来看看<code>watcher.addDep</code>，看看为什么不直接在<code>dep.depend</code>中调用<code>dep.addSub</code>，而需要绕一圈：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add a dependency to this directive.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">addDep (<span class="attr">dep</span>: <span class="title class_">Dep</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = dep.<span class="property">id</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">add</span>(id)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">newDeps</span>.<span class="title function_">push</span>(dep)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">depIds</span>.<span class="title function_">has</span>(id)) &#123;</span><br><span class="line">      dep.<span class="title function_">addSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造函数中我们看到watcher定义了下面四个字段来管理依赖，它们的意义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存当前的依赖集   </span></span><br><span class="line"><span class="attr">newDeps</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Dep</span>&gt;;</span><br><span class="line"><span class="attr">newDepIds</span>: <span class="title class_">SimpleSet</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存上一次求值时的依赖集</span></span><br><span class="line"><span class="attr">deps</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Dep</span>&gt;;</span><br><span class="line"><span class="attr">depIds</span>: <span class="title class_">SimpleSet</span>;</span><br></pre></td></tr></table></figure><p>为什么要这多呢？其实这是用来避免将一个watcher重复收集在同一个dep中的。假设<code>getter</code>函数如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> o.<span class="property">a</span> + o.<span class="property">a</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>o.a是一个响应式数据，如果我们不做处理的话，o.a.dep中将包含2个一样的watcher，这是为了在同一次求值过程中避免重复收集依赖；还有一种情况需要考虑：watcher的多次求值，这种情况我们同样需要避免重复收集watcher。所以我们在watcher中不但要保存当前求值正在收集的依赖(newDeps, newDepIds)，还需要保存上一次求值收集的依赖，每次求完值之后，我们会把newDeps赋值给deps，并把newDeps清空，这是通过在求值最后调用cleanupDeps实现的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cleanupDeps () &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="variable language_">this</span>.<span class="property">deps</span>.<span class="property">length</span></span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="variable language_">this</span>.<span class="property">deps</span>[i]</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">has</span>(dep.<span class="property">id</span>)) &#123;</span><br><span class="line">      dep.<span class="title function_">removeSub</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="variable language_">this</span>.<span class="property">depIds</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">depIds</span> = <span class="variable language_">this</span>.<span class="property">newDepIds</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">newDepIds</span> = tmp</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">newDepIds</span>.<span class="title function_">clear</span>()</span><br><span class="line">  tmp = <span class="variable language_">this</span>.<span class="property">deps</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">deps</span> = <span class="variable language_">this</span>.<span class="property">newDeps</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">newDeps</span> = tmp</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">newDeps</span>.<span class="property">length</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的逻辑分成两部分：后面的部分就是newDeps赋值给deps，并把newDeps清空；前一部分是解除废弃的依赖，就是说如果watcher不再依赖于某个数据了，需要把watcher从这个数据的依赖集中去掉：<code>dep.removeSub</code>。</p><h3 id="vue中watcher的分类"><a href="#vue中watcher的分类" class="headerlink" title="vue中watcher的分类"></a>vue中watcher的分类</h3><p>在watcher的构造函数中，有几个实例属性我们没有讲到，这牵涉到watcher的分类，我们来看看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watcher.js</span></span><br><span class="line"><span class="title function_">constructor</span> (</span><br><span class="line">  <span class="attr">vm</span>: <span class="title class_">Component</span>,</span><br><span class="line">  <span class="attr">expOrFn</span>: string | <span class="title class_">Function</span>,</span><br><span class="line">  <span class="attr">cb</span>: <span class="title class_">Function</span>,</span><br><span class="line">  options?: ?<span class="title class_">Object</span>,</span><br><span class="line">  isRenderWatcher?: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">vm</span> = vm</span><br><span class="line">  <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">    vm.<span class="property">_watcher</span> = <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line">  vm.<span class="property">_watchers</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// options</span></span><br><span class="line">  <span class="keyword">if</span> (options) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span> = !!options.<span class="property">user</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">computed</span> = !!options.<span class="property">computed</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span> = <span class="variable language_">this</span>.<span class="property">computed</span> = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数<code>isRenderWatcher</code>表示watcher是否是渲染watcher，我们知道每个vue实例都有一个渲染函数，它监控实例数据的变化并重新渲染dom，渲染watcher保存在vue实例的<code>_watcher</code>中，渲染watcher在src&#x2F;core&#x2F;instance&#x2F;lifecycle.js中创建，大家有兴趣可以看看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lifecycle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mountComponent</span> (</span><br><span class="line">  <span class="attr">vm</span>: <span class="title class_">Component</span>,</span><br><span class="line">  <span class="attr">el</span>: ?<span class="title class_">Element</span>,</span><br><span class="line">  hydrating?: boolean</span><br><span class="line">): <span class="title class_">Component</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher&#x27;s constructor</span></span><br><span class="line">  <span class="comment">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component&#x27;s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm.<span class="property">_isMounted</span>) &#123;</span><br><span class="line">        <span class="title function_">callHook</span>(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外两个属性<code>user</code>和<code>computed</code>的意义分别如下：</p><ul><li>user：标识是否是用户定义的watcher，即用户通过<code>vm.$watch</code>函数或watch选项定义的watcher</li><li>computed：标识是否是计算属性watcher，即系统自动为计算属性创建的watcher，它监听计算属性所依赖的数据的变化并更新计算属性的值</li></ul><h2 id="再看getter"><a href="#再看getter" class="headerlink" title="再看getter"></a>再看getter</h2><p>看了dep和watcher的实现，我们对依赖收集的整个过程应该比较清楚了，下面我们再看看getter中省略的部分：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">defineReactive</span> (</span><br><span class="line">  <span class="attr">obj</span>: <span class="title class_">Object</span>,</span><br><span class="line">  <span class="attr">key</span>: string,</span><br><span class="line">  <span class="attr">val</span>: any,</span><br><span class="line">  customSetter?: ?<span class="title class_">Function</span>,</span><br><span class="line">  shallow?: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(val)</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">reactiveGetter</span> () &#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.<span class="title function_">call</span>(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line">          <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">            <span class="title function_">dependArray</span>(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们重点看看<code>if (childOb)</code>里面的代码，我们先看看childOb是怎么来的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(val)</span><br></pre></td></tr></table></figure><p>如果val是一个对象，我们需要把这个对象也变成响应式，并把<code>val.__ob__</code>保存在childOb中。前面说过，如果一个watcher依赖于这个字段(key)，那么它也依赖于整个对象(val)，所以把它也收集到val中：<code>childOb.dep.depend()</code>。</p><p>除了这个之外，还有一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(value)) &#123;</span><br><span class="line">    <span class="title function_">dependArray</span>(value)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的意思是，如果这个字段对应的值是一个数组，需要再调用一个函数：<code>dependArray</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dependArray</span> (<span class="attr">value</span>: <span class="title class_">Array</span>&lt;any&gt;) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> e, i = <span class="number">0</span>, l = value.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">    e = value[i]</span><br><span class="line">    e &amp;&amp; e.<span class="property">__ob__</span> &amp;&amp; e.<span class="property">__ob__</span>.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(e)) &#123;</span><br><span class="line">      <span class="title function_">dependArray</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的意思很明显：递归遍历数组的每个元素，如果这个元素也是个响应式对象，那么这个元素也需要把当前的watcher收集起来，举例来说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  <span class="attr">a</span>: [&#123; <span class="attr">b</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">c</span>: <span class="number">2</span> &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果w依赖于<code>o.a</code>, 且o.a的每个元素都是响应式对象，那么这些对象新增或删除元素(通过vue提供的api)也会引起w的更新：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(o.<span class="property">a</span>[<span class="number">0</span>], <span class="string">&#x27;key1&#x27;</span>, <span class="string">&#x27;val1&#x27;</span>) <span class="comment">// 引起w的更新</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>响应式数据需要通过dep收集监听者(watcher)，而watcher也需要收集并管理其依赖的所有依赖集(dep)，这个过程都是由watcher的求值发起的，这个过程中需要避免重复收集依赖</p><h1 id="通知监听者更新"><a href="#通知监听者更新" class="headerlink" title="通知监听者更新"></a>通知监听者更新</h1><p>响应式系统的第三步便是修改数据，通知watcher更新，调用流程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.setter() -&gt; dep.notify() -&gt; watcher.update()</span><br></pre></td></tr></table></figure><p>我们先看看setter</p><h2 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h2><p>简略代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">defineReactive</span> (</span><br><span class="line">  <span class="attr">obj</span>: <span class="title class_">Object</span>,</span><br><span class="line">  <span class="attr">key</span>: string,</span><br><span class="line">  <span class="attr">val</span>: any,</span><br><span class="line">  customSetter?: ?<span class="title class_">Function</span>,</span><br><span class="line">  shallow?: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(val)</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> <span class="title function_">reactiveSetter</span> (newVal) &#123;</span><br><span class="line">      ...</span><br><span class="line">      childOb = !shallow &amp;&amp; <span class="title function_">observe</span>(newVal)</span><br><span class="line">      dep.<span class="title function_">notify</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要代码就两句，第二句<code>dep.notify()</code>就是通知所有watcher更新，没啥说的。第一句<code>childOb = !shallow &amp;&amp; observe(newVal)</code>在getter中也见过：如果我们新附的值也是一个对象，那没说的，需要把这个新对象也变成响应式</p><h2 id="dep-notify"><a href="#dep-notify" class="headerlink" title="dep.notify"></a>dep.notify</h2><p>dep中保存了所有依赖的watcher，数据变化时挨个通知它们就行了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dep.js</span></span><br><span class="line">notify () &#123;</span><br><span class="line">  <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">  <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">slice</span>()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">    subs[i].<span class="title function_">update</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="watcher-update"><a href="#watcher-update" class="headerlink" title="watcher.update"></a>watcher.update</h2><p>watcher怎么更新很重要的一件事，有不少问题需要考虑：</p><ul><li>同步还是异步</li><li>一个watcher的多个依赖数据同时修改，如何保证它只更新一次？</li><li>多个watcher需要更新，它们的更新顺序有没有要求？</li><li>watcher在更新过程中又触发了新的更新(包含它自己的)怎么处理？</li></ul><p>我们一边看代码一边讲解这些问题是如何处理的，首先看看入口函数：<code>watcher.update</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watcher.js</span></span><br><span class="line">update () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">computed</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">sync</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">run</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">queueWatcher</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先不考虑this.computed为true的情况，后面会单独讲计算属性。<code>this.sync</code>标识watcher是否是同步的，如果是，马上执行更新操作，这个标识可以在创建watcher的时候指定；如果不是，我们把watcher缓存起来，后面统一<strong>异步</strong>更新，所以watcher的更新一般是异步的，这是为了效率考虑。</p><p>无论是异步还是同步，最后都会调用<code>watcher.run</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watcher.js</span></span><br><span class="line">run () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">active</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">getAndInvoke</span>(<span class="variable language_">this</span>.<span class="property">cb</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>active</code>标识watcher是否还有效，如果有效，会调用<code>watcher.getAndInvoke</code>，顾名思义，这个函数就是重新求值并调用回调函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watcher.js</span></span><br><span class="line">getAndInvoke (<span class="attr">cb</span>: <span class="title class_">Function</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    value !== <span class="variable language_">this</span>.<span class="property">value</span> ||</span><br><span class="line">    <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">    <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">    <span class="comment">// have mutated.</span></span><br><span class="line">    <span class="title function_">isObject</span>(value) ||</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">deep</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// set new value</span></span><br><span class="line">    <span class="keyword">const</span> oldValue = <span class="variable language_">this</span>.<span class="property">value</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">    cb.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, value, oldValue)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先求出最新的值，然后判断该不该调用回调函数，判断条件有三个：</p><ol><li>值发生了变化</li><li>值没变化，但是值是一个对象，说明对象内部发生了变化</li><li>deep为true</li></ol><p>这三种情况都应该调用回调函数</p><h3 id="异步批量更新"><a href="#异步批量更新" class="headerlink" title="异步批量更新"></a>异步批量更新</h3><p>入口：<code>queueWatcher</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scheduler.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">queue</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Watcher</span>&gt; = [] <span class="comment">// 缓存所有待更新的watcher的队列</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">has</span>: &#123; [<span class="attr">key</span>: number]: ?<span class="literal">true</span> &#125; = &#123;&#125; <span class="comment">// 保证队列中watcher不会重复</span></span><br><span class="line"><span class="keyword">let</span> waiting = <span class="literal">false</span> <span class="comment">// 是否已经安排watcher批量更新</span></span><br><span class="line"><span class="keyword">let</span> flushing = <span class="literal">false</span> <span class="comment">// watcher的批量更新是否正在进行</span></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span> <span class="comment">// 当前正在进行更新的watcher在queue中的下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">queueWatcher</span> (<span class="attr">watcher</span>: <span class="title class_">Watcher</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.<span class="property">id</span></span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.<span class="title function_">push</span>(watcher)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">      <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">      <span class="keyword">let</span> i = queue.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].<span class="property">id</span> &gt; watcher.<span class="property">id</span>) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.<span class="title function_">splice</span>(i + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// queue the flush</span></span><br><span class="line">    <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">      waiting = <span class="literal">true</span></span><br><span class="line">      <span class="title function_">nextTick</span>(flushSchedulerQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数回答了我们前面关于<code>watcher.update</code>的第二和第四个问题，首先我们用<code>has</code>对象记录所有待更新的watcher是否已经放入更新队列，这样保证同一个watcher被多次触发更新时只会进入队列一次。</p><p><code>flushing</code>标识批量更新是否正在进行，如果不在进行，直接将watcher放入更新队列末尾；否则，将watcher按id大小放入队列中的对应位置(后面会提到，队列在批量更新之前会先按id升序排序)，就是说，更新过程中可能有watcher被不断加入队列，我们要确保中途加进来的watcher也能在本次批量中得到更新。</p><p><code>waiting</code>标识watcher的批量更新这个整体动作是否已经放入javascript的异步队列，防止这个动作被触发多次，你可以理解为和防止按钮被多次点击而采取的在首次点击都先disable，事件处理完再enable的逻辑差不多。</p><p>这里的<code>nextTick(cb)</code>你可以简单地理解为<code>setTimeout(cb, 0)</code>，真正的批量更新操作在<code>flushSchedulerQueue</code>中, 代码简化如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scheduler.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flushSchedulerQueue</span> () &#123;</span><br><span class="line">  flushing = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">let</span> watcher, id</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sort queue before flush.</span></span><br><span class="line">  <span class="comment">// This ensures that:</span></span><br><span class="line">  <span class="comment">// 1. Components are updated from parent to child. (because parent is always</span></span><br><span class="line">  <span class="comment">//    created before the child)</span></span><br><span class="line">  <span class="comment">// 2. A component&#x27;s user watchers are run before its render watcher (because</span></span><br><span class="line">  <span class="comment">//    user watchers are created before the render watcher)</span></span><br><span class="line">  <span class="comment">// 3. If a component is destroyed during a parent component&#x27;s watcher run,</span></span><br><span class="line">  <span class="comment">//    its watchers can be skipped.</span></span><br><span class="line">  queue.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">id</span> - b.<span class="property">id</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do not cache length because more watchers might be pushed</span></span><br><span class="line">  <span class="comment">// as we run existing watchers</span></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.<span class="property">length</span>; index++) &#123;</span><br><span class="line">    watcher = queue[index]</span><br><span class="line">    <span class="keyword">if</span> (watcher.<span class="property">before</span>) &#123;</span><br><span class="line">      watcher.<span class="title function_">before</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    id = watcher.<span class="property">id</span></span><br><span class="line">    has[id] = <span class="literal">null</span></span><br><span class="line">    watcher.<span class="title function_">run</span>()</span><br><span class="line">    <span class="comment">// in dev build, check and stop circular updates.</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; has[id] != <span class="literal">null</span>) &#123;</span><br><span class="line">      circular[id] = (circular[id] || <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> (circular[id] &gt; <span class="variable constant_">MAX_UPDATE_COUNT</span>) &#123;</span><br><span class="line">        <span class="title function_">warn</span>(</span><br><span class="line">          <span class="string">&#x27;You may have an infinite update loop &#x27;</span> + (</span><br><span class="line">            watcher.<span class="property">user</span></span><br><span class="line">              ? <span class="string">`in watcher with expression &quot;<span class="subst">$&#123;watcher.expression&#125;</span>&quot;`</span></span><br><span class="line">              : <span class="string">`in a component render function.`</span></span><br><span class="line">          ),</span><br><span class="line">          watcher.<span class="property">vm</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// keep copies of post queues before resetting state</span></span><br><span class="line">  <span class="keyword">const</span> activatedQueue = activatedChildren.<span class="title function_">slice</span>()</span><br><span class="line">  <span class="keyword">const</span> updatedQueue = queue.<span class="title function_">slice</span>()</span><br><span class="line"></span><br><span class="line">  <span class="title function_">resetSchedulerState</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// call component updated and activated hooks</span></span><br><span class="line">  <span class="title function_">callActivatedHooks</span>(activatedQueue)</span><br><span class="line">  <span class="title function_">callUpdatedHooks</span>(updatedQueue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将<code>flushing</code>置为true，表示批量更新正在进行。</p><p>然后对watcher按id进行升序排序，排序的原因注释里已经写了，这牵涉到其他模块的知识，大家先可以不必深究。</p><p>之后从队列中依次取出watcher调用<code>run</code>函数进行更新，<code>before</code>是创建watcher时提供的一个函数选项，表示在更新在之前的回调。这里还做了一个循环触发更新的监测，我们知道在队列的更新中不断有watcher被加入队列中，如果同一个watcher被加入很多次，有可能就是一个死循环，需要监测出来提醒用户</p><p>队列更新完之后再做一些更新后的回调，如果有的话</p><h1 id="computed属性实现原理"><a href="#computed属性实现原理" class="headerlink" title="computed属性实现原理"></a>computed属性实现原理</h1><p>我们知道计算属性和普通方法的区别就是计算属性不会每次访问都重新求值，而是它会监听求值过程中的数据的变化，有变化时才会重新求值，就这点来说，它和watcher的性质是一样的，不难想到计算属性是使用watcher实现的，每个计算属性内部都对应一个watcher，其<code>computed</code>属性为true。</p><p>除此之外，计算属性还可以被其他watcher所依赖，这是它和普通方法的另一个重要区别。</p><p>基于这两点，computed watcher的实现和普通watcher有些不一样，我们来看看watcher作了哪些特殊处理，首先来看看构造函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watcher.js</span></span><br><span class="line"><span class="title function_">constructor</span> (</span><br><span class="line">    <span class="attr">vm</span>: <span class="title class_">Component</span>,</span><br><span class="line">    <span class="attr">expOrFn</span>: string | <span class="title class_">Function</span>,</span><br><span class="line">    <span class="attr">cb</span>: <span class="title class_">Function</span>,</span><br><span class="line">    options?: ?<span class="title class_">Object</span>,</span><br><span class="line">    isRenderWatcher?: boolean</span><br><span class="line">  ) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="variable language_">this</span>.<span class="property">computed</span> <span class="comment">// for computed watchers</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">computed</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="literal">undefined</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dep</span> = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从构造函数可以看出2点：</p><ul><li><p>computed watcher还多了一个<code>dirty</code>属性，用来标识watcher是否需要重新求值</p></li><li><p>computed watcher在构造函数中不会马上求值以收集依赖，而是把value置为<code>undefined</code>且创建了一个Dep实例：<code>this.dep = new Dep()</code>。如果有其他的watcher依赖于计算属性的值，这个dep就是用来收集这些watcher的：</p><p><img src="/../images/1541470064217.png"></p></li></ul><h2 id="计算属性的初始化简介"><a href="#计算属性的初始化简介" class="headerlink" title="计算属性的初始化简介"></a>计算属性的初始化简介</h2><p>这里我们省略了一些细节，具体大家可以参考src&#x2F;core&#x2F;instance&#x2F;state.js中的<code>initComputed</code>函数</p><p>假设我们在vue实例上定义了计算属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过初始化后，系统为每个计算属性定义了一个watcher，所有的计算属性watcher保存在<code>_computedWatchers</code>中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="property">_computedWatchers</span> = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="keyword">new</span> <span class="title class_">Watcher</span>(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop, <span class="comment">// 计算属性的求值函数</span></span><br><span class="line">        noop,</span><br><span class="line">        &#123; <span class="attr">computed</span>: <span class="literal">true</span> &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且在vue实例上定义了一个同名属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(vm, <span class="string">&#x27;a&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> <span class="title function_">computedGetter</span> () &#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="variable language_">this</span>.<span class="property">_computedWatchers</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">_computedWatchers</span>[a]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      watcher.<span class="title function_">depend</span>()</span><br><span class="line">      <span class="keyword">return</span> watcher.evaluate()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: setter <span class="comment">// 可选</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="计算属性的求值"><a href="#计算属性的求值" class="headerlink" title="计算属性的求值"></a>计算属性的求值</h2><p>在watcher的构造函数中我们看到，computed watcher没有马上求值，而是在我们访问计算属性时才开始求值。我们通过vue实例访问计算属性的时候(如vm.a)，进入get函数，下面两句代码得以执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watcher.<span class="title function_">depend</span>()</span><br><span class="line"><span class="keyword">return</span> watcher.evaluate()</span><br></pre></td></tr></table></figure><p>第一句代码用来收集对计算属性本身的值的依赖：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watcher.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Depend on this watcher. Only for computed property watchers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">depend () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">dep</span> &amp;&amp; <span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dep</span>.<span class="title function_">depend</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释已经写得很清楚了</p><p>第二句代码就是计算属性的求值，返回给访问者：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watcher.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Evaluate and return the value of the watcher.</span></span><br><span class="line"><span class="comment"> * This only gets called for computed property watchers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">evaluate () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">dirty</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出它是惰性求值的，只有dirty为true，说明计算属性需要重新求值了，才重新求值，否则返回之前的值</p><h2 id="computed-watcher的更新：再看update"><a href="#computed-watcher的更新：再看update" class="headerlink" title="computed watcher的更新：再看update"></a>computed watcher的更新：再看update</h2><p>computed watcher的更新机制也不一样，我们再来看看：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// watcher.js</span></span><br><span class="line">update () &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">computed</span>) &#123;</span><br><span class="line">    <span class="comment">// A computed property watcher has two modes: lazy and activated.</span></span><br><span class="line">    <span class="comment">// It initializes as lazy by default, and only becomes activated when</span></span><br><span class="line">    <span class="comment">// it is depended on by at least one subscriber, which is typically</span></span><br><span class="line">    <span class="comment">// another computed property or a component&#x27;s render function.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">dep</span>.<span class="property">subs</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// In lazy mode, we don&#x27;t want to perform computations until necessary,</span></span><br><span class="line">      <span class="comment">// so we simply mark the watcher as dirty. The actual computation is</span></span><br><span class="line">      <span class="comment">// performed just-in-time in this.evaluate() when the computed property</span></span><br><span class="line">      <span class="comment">// is accessed.</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">dirty</span> = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// In activated mode, we want to proactively perform the computation</span></span><br><span class="line">      <span class="comment">// but only notify our subscribers when the value has indeed changed.</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">getAndInvoke</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">dep</span>.<span class="title function_">notify</span>()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是计算属性watcher，我们看看第一个if语句：<code>if (this.dep.subs.length === 0)</code>，它说明没有其他watcher依赖于这个计算属性，这个时候我们只是设置一些dirty，表示计算属性要重新求值，后面访问计算属性的时候它就会重新求值(见watcher.evaluate)；否则的话说明有其他watcher依赖于此计算属性，这个时候我们应该马上求值并通知其他watcher去更新</p><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p>到此为止，整个响应式系统就差不多讲完了，其实基本思路很简单，但是细节多，但愿讲清楚了；特别感谢：</p><p><a href="http://hcysun.me/vue-design/art/%E7%9A%84%E4%BD%9C%E8%80%85%EF%BC%8C%E5%85%B6%E4%BB%96%E4%BB%96%E5%86%99%E5%BE%97%E6%9B%B4%E8%AF%A6%E7%BB%86%EF%BC%8C%E6%88%91%E8%BF%99%E9%87%8C%E5%8F%AA%E6%98%AF%E7%BB%93%E5%90%88%E8%87%AA%E5%B7%B1%E7%9A%84%E7%90%86%E8%A7%A3%E9%87%8D%E6%96%B0%E6%80%BB%E7%BB%93%E4%BA%86%E4%B8%80%E9%81%8D%EF%BC%8C%E5%A4%A7%E5%AE%B6%E8%A6%81%E7%9C%8B%E6%9B%B4%E5%A4%9A%E7%BB%86%E8%8A%82%E7%9A%84%E8%AF%9D%E5%8F%AF%E4%BB%A5%E5%8E%BB%E7%9C%8B%E7%9C%8B">http://hcysun.me/vue-design/art/的作者，其他他写得更详细，我这里只是结合自己的理解重新总结了一遍，大家要看更多细节的话可以去看看</a></p><p>看了一些最新的源码，有些地方改了，我这个是基于2.5.17-beta.0，最新的是正式版2.5.17，回头有时间看了再修改下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;和众多前端框架一样，vue的数据驱动系统是它的核心，很多人都大概知道它是通过&lt;code&gt;Object.defineProperty&lt;/code&gt;将普通属性变成&lt;code&gt;get&lt;/code&gt;,&lt;code&gt;set&lt;/code&gt;实现的，但知道这一点其实没啥用，因为实际情况远比这</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="vue" scheme="http://tomwang1013.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>service worker之clients.claim() vs self.skipWaiting()</title>
    <link href="http://tomwang1013.github.io/pwa-clients-claim-vs-self-skipWaiting/"/>
    <id>http://tomwang1013.github.io/pwa-clients-claim-vs-self-skipWaiting/</id>
    <published>2018-10-25T09:20:09.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<p>service worker中有两个api出镜率很高：一个是<code>clients.claim()</code>, 另一个是<code>self.skipWaiting()</code>，我们分别看看它们的应用场景：</p><h1 id="clients-claim"><a href="#clients-claim" class="headerlink" title="clients.claim"></a>clients.claim</h1><p>当页面第一次注册sw的时候，我们注意到即使此页面及其子页面处于sw的控制范围之内，但是由此页面发出的任务请求都没有经过sw，换句话说，sw在页面第一次打开的时候并没有生效。这是一个<strong>正常</strong>行为，原因如下：</p><blockquote><p>if your page loads without a service worker, neither will its subresources</p></blockquote><p>就是说，如果页面自身的加载没有经过sw，那么它发出的所有请求也不会经过sw，这很正常，毕竟这只和首次加载有关，且即使没有sw应该也能工作良好。</p><p>如果你想改变这种情况，系统也提供了api，这就是<code>clients.claim</code>，你可以在sw的<code>activate</code>事件处理中调用，让sw马上生效，这样注册页面发出的请求在第一次页面加载的时候就会经过sw：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sw.js</span></span><br><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;activate&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Service worker activating...&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  clients.<span class="title function_">claim</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="self-skipWaiting"><a href="#self-skipWaiting" class="headerlink" title="self.skipWaiting"></a>self.skipWaiting</h1><p>我们知道，当sw更新的时候如果前一版本的sw还在工作，新的sw会等待，处于waiting状态知道所有被老的sw控制的页面都关闭，这也是<strong>正常</strong>行为，有利于保证应用状态的一致性。</p><p>如果你想新的sw马上取代老的进入工作状态(即进入<code>activate</code>状态)，你可以在<code>install</code>事件处理中调用<code>self.skipWaiting</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="title function_">addEventListener</span>(<span class="string">&#x27;install&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Service worker installing...&#x27;</span>)</span><br><span class="line">  self.<span class="title function_">skipWaiting</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;service worker中有两个api出镜率很高：一个是&lt;code&gt;clients.claim()&lt;/code&gt;, 另一个是&lt;code&gt;self.skipWaiting()&lt;/code&gt;，我们分别看看它们的应用场景：&lt;/p&gt;
&lt;h1 id=&quot;clients-claim&quot;</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="html5" scheme="http://tomwang1013.github.io/tags/html5/"/>
    
    <category term="pwa" scheme="http://tomwang1013.github.io/tags/pwa/"/>
    
  </entry>
  
  <entry>
    <title>web component之shadow dom</title>
    <link href="http://tomwang1013.github.io/web-component-shadow-dom/"/>
    <id>http://tomwang1013.github.io/web-component-shadow-dom/</id>
    <published>2018-10-22T06:33:45.000Z</published>
    <updated>2023-07-18T03:20:12.568Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="http://jinge.red/web-componet-custom-element/">custom elment</a>中我们提到web component的封装性需要<strong>shadow dom</strong>来进一步提升，因为shadow dom具有两大特点：</p><ul><li>Isolated DOM：隔离的dom结构</li><li>Scoped CSS：作用范围受限的CSS</li></ul><p>一句话：custom elements使我们能创建新的html元素，而shadow dom则为新的元素提供内容(html &amp; css)，它们结合在一起使web component(self-contained HTML, CSS, and JavaScript)成为可能</p><p>在下文中，我们会交换使用”自定义元素”和”组件”这两个术语，它们基本可以理解为同一个东西</p><p>下面我们从基础开始一点点揭开shadow dom的面纱</p><h1 id="什么是shadow-dom？"><a href="#什么是shadow-dom？" class="headerlink" title="什么是shadow dom？"></a>什么是shadow dom？</h1><p>普通的dom元素可以有自己的子节点，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>p1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>p2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的<code>div</code>元素有两个子元素；除此之外，我们还可以在它上面依附(attach)另一个dom树：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;to-attach-shadow&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// attach a shadow dom tree to it</span></span><br><span class="line"><span class="keyword">const</span> shadowRoot = div.<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;);</span><br><span class="line">shadowRoot.<span class="property">innerHTML</span> = <span class="string">&#x27;&lt;p&gt;shadow p1&lt;/p&gt;&lt;p&gt;shadow p2&lt;/p&gt;&#x27;</span>;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1540274643627.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>依附的这个dom树就是shadow dom，它的根节点叫<strong>shadow root</strong>，而它依附的元素(这里的div)叫<strong>shadow host</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.<span class="property">shadowRoot</span> === shadowRoot <span class="comment">// true</span></span><br><span class="line">shadowRoot.<span class="property">host</span> === div <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>那这里的渲染结果是什么？根据之前custom element中的例子，我们应该才到原来的内容被丢弃了，渲染出来的是shadow dom中的内容：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1540275086006.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="Isolated-DOM"><a href="#Isolated-DOM" class="headerlink" title="Isolated DOM"></a>Isolated DOM</h2><p>这里我们通过<code>document.querySelectorAll</code>只能得到原来的两个p元素：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1540275540129.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>shadow dom中的内容没法通过正常途径查询出来，只能通过shadow root来查：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1540275645122.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="不是所有的元素都可以attach-shadow-dom"><a href="#不是所有的元素都可以attach-shadow-dom" class="headerlink" title="不是所有的元素都可以attach shadow dom"></a>不是所有的元素都可以attach shadow dom</h2><p>有些元素(如：textarea，video等)浏览器已经使用了shadow dom来实现了，你不能再加了；有些元素加shadow dom没有任何意义，如img。所以，只有部分元素可以添加shadow dom，当然这部分元素包含了所有合法的custom elements，参考<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow">attachShadow</a>查看具体哪些元素可以</p><h1 id="内容分发与slot"><a href="#内容分发与slot" class="headerlink" title="内容分发与slot"></a>内容分发与slot</h1><p>我们把元素原来的子节点dom结构称为<strong>light dom</strong>，前面我们知道，默认情况下light dom是不会渲染出来的，最终的渲染结果完全由其上依附的shadow dom决定:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1540285980857.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这样不是很灵活，有时候我们希望由组件的使用者和开发者共同决定最终的渲染内容，这就是<strong>slot</strong>的由来：我们可以在shadow dom里面指定一些slot(插槽)，用来接收来自light dom中的内容，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shadowRoot.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;p&gt;shadow p1&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;shadow p2&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>上面的代码将整个light dom的内容插入到slot指定位置，渲染结果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1540287137492.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>shadow dom结构：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1540287198222.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>slot还可以指定<code>name</code>属性，然后在light dom中可以通过在元素上指定<code>slot=slotName</code>将对应元素渲染到指定的slot中，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shadowRoot.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;p&gt;shadow p1&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;slot name=&quot;slot1&quot;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;shadow p2&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;to-attach-shadow&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">&quot;slot1&quot;</span>&gt;</span>p1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>p2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>渲染结果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1540287536883.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>dom结构：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1540287575786.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>light dom中没有指定slot属性的都被渲染到默认的匿名slot中</p><h1 id="shadow-dom样式"><a href="#shadow-dom样式" class="headerlink" title="shadow dom样式"></a>shadow dom样式</h1><h2 id="scoped-css"><a href="#scoped-css" class="headerlink" title="scoped css"></a>scoped css</h2><p>shadow dom内部的元素样式不受外部css影响，内部定义的css也只作用于内部的元素，不影响外部，你可以把shadow root看做是一个屏障，把shadow dom和外面隔开了。比如说我们在外面定义了样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">200%</span>;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个样式只影响light dom，对shadow dom没有影响：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1540288132596.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>同理，我们在shadow dom内部定义了它自己的样式(外部的样式被删除了)，对外部元素的样式没有影响：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">shadowRoot.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;style&gt;</span></span><br><span class="line"><span class="string">    p &#123;</span></span><br><span class="line"><span class="string">      font-size: 20px;</span></span><br><span class="line"><span class="string">      color: blue;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &lt;/style&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;shadow p1&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;slot name=&quot;slot1&quot;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;shadow p2&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p><img src="/../images/1540288249870.png"></p><p>但是，shadow dom的样式还是受继承属性的影响，比如我们在body上面定义了一些继承属性，如<code>font-size</code>等，shadow dom也受这个影响:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1540288701927.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>特别地，shadow dom的样式从shadow host继承，受host元素样式的影响，把上面的body换成div同样成立</p><h2 id="从shadow-dom内部控制host的样式"><a href="#从shadow-dom内部控制host的样式" class="headerlink" title="从shadow dom内部控制host的样式"></a>从shadow dom内部控制host的样式</h2><p>我们可以在shadow dom内部利用下面三个selector选中其所在的host元素：</p><ul><li><p>:host</p><p>无条件选中host</p></li><li><p>:host(selector)</p><p>只有满足<code>selector</code>的host才被选中</p></li><li><p>:host-context(selector)</p><p>只有其本身或其祖先节点满足<code>selector</code>的host才被选中，是<code>:host(selector)</code>的超集</p></li></ul><p>利用这些选择器，我们可以在shadow dom内部控制host的样式，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">shadowRoot.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;style&gt;</span></span><br><span class="line"><span class="string">    :host &#123;</span></span><br><span class="line"><span class="string">      color: red;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    p &#123;</span></span><br><span class="line"><span class="string">      color: blue;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &lt;/style&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;shadow p1&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;slot name=&quot;slot1&quot;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;shadow p2&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1540298214495.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我们在host元素(即这里的div)上设置了<code>color: red</code>，所以light dom中的p元素都是红色；在shadow dom内部还重新定义了p的样式：<code>color: blue</code>，覆盖了从host元素继承的样式，所以shadow dom内部的p是蓝色。</p><h2 id="从shadow-dom内部控制light-dom的样式"><a href="#从shadow-dom内部控制light-dom的样式" class="headerlink" title="从shadow dom内部控制light dom的样式"></a>从shadow dom内部控制light dom的样式</h2><p>从上一节可以看到，light dom样式完全不受shadow dom内部样式影响，我们可以想象成<em>light dom以外部样式渲染好了之后再插入到shadow dom的slot处</em>。浏览器提供了一种机制：在light dom中的元素插入到slot处时，可以继续对它(已经使用外部样式渲染好了)追加一些样式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">shadowRoot.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;style&gt;</span></span><br><span class="line"><span class="string">    :host &#123;</span></span><br><span class="line"><span class="string">      color: red;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ::slotted(p) &#123;</span></span><br><span class="line"><span class="string">      font-size: 30px;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &lt;/style&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;shadow p1&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;slot name=&quot;slot1&quot;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">  &lt;p&gt;shadow p2&lt;/p&gt;</span></span><br><span class="line"><span class="string">  &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure><p>这使得light dom中的p元素的font-size变成30px：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1540299236892.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><code>::slotted(selector)</code>只能作用于顶层元素，例如这里只能选择p元素，而不能选择p元素的子元素(如果有的话)</p><h2 id="外部host样式优先"><a href="#外部host样式优先" class="headerlink" title="外部host样式优先"></a>外部host样式优先</h2><p>对于host元素，我们既可以在外部也可以在内部添加样式，当发生冲突时，外部的样式优先</p><h1 id="使用shadow-dom来填充custom-element"><a href="#使用shadow-dom来填充custom-element" class="headerlink" title="使用shadow dom来填充custom element"></a>使用shadow dom来填充custom element</h1><p>前面一直以普通的div元素来讲解shadow dom的机制，其实它的最佳拍档是custom element，一般来说，我们是在自定义元素的constructor中进行填充：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">HTMLClockElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="comment">// this.innerHTML = &#x27;i am a clock custom element&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> shadowRoot = <span class="variable language_">this</span>.<span class="title function_">attachShadow</span>(&#123; <span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span> &#125;);</span><br><span class="line">    shadowRoot.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;style&gt;</span></span><br><span class="line"><span class="string">        ...</span></span><br><span class="line"><span class="string">      &lt;/style&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;from clock&#x27;s shadow dom&lt;/p&gt;</span></span><br><span class="line"><span class="string">      &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;custom element created&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-clock</span>&gt;</span>i am a clock<span class="tag">&lt;/<span class="name">x-clock</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，<code>x-clock</code>就算得上一个真正的组件了，cool~</p><h1 id="高级主题"><a href="#高级主题" class="headerlink" title="高级主题"></a>高级主题</h1><p>有一些高级主题这里就不详细介绍了，大家碰到时可以参考google文档：<a href="https://developers.google.com/web/fundamentals/web-components/shadowdom#advanced">https://developers.google.com/web/fundamentals/web-components/shadowdom#advanced</a></p><p>其中最重要的是shadow dom的<a href="https://developers.google.com/web/fundamentals/web-components/shadowdom#advanced">事件模型</a>：发生在shadow dom内部的事件如何处理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;http://jinge.red/web-componet-custom-element/&quot;&gt;custom elment&lt;/a&gt;中我们提到web component的封装性需要&lt;strong&gt;shadow dom&lt;/strong&gt;来进一步提升，因为sha</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="html5" scheme="http://tomwang1013.github.io/tags/html5/"/>
    
    <category term="web component" scheme="http://tomwang1013.github.io/tags/web-component/"/>
    
  </entry>
  
  <entry>
    <title>web component之custom element</title>
    <link href="http://tomwang1013.github.io/web-componet-custom-element/"/>
    <id>http://tomwang1013.github.io/web-componet-custom-element/</id>
    <published>2018-10-22T05:57:34.000Z</published>
    <updated>2023-07-18T03:20:12.568Z</updated>
    
    <content type="html"><![CDATA[<p><strong>web component</strong>是html5原生的组件机制，它由四个标准组成：</p><ol><li>custom element</li><li>shadow dom</li><li>html template</li><li>html import</li></ol><p>这些标准可以单独使用，也可以结合在一起使用，今天先介绍一下<code>custom element</code>，后面会依次介绍其他几个</p><h1 id="native-elements与custom-elements"><a href="#native-elements与custom-elements" class="headerlink" title="native elements与custom elements"></a>native elements与custom elements</h1><p>html文档由很多基本元素组成，如<code>div</code>, <code>span</code>, <code>ul</code>等等，我们可以称这些已经存在的元素为<code>native elements(本地元素)</code>。每一种本地元素都有一个class与之对应，如<code>div</code>对应<code>HTMLDivElement</code>, <code>span</code>对应<code>HTMLSpanElement</code>，<code>ul</code>对应<code>HTMLUListElement</code>，这些class都是从<code>HTMLElement</code>继承下来</p><p>一个自然而然的想法是：我们能否创建一些自定义元素并使用自定义标签呢？如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-tag</span>&gt;</span><span class="tag">&lt;/<span class="name">my-tag</span>&gt;</span></span><br></pre></td></tr></table></figure><p>答案是可以，这就是<strong>custom elements</strong>的由来</p><h1 id="创建一种自定义元素"><a href="#创建一种自定义元素" class="headerlink" title="创建一种自定义元素"></a>创建一种自定义元素</h1><p>要创建一种自定义元素，我们首先要准备一个class，就像本地的<code>HTMLDivElement</code>一样，从<code>HTMLElement</code>继承，用来定义元素的内在行为，假设我们要创建一个表示时钟的元素，我们可以这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HTMLClockElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像<code>div</code>一样我们还需要指定这个元素对应的标签名，这样我们就能直接在html语言中使用这个元素了，我们把这个动作叫<strong>注册自定义元素</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&#x27;x-clock&#x27;</span>, <span class="title class_">HTMLClockElement</span>);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-clock</span>&gt;</span><span class="tag">&lt;/<span class="name">x-clock</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于元素的标签名需要注意的是：</p><ul><li>它们必须包含短横线(-)，这样浏览器在解析的时候才能将它们和本地元素区分开来</li><li>在使用的时候不能自包含(self-closing:<code>&lt;x-clock/&gt;</code>)，必须使用结束标签</li></ul><h1 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h1><p>在自定义元素的生命周期中有一些钩子(lifecycle hooks)，我们可以在其中做一些适当的响应处理：</p><table><thead><tr><th>Name</th><th>调用时机(Called when)</th></tr></thead><tbody><tr><td><code>constructor</code></td><td>An instance of the element is created or <a href="https://developers.google.com/web/fundamentals/web-components/customelements#upgrades">upgraded</a>. Useful for initializing state, settings up event listeners, or <a href="https://developers.google.com/web/fundamentals/web-components/customelements#shadowdom">creating shadow dom</a>. See the <a href="https://html.spec.whatwg.org/multipage/scripting.html#custom-element-conformance">spec </a>for restrictions on what you can do in the <code>constructor</code>.</td></tr><tr><td><code>connectedCallback</code></td><td>Called every time the element is inserted into the DOM. Useful for running setup code, such as fetching resources or rendering. Generally, you should try to delay work until this time.</td></tr><tr><td><code>disconnectedCallback</code></td><td>Called every time the element is removed from the DOM. Useful for running clean up code.</td></tr><tr><td><code>attributeChangedCallback(attrName, oldVal, newVal)</code></td><td>Called when an <a href="https://developers.google.com/web/fundamentals/web-components/customelements#attrchanges">observed attribute</a> has been added, removed, updated, or replaced. Also called for initial values when an element is created by the parser, or <a href="https://developers.google.com/web/fundamentals/web-components/customelements#upgrades">upgraded</a>. <strong>Note:</strong> only attributes listed in the <code>observedAttributes</code> property will receive this callback.</td></tr><tr><td><code>adoptedCallback()</code></td><td>The custom element has been moved into a new <code>document</code> (e.g. someone called <code>document.adoptNode(el)</code>).</td></tr></tbody></table><p><code>constructor</code>,<code>connectedCallback</code>,<code>disconnectedCallback</code>都很好理解，我们说下<code>attributeChangedCallback</code>和<code>adoptedCallback</code>：</p><ul><li><p><code>attributeChangedCallback</code></p><p>在使用元素的时候我们经常要指定一些属性，不同的元素需要指定不同的属性，如<code>img</code>元素有<code>src</code>属性，<code>input</code>元素有<code>disabled</code>, <code>value</code>等属性，这些都是浏览器内置的。作为自定义元素的作者，我们需要决定元素需要哪些属性供使用者使用，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-clock</span> <span class="attr">disabled</span> <span class="attr">hour</span>=<span class="string">&quot;4&quot;</span> <span class="attr">minute</span>=<span class="string">&quot;30&quot;</span> <span class="attr">second</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">x-clock</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这些属性中，我们可以指定哪些属性的变化可以被监控到，通过<code>observedAttributes</code>函数指定：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定需要观察的属性</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">get</span> <span class="title function_">observedAttributes</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="string">&#x27;disabled&#x27;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当<code>disabled</code>属性被修改或移除(<code>setAttribute,remoteAttribute</code>)时，<code>attributeChangedCallback</code>将被<strong>同步</strong>调用</p></li><li><p><code>adoptedCallback</code></p><p>当元素从当前文档移到另一个文档时被调用，移动的方式是<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/adoptNode">document.adoptNode</a></p></li></ul><h1 id="自定义元素的”升级”-upgrade"><a href="#自定义元素的”升级”-upgrade" class="headerlink" title="自定义元素的”升级”(upgrade)"></a>自定义元素的”升级”(upgrade)</h1><p>我们可以在自定义元素被注册之前就使用它：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-clock</span>&gt;</span><span class="tag">&lt;/<span class="name">x-clock</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个时候系统知道这些元素是自定义元素，但是是未定义的(<code>undefined</code>)，我们可以在后面再使用<code>customElements.define</code>来注册它，一旦被注册，这些未定义的元素就自动”升级(upgrade)”。</p><p>我们可以使用<code>customElements.whenDefined</code>来得知一个元素什么时候被定义了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">customElements.<span class="title function_">whenDefined</span>(<span class="string">&#x27;x-clock&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x-clock defined&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们来测试一下，页面如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>现在是未定义的：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;reg&quot;</span>&gt;</span>点击注册clock<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">x-clock</span>&gt;</span><span class="tag">&lt;/<span class="name">x-clock</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.mjs&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1540262306376.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clock.mjs</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">HTMLClockElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;i am a clock custom element&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;custom element created&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指定需要观察的属性</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> <span class="title function_">observedAttributes</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">&#x27;disabled&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">connectedCallback</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;insert into dom&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">disconnectedCallback</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;removed from dom&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">attributeChangedCallback</span>(<span class="params">attrName, oldVal, newVal</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;attrName&#125;</span> changed from <span class="subst">$&#123;oldVal&#125;</span> to <span class="subst">$&#123;newVal&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">adoptedCallback</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;move to new document&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HTMLClockElement</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./clock.mjs&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;reg&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  customElements.<span class="title function_">define</span>(<span class="string">&#x27;x-clock&#x27;</span>, <span class="title class_">HTMLClockElement</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">customElements.<span class="title function_">whenDefined</span>(<span class="string">&#x27;x-clock&#x27;</span>).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;x-clock defined&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>刚开始的时候自定义元素没有注册，虽然我们使用了它，但是控制台没有任何打印任何信息，元素内容也没有渲染出来；当我们点击按钮时，元素被注册，内容也渲染出来了：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1540262867740.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1540262877824.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1 id="自定义元素的展示"><a href="#自定义元素的展示" class="headerlink" title="自定义元素的展示"></a>自定义元素的展示</h1><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>自定义元素默认是空的，没有内容也没有样式，这显然没啥卵用，我们第一步先填充点内容，最简单的方式是直接在标签里面指定内容，就像普通的<code>div</code>元素一样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x-clock</span>&gt;</span>i am a clock<span class="tag">&lt;/<span class="name">x-clock</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1540264685155.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>这个时候自定义元素的内容完全取决于使用者，一般我们是不会这样做的，因为使用自定义元素(进而是web component)就是为了封装，所以一般是自己控制里面的内容。</p><p>可以在<code>constructor</code>中直接设置<code>innerHTML</code>属性(注意：在<code>constructor</code>中能做的事有一定的限制<a href="https://html.spec.whatwg.org/multipage/custom-elements.html#custom-element-conformance">spec</a>)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">super</span>();</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;i am a clock&#x27;</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;custom element created&#x27;</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p>自定义标签和其他标签一样，可以为它设置任何样式，如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x-clock &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1540264712762.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>为了更好地控制元素注册前后的展示效果，我们可以利用<code>:defined</code>伪类，它可以用来选取一定注册了的自定义元素，所以我们可以给未注册的元素单独设置样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x-clock<span class="selector-pseudo">:not</span>(<span class="selector-pseudo">:defined</span>) &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>自定义元素作为web component的重要组成部分，使得我们可以定制新的标签，标签中的内容由自己定义，有一定的封装作用。但是一旦元素被渲染出来，它和其他内置元素完全一样：里面的dom结构完全暴露在外面(通过document.queryBy***直接获取)，它的内部dom样式也会受外部css的影响，这离我们想要的组件封装还有一定的距离。</p><p>web component另一个组成部分是shadow dom，它就是来解决上面提到的封装问题的，后面会单独讲</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;web component&lt;/strong&gt;是html5原生的组件机制，它由四个标准组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;custom element&lt;/li&gt;
&lt;li&gt;shadow dom&lt;/li&gt;
&lt;li&gt;html template&lt;/li&gt;
&lt;li&gt;htm</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="html5" scheme="http://tomwang1013.github.io/tags/html5/"/>
    
    <category term="web component" scheme="http://tomwang1013.github.io/tags/web-component/"/>
    
  </entry>
  
  <entry>
    <title>随手练练：O(n)时间复杂度解决topk</title>
    <link href="http://tomwang1013.github.io/topk/"/>
    <id>http://tomwang1013.github.io/topk/</id>
    <published>2018-10-19T01:02:28.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><p>利用快排中的<code>partition</code>算法对数组a[n]进行划分成：a[0..p-1], a[p], a[p+1..n-1], 如果p+1&#x3D;k，完成；如果p+1&gt;k, 问题转化为在a[0..p-1]中查找topk；否则，问题转化为在a[p+1..n-1]中查找top(k-p-1)。这样，我们利用减治的思路一步步对数组做原地划分，算法终止时，我们直接取数组的前k个元素即可</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p><a href="https://gist.github.com/tomwang1013/6015cc8ba2c52d7e24d9e01d1b25fcaf">topK</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找数组的top K元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; <span class="variable">arr</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; <span class="variable">k</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">topK</span>(<span class="params">arr, k</span>) &#123;</span><br><span class="line">  <span class="title function_">topKRange</span>(arr, <span class="number">0</span>, arr.<span class="property">length</span> - <span class="number">1</span>, k);</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">slice</span>(<span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在arr[l..h]中查找top k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; arr </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; l </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; h </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; k </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">topKRange</span>(<span class="params">arr, l, h, k</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= h) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> m = <span class="title function_">partition</span>(arr, l, h);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (m - l + <span class="number">1</span> === k) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (m - l + <span class="number">1</span> &gt; k) &#123;</span><br><span class="line">    <span class="title function_">topKRange</span>(arr, l, m - <span class="number">1</span>, k);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">topKRange</span>(arr, m + <span class="number">1</span>, h, k - (m - l + <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * partition arr by the last element</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; arr </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; l </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; h </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> index of the partition element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partition</span>(<span class="params">arr, l, h</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = l;</span><br><span class="line">  <span class="keyword">let</span> j = l;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (j &lt; h) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[j] &gt; arr[h]) &#123;</span><br><span class="line">      <span class="title function_">swapArrEle</span>(arr, i++, j++);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">swapArrEle</span>(arr, i, h);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swapArrEle</span>(<span class="params">arr, i, j</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i === j) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tmp = arr[j];</span><br><span class="line">  arr[j] = arr[i];</span><br><span class="line">  arr[i] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本思路&quot;&gt;&lt;a href=&quot;#基本思路&quot; class=&quot;headerlink&quot; title=&quot;基本思路&quot;&gt;&lt;/a&gt;基本思路&lt;/h1&gt;&lt;p&gt;利用快排中的&lt;code&gt;partition&lt;/code&gt;算法对数组a[n]进行划分成：a[0..p-1], a[p], a[</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="algorithm" scheme="http://tomwang1013.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>行内布局的一点新的感悟</title>
    <link href="http://tomwang1013.github.io/inline-box-review/"/>
    <id>http://tomwang1013.github.io/inline-box-review/</id>
    <published>2018-10-18T01:41:08.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<p>行内布局是css的难点，主要涉及<code>line-height</code>，<code>vertical-align</code>，<code>font-size</code>这几个属性，一个简单的”行内居中对齐”就常常让人抓狂，因为行内不止有文字，还有图片、icon font及<code>inline-block</code>元素，它们混在一起会导致各种像素偏差，如果不深入理解其中原理的话，调起来只有碰运气了。还好，已经有前辈帮我们做了很深入浅出的总结，最近又重温了一遍张鑫旭同学的《CSS世界》的第五章：内联元素与流，有了一些新的感悟，特此记录一下</p><h1 id="几个基础概念"><a href="#几个基础概念" class="headerlink" title="几个基础概念"></a>几个基础概念</h1><ul><li><p>content area：内容区域</p><p>对文字来说，其选中的背景区域(蓝底白字)可以看成内容区域：</p><p><img src="/../images/content-area.png" alt="1539828317226"></p><p>对图片来说，内容区域可以看成是它本身</p></li><li><p>inline-box：内联盒子</p><p>内联盒子是行内的一段文字构成的盒子，如果这段文字被内联元素(如<code>em</code>,<code>span</code>等)包含，就是”内联盒子”，否则就是”匿名内联盒子”</p></li><li><p>line-box：行框</p><p>每一行就是就是一个行框，里面有多个内联盒子</p></li><li><p>containing box：包含盒子</p><p>包含盒子里面有多个行框</p></li></ul><h1 id="行内对齐"><a href="#行内对齐" class="headerlink" title="行内对齐"></a>行内对齐</h1><p>我们几乎每天都在做行内对齐，都在用<code>vertical-align</code>，但是大家有没有想过：既然是对齐，那肯定有参照物和被参照物，即谁和谁对齐。结合书上的讲解及自己的测试，我得出了下面的结论：</p><ol><li><p>谁和谁对齐？</p><p>指的是内联盒子与行框内的默认基线对齐：每个内联盒子都属于某个行框，而每个行框都有一条默认基线，即行框内匿名内联盒子中x字母的下边沿：</p><p><img src="/../images/1539837492653.png" alt="1539837492653"></p></li><li><p>如何对齐？</p><p>首先，每个内联盒子都有自己的基线，即每个盒子中字母x的下边沿；行框内所有匿名内联盒子的基线在同一水平线上，我们把这条水平线作为整个行框的默认基线，即上面提到的”默认基线”。</p><p>默认情况下，所有内联盒子的<code>vertical-align</code>都是<code>baseline</code>，这时的对齐方式是内联盒子的基线和整个行框的”默认基线”对齐：</p><p><img src="/../images/1539838192059.png" alt="1539838192059"></p><p>图中的实线是默认基线，虚线是每个内联盒子的基线</p><p>每个内联盒子可以设置不同的<code>vertical-align</code>，这会导致这个盒子在垂直方向上偏离默认基线：</p><p><img src="/../images/1539838404195.png" alt="1539838404195"></p><p>下面举个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  zyx</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;span1&quot;</span>&gt;</span>span1 x<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;span2&quot;</span>&gt;</span>x span2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;span3&quot;</span>&gt;</span>x span2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">600px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">141</span>, <span class="number">118</span>, <span class="number">163</span>);</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">   </span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.span1</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: brown</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">   </span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.span2</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">   </span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.span3</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">60px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: yellowgreen;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>默认情况下内联盒子都是按基线(baseline)对齐的：</p><p><img src="/../images/1539838552222.png" alt="1539838552222"></p><p>可以看到它们确实是按基线对齐的。现在我们来调整一下它们的”对齐线”：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.span1</span> &#123;</span><br><span class="line">  <span class="attribute">vertical-align</span>: -<span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.span2</span> &#123;</span><br><span class="line">  <span class="attribute">vertical-align</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.span3</span> &#123;</span><br><span class="line">  <span class="attribute">vertical-align</span>: -<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下，都相对默认基线偏移了设置的值，正值往上偏移，负值往下偏移：</p><p><img src="/../images/1539838743672.png" alt="1539838743672"></p><p>上面提到的是<code>vertical-align</code>设置成数值的效果，我们还可以使用关键字top，middle，bottom等。top和bottom比较好理解，它们会导致内连盒子的上边沿或下边沿和整个行框的上边沿或下边沿对齐，这2个值和baseline没啥关系。下面我们说下middle，首先是MDN上的正式定义：</p><blockquote><p>middle:</p><p>​Aligns the middle of the element with the baseline plus half the x-height of the parent</p></blockquote><p>可以看到，middle使得内联盒子的垂直中点和整个行框的默认基线以上1&#x2F;2个x字母的高度位置对齐，也就是和行框中匿名盒子中x字母的交叉点对齐：</p><p><img src="/../images/1539841495253.png" alt="1539841495253"></p><p>图中span1的高度是40px，它的中线穿过外面x字母的交叉点</p></li><li><p>其他vertical-align值</p><ul><li><p>百分比</p><p>和数值意思一样，但是需要和line-height的值相乘得到一个具体px数值</p></li><li><p>text-top</p><p>Aligns the top of the element with the top of the parent element’s font</p></li><li><p>text-bottom</p><p>Aligns the bottom of the element with the bottom of the parent element’s font</p></li></ul><p>用得不多，但是从字面意思应该不难理解</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;行内布局是css的难点，主要涉及&lt;code&gt;line-height&lt;/code&gt;，&lt;code&gt;vertical-align&lt;/code&gt;，&lt;code&gt;font-size&lt;/code&gt;这几个属性，一个简单的”行内居中对齐”就常常让人抓狂，因为行内不止有文字，还有图片、icon</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="css" scheme="http://tomwang1013.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>随手练练 - 归并和快速排序</title>
    <link href="http://tomwang1013.github.io/merge-quick-sort/"/>
    <id>http://tomwang1013.github.io/merge-quick-sort/</id>
    <published>2018-10-17T05:27:37.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="归并排序和快速排序比较"><a href="#归并排序和快速排序比较" class="headerlink" title="归并排序和快速排序比较"></a>归并排序和快速排序比较</h1><p>归并和快速排序是两种常见的排序算法，基本思路都是分治，平均时间复杂度都是<code>O(nlg(n))</code>，下面是它们的一些特性比较：</p><table><thead><tr><th></th><th>归并排序</th><th>快速排序</th></tr></thead><tbody><tr><td>平均时间复杂度</td><td>O(nlg(n))</td><td>O(nlg(n))</td></tr><tr><td>最坏时间复杂度</td><td>O(nlg(n))</td><td>O(n^2)</td></tr><tr><td>稳定性</td><td>稳定</td><td>不稳定</td></tr><tr><td>空间复杂度</td><td>O(n)</td><td>O(1)</td></tr></tbody></table><h1 id="归并排序实现"><a href="#归并排序实现" class="headerlink" title="归并排序实现"></a>归并排序实现</h1><p><a href="https://gist.github.com/tomwang1013/a5c7d25c776669411cc59e20963ef00e">merge-sort.js</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * marge an array arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; arr </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="title function_">mergeSortRange</span>(arr, <span class="number">0</span>, arr.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * merge sort arr[l..h]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; arr </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; l </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; h </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mergeSortRange</span>(<span class="params">arr, l, h</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= h) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> m = l + <span class="title class_">Math</span>.<span class="title function_">floor</span>((h - l) / <span class="number">2</span>);</span><br><span class="line">  <span class="title function_">mergeSortRange</span>(arr, l, m);</span><br><span class="line">  <span class="title function_">mergeSortRange</span>(arr, m + <span class="number">1</span>, h);</span><br><span class="line">  <span class="title function_">merge</span>(arr, l, m, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * merge arr[p..q] and arr[q + 1..r]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; arr </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; p </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; q </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; r </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">arr, p, q, r</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> tmpArr = <span class="keyword">new</span> <span class="title class_">Array</span>(r - p + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">let</span> i = p;</span><br><span class="line">  <span class="keyword">let</span> j = q + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= q &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">      tmpArr[k++] = arr[i++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tmpArr[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= q) &#123;</span><br><span class="line">    tmpArr[k++] = arr[i++];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (j &lt;= r) &#123;</span><br><span class="line">    tmpArr[k++] = arr[j++];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  k = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (k &lt;= r - p) &#123;</span><br><span class="line">    arr[k + p] = tmpArr[k++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序一个最大的缺点是它不能原地排序，需要分配一个临时的数组来存储归并结果并将归并结果写入原数组对应位置，这是它不那么流行的原因之一</p><h1 id="快速排序实现"><a href="#快速排序实现" class="headerlink" title="快速排序实现"></a>快速排序实现</h1><p><a href="https://gist.github.com/tomwang1013/c9c4512f7c0359c41e97bea7f29aec09">quick sort</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * quick sort an array arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; arr </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">quickSort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="title function_">quickSortRange</span>(arr, <span class="number">0</span>, arr.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * quick sort arr[l..h]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; arr </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; l </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; h </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">quickSortRange</span>(<span class="params">arr, l, h</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (l &gt;= h) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> m = <span class="title function_">partition</span>(arr, l, h);</span><br><span class="line">  <span class="title function_">quickSortRange</span>(arr, l, m - <span class="number">1</span>);</span><br><span class="line">  <span class="title function_">quickSortRange</span>(arr, m + <span class="number">1</span>, h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * partition arr by the last element</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Array</span>&#125; arr </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; l </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; h </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> index of the partition element</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partition</span>(<span class="params">arr, l, h</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = l;</span><br><span class="line">  <span class="keyword">let</span> j = l;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (j &lt; h) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[j] &lt; arr[h]) &#123;</span><br><span class="line">      <span class="title function_">swapArrEle</span>(arr, i++, j++);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      j++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">swapArrEle</span>(arr, i, h);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">swapArrEle</span>(<span class="params">arr, i, j</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i === j) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> tmp = arr[j];</span><br><span class="line">  arr[j] = arr[i];</span><br><span class="line">  arr[i] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快速排序的关键是<code>partition</code>函数，它能实现原地分隔，不需要分配临时数组，所以它比merge sort应用广泛一点</p><h1 id="分治减治思想"><a href="#分治减治思想" class="headerlink" title="分治减治思想"></a>分治减治思想</h1><p>这2种排序都用到了分治思想，即把一个大问题拆成小问题，<strong>每个</strong>小问题都解决了，大问题也就解决了；还有一种思想是减治：把一个大问题化简为<strong>一个</strong>小问题，这个小问题解决了，大问题也就解决了，二分查找就是典型的减治思想的应用。这两种思想的时间复杂度不同，减治算法通常时间复杂度更小</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;归并排序和快速排序比较&quot;&gt;&lt;a href=&quot;#归并排序和快速排序比较&quot; class=&quot;headerlink&quot; title=&quot;归并排序和快速排序比较&quot;&gt;&lt;/a&gt;归并排序和快速排序比较&lt;/h1&gt;&lt;p&gt;归并和快速排序是两种常见的排序算法，基本思路都是分治，平均时间复杂度</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="algorithm" scheme="http://tomwang1013.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>PWA之存储简介</title>
    <link href="http://tomwang1013.github.io/pwa-storage/"/>
    <id>http://tomwang1013.github.io/pwa-storage/</id>
    <published>2018-10-12T13:20:44.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器端有多种存储方式，作为PWA程序该如何选择离线存储方式呢？首先我们看看典型的web程序有哪些数据需要存储。浏览器端的数据分两类：</p><ol><li>静态资源：如html，css，js，image等和某个URL关联的请求资源</li><li>动态数据：如动态请求后端接口返回的一些状态信息等，通常是ajax请求返回的</li></ol><p>总结来看：</p><ol><li>对静态资源(URL addressable resources)，我们使用<a href="https://developers.google.com/web/fundamentals/instant-and-offline/web-storage/cache-api">Cache Api</a></li><li>对动态数据，我们使用<a href="https://developers.google.com/web/ilt/pwa/working-with-indexeddb">IndexDB</a></li></ol><p>下面我们依次介绍并比较一下所有浏览器端的存储方式：</p><ol><li>Cookies<ul><li>sync</li><li>不支持web worker及service worker</li><li>储存量很有限，且只能存string类型</li></ul></li><li>Session Storage &amp; Local Storage<ul><li>sync</li><li>不支持web worker及service worker</li><li>储存量很有限，且只能存string类型</li></ul></li><li>Cache API<ul><li>async (Promise-based)</li><li>支持Windows, Workers, Service Workers</li><li>key &#x3D; Request, value &#x3D; Response</li><li>储存类型不限</li></ul></li><li>IndexDB<ul><li>async (event based)</li><li>支持Windows, Workers, Service Workers</li><li>支持索引(indexed)、事务(transactions)、游标(cursors)</li><li>储存类型不限</li><li>Not SQL，很低层，一般使用封装好的基于promised的库，如<a href="https://github.com/jakearchibald/idb">idb</a></li></ul></li><li><del>File System</del>：只有chrome支持，不考虑</li><li><del>WebSQL</del>：Rejected by Edge, Firefox，不考虑</li><li><del>App Cache</del>：废弃</li></ol><p>前面没有提到Cache API和IndexDB的储存大小限制，其实他们也有限制，只是上限远高于Cookies和LocalStorage，但是具体的限制却有点复杂，且每个浏览器都不一样，这里有个大概的数据：</p><table><thead><tr><th>Browser</th><th>Limit</th></tr></thead><tbody><tr><td>Chrome</td><td>&lt;6% of free space</td></tr><tr><td>Firefox</td><td>&lt;10% of free space</td></tr><tr><td>Safari</td><td>&lt;50MB</td></tr><tr><td>IE10</td><td>&lt;250MB</td></tr><tr><td>Edge</td><td><a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/documentation/dev-guide/storage/IndexedDB/">Dependent on volume size</a></td></tr></tbody></table><p>参考：</p><p><a href="https://developers.google.com/web/fundamentals/instant-and-offline/web-storage/">https://developers.google.com/web/fundamentals/instant-and-offline/web-storage/</a></p><p><a href="https://docs.google.com/presentation/d/11CJnf77N45qPFAhASwnfRNeEMJfR-E_x05v1Z6Rh5HA/edit#slide=id.g146417e51d_0_113">https://docs.google.com/presentation/d/11CJnf77N45qPFAhASwnfRNeEMJfR-E_x05v1Z6Rh5HA/edit#slide=id.g146417e51d_0_113</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;浏览器端有多种存储方式，作为PWA程序该如何选择离线存储方式呢？首先我们看看典型的web程序有哪些数据需要存储。浏览器端的数据分两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态资源：如html，css，js，image等和某个URL关联的请求资源&lt;/li&gt;
&lt;li&gt;动态数据：如动态请</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="pwa" scheme="http://tomwang1013.github.io/tags/pwa/"/>
    
    <category term="storage" scheme="http://tomwang1013.github.io/tags/storage/"/>
    
  </entry>
  
  <entry>
    <title>offline-cookbook总结</title>
    <link href="http://tomwang1013.github.io/offline-cookbook/"/>
    <id>http://tomwang1013.github.io/offline-cookbook/</id>
    <published>2018-10-12T04:49:24.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook">offline cookbook</a>是关于service worker缓存及响应策略很好的文章，这里画个图总结一下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="..\images\offline-cookbook.png" alt="offline cookbook" title="">                </div>                <div class="image-caption">offline cookbook</div>            </figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook&quot;&gt;offline cookbook&lt;/a&gt;是关于service worker缓存及响应策</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="pwa" scheme="http://tomwang1013.github.io/tags/pwa/"/>
    
  </entry>
  
  <entry>
    <title>CSRF和XSS扫盲</title>
    <link href="http://tomwang1013.github.io/csrf-xss/"/>
    <id>http://tomwang1013.github.io/csrf-xss/</id>
    <published>2018-09-02T04:49:24.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<p>关于CSRF和XSS的文章非常多，相信很多人也看过了，笔者也看了一些，但总是记不住，这个做个非常简单的总结，让大家有个直观的印象</p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>全称：Cross-Site Request Forgery，以用户的名义发起一个恶意请求，简单过程如下：</p><ol><li>用户登录正常网站A</li><li>用户同时不小心打开黑客的网站B</li><li>网站B自动或由用户触发发起一个恶意的指向A服务器的请求</li><li>A服务器处理这个恶意请求，坏事发生</li></ol><p>这里有幅网上找的图可以看出这个过程：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/csrf.png" alt="img" title="">                </div>                <div class="image-caption">img</div>            </figure><h3 id="如何避免？"><a href="#如何避免？" class="headerlink" title="如何避免？"></a>如何避免？</h3><ol><li><p>让服务器只接受POST请求是无法避免的，普通的form提交同样可以发起cross-domain请求</p></li><li><p>严格限制<a href="http://performantcode.com/web/do-you-really-know-cors">CORS</a>, 千万不要出现</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure></li><li><p>避免的关键是如何区分甄别出恶意请求：目前比较好的一种做法是为每个请求带上一个随机的token，这个token是服务器端和浏览器端通过某种方式约定好的，服务器端通过检查这个token来验证请求的合法性，这个很多后端框架都做了支持。</p></li><li><p>最新新的cookie规范添加了一个<a href="https://www.netsparker.com/blog/web-security/same-site-cookie-attribute-prevent-cross-site-request-forgery/">SameSite</a>的属性，能有效遏制CSRF，其核心原理控制从第三方页面发起的请求是否能带上cookie。比如：从b页面访问a页面，将不会带上属于a页面的设置了<code>SameSite</code>的cookie</p></li></ol><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>全称：Cross-site Scripting，想方设法在用户浏览的网页上植入恶意脚本，既然是脚本，就可以做任何事：获取隐私(cookie等)、打开其他网站、修改页面内容等等</p><p>怎么植入恶意脚本呢？举两个例子：</p><ol><li><p>下面是一段JSP脚本，将来自当前页面url中的一个参数展示在页面上：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="type">String</span> <span class="variable">eid</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;eid&quot;</span>); %&gt; </span><br><span class="line">Employee ID: &lt;%= eid %&gt;</span><br></pre></td></tr></table></figure><p>攻击者可以先准备一个url，在eid参数中存入恶意脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://webpage.com/?eid=&lt;script&gt;alert(1)&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>然后引诱用户点击这个url，引诱的方式很多，如email，SNS等。用户一点击，脚本执行</p></li><li><p>又是一段JSP脚本，在数据库中查找一个名称，然后展示出来：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"> <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;select * from emp where id=&quot;</span> + id);</span><br><span class="line"><span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">    rs.next(); </span><br><span class="line">   <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">Employee Name: &lt;%= name %&gt;</span><br></pre></td></tr></table></figure><p>如果这个名称是用户输入的，且正常情况下其他用户可以通过浏览网页看到这个信息，那么攻击者可以输入一段恶意脚本作为名称，这个名称被存入数据库中，所有用户都可能看到，所以很多用户都会受到攻击</p></li></ol><p>由此可以看到，XSS一般是外部输入直接展示在页面上导致的，所以解决的办法就是对外部输入进行严格的验证，必要时对输入内容进行转码，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- html entity encode --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">script</span>&gt;</span> =&gt; <span class="symbol">&amp;lt;</span>script<span class="symbol">&amp;gt;</span>alert(1)<span class="symbol">&amp;lt;</span>/script<span class="symbol">&amp;gt;</span> </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于CSRF和XSS的文章非常多，相信很多人也看过了，笔者也看了一些，但总是记不住，这个做个非常简单的总结，让大家有个直观的印象&lt;/p&gt;
&lt;h2 id=&quot;CSRF&quot;&gt;&lt;a href=&quot;#CSRF&quot; class=&quot;headerlink&quot; title=&quot;CSRF&quot;&gt;&lt;/a&gt;CS</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="安全" scheme="http://tomwang1013.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>javascript优化之code splitting</title>
    <link href="http://tomwang1013.github.io/code-splitting/"/>
    <id>http://tomwang1013.github.io/code-splitting/</id>
    <published>2018-08-22T04:49:24.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<p><code>tree shaking</code>指的是去掉没用到的代码，减小js文件体积从而提高加载速度；而<code>code splitting</code>指的是如何将js代码分解成不同的js文件，使得页面在打开时只加载必要的js文件，从而提高页面加载速度。</p><p>大概有以下三种分解方式：</p><h3 id="Vendor-splitting"><a href="#Vendor-splitting" class="headerlink" title="Vendor splitting"></a>Vendor splitting</h3><p>将第三方代码(vendor code)和应用程序的代码分开来，使用不用的缓存策略，使得它们互不影响。我们<strong>始终</strong>都应该这么做</p><h3 id="Entry-point-splitting"><a href="#Entry-point-splitting" class="headerlink" title="Entry point splitting"></a>Entry point splitting</h3><p>对于多页面应用，应该按页面打包js，并将各个页面的公共js提取出来作为单独的js文件进行加载</p><h3 id="Dynamic-splitting"><a href="#Dynamic-splitting" class="headerlink" title="Dynamic splitting"></a>Dynamic splitting</h3><p>使用动态js加载语法，在页面首次打开后，在后面的操作过程中按需加载js，比如根据用户状态或模块切换动态加载相关js，提高页面首屏渲染速度</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;tree shaking&lt;/code&gt;指的是去掉没用到的代码，减小js文件体积从而提高加载速度；而&lt;code&gt;code splitting&lt;/code&gt;指的是如何将js代码分解成不同的js文件，使得页面在打开时只加载必要的js文件，从而提高页面加载速度。&lt;/p&gt;</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="performance" scheme="http://tomwang1013.github.io/tags/performance/"/>
    
    <category term="webpack" scheme="http://tomwang1013.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>深入理解浏览器关键渲染路径(critical render path)及其优化</title>
    <link href="http://tomwang1013.github.io/crp/"/>
    <id>http://tomwang1013.github.io/crp/</id>
    <published>2018-08-22T04:49:24.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<p>web性能分析通常都是基本理论+反复实践，没有一套统一的标准或方法。以我的经验来看，我们或多或少都知道一些或几点相关理论，但都是很片段很零碎的，不太好总结或关联起来。本文尝试在<code>critical render path</code>(后简称crp)上做一个分析总结。</p><h3 id="什么是crp？"><a href="#什么是crp？" class="headerlink" title="什么是crp？"></a>什么是crp？</h3><p>crp是和浏览器首屏渲染有关的，指的是浏览器在渲染首屏之前需要经过哪些关键步骤。我们知道，首屏渲染速度是性能的一个重要指标，我们应该让用户在打开页面后尽快看到东西出来。要做到这一点，需要深入分析并优化crp，让这些关键步骤所花时间最小。第一步，我们先看看浏览器是如何渲染页面的</p><h3 id="页面渲染流程"><a href="#页面渲染流程" class="headerlink" title="页面渲染流程"></a>页面渲染流程</h3><p>这算是一个基本理论，每个浏览器渲染页面都要经过一个基本相同的过程：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1537495003079.png" alt="1537495003079" title="">                </div>                <div class="image-caption">1537495003079</div>            </figure><ol><li>解析html构建DOM</li><li>解析css构建CSSOM（和第一步同时进行）</li><li>将DOM和CSSOM合起来构建渲染树</li><li>根据渲染树，计算每个元素在窗口中的确切位置和大小</li><li>执行渲染</li></ol><p>我们以一个例子来详细说明这几个步骤，考虑下面一段html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Critical Path<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;awesome-photo.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第一步解析html，生成DOM：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1537495651317.png" alt="1537495651317" title="">                </div>                <div class="image-caption">1537495651317</div>            </figure><p>第二步解析css，生成CSSOM：</p><p>DOM告诉了我们页面的结构，但是没有样式信息，所以下一步就是解析css，也会生成一个树状结构，这是因为css具有继承特性，子元素或默认继承父元素的一些样式，我们假设页面中的css如下(可以inline或从外部文件导入)：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-size</span>: <span class="number">16px</span> &#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">font-weight</span>: bold &#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123; <span class="attribute">color</span>: red &#125;</span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span> &#123; <span class="attribute">display</span>: none &#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123; <span class="attribute">float</span>: right &#125;</span><br></pre></td></tr></table></figure><p>生成的CSSOM树如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1537495994924.png" alt="1537495994924" title="">                </div>                <div class="image-caption">1537495994924</div>            </figure><p>灰色的<code>font-size</code>表示这是一个继承属性。这里需要注意的是，CSSOM树中只包含了我们显式设置样式的元素，因为浏览器还有自己的默认样式</p><p>第三步把DOM和CSSOM结合在一起，生成渲染树(render tree)：</p><p>渲染树包含所有<strong>可见</strong>的元素及其显式设置的**最终样式(computed style)**，所以head和p元素下面的span不会出现在渲染树中：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1537498465699.png" alt="1537498465699" title="">                </div>                <div class="image-caption">1537498465699</div>            </figure><p><span style="color: #999999;font-size:12px">注：图中的渲染树应该少了一个body的植树span元素</span></p><p>第四步计算所有元素在视窗(viewport)中的位置和大小：</p><p>在最终渲染之前需要计算每个元素的位置和大小，即它的<code>box model</code>，所有的尺寸css属性都要转为为像素，这一步也叫<em>回流(reflow)</em></p><p>最后一步就是渲染(pixel to screen)了，我们知道了元素的可见性及最终样式、大小、尺寸，剩下的事就是将它们画在屏幕上</p><p>这就是整个渲染过程，优化crp就是要尽量减少这5步所花的时间，让内容尽快呈现在用户面前。</p><h3 id="css的render-blocking特性"><a href="#css的render-blocking特性" class="headerlink" title="css的render blocking特性"></a>css的render blocking特性</h3><p>从上面我们可以看到，只有html和css都解析完了，我们才能构建渲染树，它们都是<em>渲染阻塞</em>(render blocking)的。html不用说了，没有它我们的页面从何而来，我们来说下css。如果没有样式，使用系统默认的样式，页面是很难看且基本不可用的。如果浏览器解析完DOM就直接渲染，等后面css再解析完了再渲染，就会出现页面的闪动问题：”Flash of Unstyled Content” (FOUC)，所以我们必须尽快构建CSSOM。因为CSSOM与DOM的构建是并行的，所以一般将css放在head里面，让它尽快开始构建，这样能将渲染树的构建尽量提前。</p><h3 id="javascript登场"><a href="#javascript登场" class="headerlink" title="javascript登场"></a>javascript登场</h3><p>页面当然少不了js，关于js的故事也最多。当页面引入js后，问题变复杂了，因为js太强大了：既能修改DOM有能修改CSSOM，还有人人闻之变色敬而远之的<code>document.write</code>，所以大家都听到一个故事了：浏览器在parse html过程中只要一遇到js，就要停止parse，直接此js加载并运行完成，这就是<strong>html block on js</strong>。其实这个故事只讲了一半，另一半是<strong>js block on css</strong>：如果当前有css还没有下载或解析完，js必须等待它们完成后才能执行！</p><p>前面说过，DOM和CSSOM是并行独立解析的，现在因为js的加入，它们之间发生了关联：DOM解析因js而阻塞，而js又因CSSOM而阻塞：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1537505638482.png" alt="1537505638482" title="">                </div>                <div class="image-caption">1537505638482</div>            </figure><p>这也解释了为什么**css在上，js在下(Stylesheets at the top, scripts at the bottom)**：js放在body的末尾，这样就不会对DOM和CSSOM的构建进行干扰，让它们并行尽快完成；放在下面还有一个好处就是不通过<code>document.ready</code>事件也能直接引用所有DOM元素。</p><h4 id="说说defer和async"><a href="#说说defer和async" class="headerlink" title="说说defer和async"></a>说说defer和async</h4><p>前面说的html block on js中的js值的是<em>sync js</em>，js可以加上defer或async属性，大家应该都听说过，这里我们详细比较下这2个属性，首先它们有一个共同点：<strong>不会阻塞html的解析</strong>，不同点如下：</p><ul><li>defer js的执行在DOM和<strong>CSSOM</strong>全部构建完之后立即<em>按顺序执行</em>，而async js在加载完后马上执行，但是不保证执行顺序</li><li>DOMContentLoaded(DCL)在defer js执行完后再触发，而async js的执行和DCL触发时机无关。使用async js的话，DCL一般在DOM构建完后马上触发</li></ul><p>由此可见，如果不考虑js执行顺序，应该优先使用async js</p><h4 id="使用chrome-devtool中的Audits查看页面crp"><a href="#使用chrome-devtool中的Audits查看页面crp" class="headerlink" title="使用chrome devtool中的Audits查看页面crp"></a>使用chrome devtool中的Audits查看页面crp</h4><p>我们分别使用sync js，defer js，async js来测试下网页的渲染过程，特别是crp，页面如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>crp test - async<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;measureCRP()&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;awesome-photo.jpg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">&lt;!-- 分别使用defer，async测试 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;timing.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><a href="../labs/crp/crp-test-sync.html">sync js(默认行为)</a>：</p><p><img src="/../images/1537520189100.png" alt="1537520189100"></p><p>可以看到js在crp中，且html经过了2次parse，中间被sync js阻塞了：</p><p><img src="/../images/1537520778480.png" alt="1537520778480"></p><p>DCL(蓝线)也在js之后触发</p></li><li><p><a href="../labs/crp/crp-test-defer.html">defer js</a></p><p><img src="/../images/1537520878367.png" alt="1537520878367"></p><p>js不在crp中，但是DCL依然在js之后触发：</p><p><img src="/../images/1537520964513.png" alt="1537520964513"></p></li><li><p><a href="../labs/crp/crp-test-async.html">async js</a></p><p><img src="/../images/1537520994931.png" alt="1537520994931"></p><p>js不在crp中，和预想的一样，且DCL也在js执行之前触发：</p><p><img src="/../images/1537521049196.png" alt="1537521049196"></p><p>DCL在html parse完之后马上触发了</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>想要提高页面加载和渲染速度，让用户尽快看到内容并交互，必须尽量减少crp的总体时间，控制crp中的资源数量</p><p>参考：</p><p><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/">https://developers.google.com/web/fundamentals/performance/critical-rendering-path/</a></p><p><a href="https://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/">https://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;web性能分析通常都是基本理论+反复实践，没有一套统一的标准或方法。以我的经验来看，我们或多或少都知道一些或几点相关理论，但都是很片段很零碎的，不太好总结或关联起来。本文尝试在&lt;code&gt;critical render path&lt;/code&gt;(后简称crp)上做一个分析总结</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="performance" scheme="http://tomwang1013.github.io/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>浏览器渲染性能分析总结</title>
    <link href="http://tomwang1013.github.io/rendering/"/>
    <id>http://tomwang1013.github.io/rendering/</id>
    <published>2018-08-22T04:49:24.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章的主要素材来源于google开发文档：<a href="https://developers.google.com/web/fundamentals/performance/rendering/%EF%BC%8C%E7%AE%97%E6%98%AF%E5%81%9A%E4%B8%80%E4%B8%AA%E6%80%BB%E7%BB%93%E5%86%8D%E5%8A%A0%E4%B8%8A%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%EF%BC%8C%E5%81%9A%E4%B8%80%E4%B8%AA%E5%A4%87%E5%BF%98%E5%BD%95">https://developers.google.com/web/fundamentals/performance/rendering/，算是做一个总结再加上自己的一些理解，做一个备忘录</a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>显示器是以一个固定速度刷新屏幕的，一般是每秒60帧，我们可以想象浏览器里面有一个保存当前浏览器内容的渲染缓存，有一个独立的线程每隔大约16.6ms从这个缓存中把浏览器内容刷新到屏幕上，而浏览器的渲染便是刷新这个缓存。</p><p>浏览器绘制一帧主要需要经过下面5步：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1537324920067.png" alt="1537324920067" title="">                </div>                <div class="image-caption">1537324920067</div>            </figure><ul><li><p>javascript</p><p>在javascript中可以做一些引起视觉变化的动作，如修改样式、操作dom等</p></li><li><p>style</p><p>这一步主要是根据选择器重新计算元素的最终的css样式，看哪些元素的样式发生了变化</p></li><li><p>layout</p><p>这个阶段计算元素几何布局的变化，如位置、大小等。值的注意的是，一个元素layout的变化可能会导致其他元素的连锁变化</p></li><li><p>paint</p><p>这一步就是绘制了：根据元素的位置、大小、样式进行绘制。一般来说，浏览器是分层(layer)绘制的，不同的元素可能被绘制到不同的层上</p></li><li><p>composite</p><p>这一步把绘制好的层根据层级关系(如z-index)组装起来</p></li></ul><p>不是每次重绘(update rendering)都会经过这完整的5步，这又分三种情况：</p><ul><li><p>修改layout相关属性，如width，这种情况下需要经过完整的步骤</p></li><li><p>修改的属性和layout无关，如边框颜色，这种情况下不需要重新计算layout，只需要重绘</p><p><img src="/../images/1537326874563.png" alt="1537326874563"></p></li><li><p>有些属性的修改甚至都不需要重绘，直接组装即可</p><p><img src="/../images/1537326942439.png" alt="1537326942439"></p><p>所以做视觉变化时我们应该优先使用这种属性</p></li></ul><p>下面我们依次分析每一步在性能优化时该注意哪些东西</p><h2 id="优化javascript的执行"><a href="#优化javascript的执行" class="headerlink" title="优化javascript的执行"></a>优化javascript的执行</h2><h3 id="避免js执行时间太长"><a href="#避免js执行时间太长" class="headerlink" title="避免js执行时间太长"></a>避免js执行时间太长</h3><p>提到js渲染优化，大家都知道一点，就是不要让js执行时间过长以免卡住主线程使得页面不能及时渲染更新，因为上面说的那几步都是在主线程中进行的。这个问题除了优化自身代码外有2种解决办法：</p><ul><li><p>web worker</p><p>比如你要做一个很费时的排序，可以扔给web worker去做，排好序了再返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dataSortWorker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;sort-worker.js&quot;</span>);</span><br><span class="line">dataSortWorker.<span class="title function_">postMesssage</span>(dataToSort);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The main thread is now free to continue working on other things...</span></span><br><span class="line"></span><br><span class="line">dataSortWorker.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="keyword">function</span>(<span class="params">evt</span>) &#123;</span><br><span class="line">   <span class="keyword">var</span> sortedData = evt.<span class="property">data</span>;</span><br><span class="line">   <span class="comment">// Update data on screen...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>任务分解</p><p>如果你的任务实在是要在主线程中做(如需要操作dom)，那么可以把任务分解成很多小步，把每一小步放到<code>requestAnimationRequest</code>(简称<strong>raf</strong>，后面会讲到)中进行，这样就不会阻塞页面的响应与渲染，示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> taskList = <span class="title function_">breakBigTaskIntoMicroTasks</span>(monsterTaskList);</span><br><span class="line"><span class="title function_">requestAnimationFrame</span>(processTaskList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">processTaskList</span>(<span class="params">taskStartTime</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> taskFinishTime;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// Assume the next task is pushed onto a stack.</span></span><br><span class="line">    <span class="keyword">var</span> nextTask = taskList.<span class="title function_">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Process nextTask.</span></span><br><span class="line">    <span class="title function_">processTask</span>(nextTask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Go again if there’s enough time to do the next task.</span></span><br><span class="line">    taskFinishTime = <span class="variable language_">window</span>.<span class="property">performance</span>.<span class="title function_">now</span>();</span><br><span class="line">  &#125; <span class="keyword">while</span> (taskFinishTime - taskStartTime &lt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (taskList.<span class="property">length</span> &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="title function_">requestAnimationFrame</span>(processTaskList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="用requestAnimationRequest来做视觉变化"><a href="#用requestAnimationRequest来做视觉变化" class="headerlink" title="用requestAnimationRequest来做视觉变化"></a>用requestAnimationRequest来做视觉变化</h3><p>前面提到了<code>raf</code>，这里我们正式介绍一下。简单地说，raf中注册的callback会在每一帧绘制开始的时候被调用。这里的<em>每一帧开始</em>可以理解为我们刚开始提到的屏幕以60帧每秒刷新的每一帧的开始，也是上一帧的结束点。就是说，从这个开始点开始，过大约16.6ms，屏幕会再次刷新。所以，你在raf中做的视觉变化(如样式修改，dom操作等)会在下一帧中得到展示(当然这些变化需要在16.6ms之内被浏览器更新)。</p><p>在raf出来之前，我们做视觉修改的时机和屏幕刷新时机是完全独立的，这会导致丢帧的情况，就是我我们的修改不会在下一帧显示出来，而是下下帧才显示出来，比如你用<code>setTimeout</code>在某个时间点做了修改，可能就会出现这种情形：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1537335693692.png" alt="1537335693692" title="">                </div>                <div class="image-caption">1537335693692</div>            </figure><p>如果我们能把js中的视觉修改提前到当前帧的开始处，那就能在下一帧得到展示，而唯一能达到这个目的的做法就是使用raf</p><h2 id="减少样式计算的作用范围及复杂性"><a href="#减少样式计算的作用范围及复杂性" class="headerlink" title="减少样式计算的作用范围及复杂性"></a>减少样式计算的作用范围及复杂性</h2><p>这一节没啥好说的，一是使用简单的选择器，尽量使用class：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">.<span class="property">box</span>:nth-last-<span class="title function_">child</span>(-n+<span class="number">1</span>) .<span class="property">title</span> &#123;</span><br><span class="line">  <span class="comment">/* styles */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">.<span class="property">final</span>-box-title &#123;</span><br><span class="line">  <span class="comment">/* styles */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二是尽量减少需要重新计算样式的元素数量</p><h2 id="避免复杂的布局计算以及布局的反复计算-下面简称布局抖动"><a href="#避免复杂的布局计算以及布局的反复计算-下面简称布局抖动" class="headerlink" title="避免复杂的布局计算以及布局的反复计算(下面简称布局抖动)"></a>避免复杂的布局计算以及布局的反复计算(下面简称布局抖动)</h2><ul><li><p>尽量避免修改元素的布局</p><p>布局计算是重新计算元素的位置及大小，由于元素之间的排版关系紧密，布局计算的范围通常是整个文档：如果文档中的元素很多，这个过程需要花很长时间，所以第一原则是尽量避免修改元素的布局</p></li><li><p>避免强制布局同步(forced synchronous layouts)</p><p>前面提到，一般而言，我们渲染一帧需要经过以下5步：</p><p><img src="/../images/1537347171681.png" alt="1537347171681"></p><p>layout只会计算一次，但是如果我们不注意的话，可能在javascript中就会发生layout计算，这种情况叫<em>强制布局计算</em>，也就是通常所说的<strong>回流</strong>。</p><p>关于布局，我们首先要认识的一件事就是在javascript中可以毫无代价地得到前一帧的布局信息，问题在于，如果你在获取之前改变了元素的样式，这个时候浏览器为了得到元素的最新的布局信息，必须先进行布局计算：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logBoxHeight</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 改变元素样式</span></span><br><span class="line">  box.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&#x27;super-big&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Gets the height of the box in pixels</span></span><br><span class="line">  <span class="comment">// and logs it out - 回流产生</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(box.<span class="property">offsetHeight</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>避免布局抖动(layout thrashing)</p><p>比回流更可怕的是反复回流，看下以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resizeAllParagraphsToMatchBlockWidth</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// Puts the browser into a read-write-read-write cycle.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; paragraphs.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    paragraphs[i].<span class="property">style</span>.<span class="property">width</span> = box.<span class="property">offsetWidth</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次循环中需要得到box的宽度，同时设置其他元素的宽度；在下一次循环时，由于有元素的样式发生了变化，所以为了得到box的新的宽度必须重新计算布局，导致每次循环都要进行回流，这对性能是影响很大的</p></li></ul><h2 id="简化绘制复杂性及减小绘制区域"><a href="#简化绘制复杂性及减小绘制区域" class="headerlink" title="简化绘制复杂性及减小绘制区域"></a>简化绘制复杂性及减小绘制区域</h2><p>绘制一般是整个流程中最费时的一步，且除了<code>transform</code>和<code>opacity</code>属性外(下节会详细讲)，其他css属性的修改都会引起重绘。在重绘不可避免的情况下，可以考虑以下方法来减轻重绘的代价：</p><ul><li><p>将重绘的元素提升到新的层</p><p>前面提到过，浏览器是按层绘制的，绘制好所有层之后再把它们叠加合成生成最终的渲染结果。将重绘的元素提升到单独的层，这样就不会影响其他元素，提高渲染效率，这对那种移动的元素尤其有效。提升到独立的层的最有效的办法是使用<code>will-change</code>属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.moving-element</span> &#123;</span><br><span class="line">  <span class="attribute">will-change</span>: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果浏览器不支持这个属性，可以使用下面的规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.moving-element</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，太多的层也不好，加了之后需要处理验证</p></li><li><p>减小绘制区域</p></li><li><p>减小绘制复杂性</p><p>不用的css样式效果绘制效率不一样，比如说阴影绘制就比背景耗时，在效果相差不大时尽量考虑使用简单的css样式</p></li></ul><h2 id="坚持使用只影响合成的css属性-下面简称”合成相关”-及合理使用渲染层"><a href="#坚持使用只影响合成的css属性-下面简称”合成相关”-及合理使用渲染层" class="headerlink" title="坚持使用只影响合成的css属性(下面简称”合成相关”)及合理使用渲染层"></a>坚持使用只影响合成的css属性(下面简称”合成相关”)及合理使用渲染层</h2><p>上一节提过，有两个属性的修改不会引起重绘，这2个属性就是 transform 和 opacity：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1537350905247.png" alt="1537350905247" title="">                </div>                <div class="image-caption">1537350905247</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1537351412290.png" alt="1537351412290" title="">                </div>                <div class="image-caption">1537351412290</div>            </figure><p>所以在做动画时使用这2个属性是效率最高的：浏览器会把元素临时提升到独立层，不用绘制，直接合成。注意：如果需要将元素永久性地提升到独立层，需要使用上面提到的<code>will-change</code>或<code>transform</code>属性：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1537355072366.png" alt="1537355072366" title="">                </div>                <div class="image-caption">1537355072366</div>            </figure><h2 id="考虑在事件处理中使用防节流机制"><a href="#考虑在事件处理中使用防节流机制" class="headerlink" title="考虑在事件处理中使用防节流机制"></a>考虑在事件处理中使用防节流机制</h2><ul><li><p>避免在事件处理中改变样式</p><p>事件处理是在<code>raf</code>之前执行的，如果你在事件处理中修改了样式，然后在raf中读取了样式，就可能导致前面提到的回流：</p><p><img src="/../images/1537355384983.png" alt="1537355384983"></p><p>所以始终应该在raf中修改样式</p></li><li><p>事件节流</p><p>想scroll，size这种事件触发频率远远大于屏幕刷新频率的，在这种事件处理中做一些视觉变化操作是很浪费资源的，并可能导致界面卡死，解决办法还是一样：使用raf：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">onScroll</span> (evt) &#123;</span><br><span class="line">  <span class="comment">// Store the scroll value for laterz.</span></span><br><span class="line">  lastScrollY = <span class="variable language_">window</span>.<span class="property">scrollY</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prevent multiple rAF callbacks.</span></span><br><span class="line">  <span class="keyword">if</span> (scheduledAnimationFrame)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  scheduledAnimationFrame = <span class="literal">true</span>;</span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(readAndUpdatePage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, onScroll);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文章的主要素材来源于google开发文档：&lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/rendering/%EF%BC%8C%E7%AE%97%E6%98%AF%E5%81%9A</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="performance" scheme="http://tomwang1013.github.io/tags/performance/"/>
    
  </entry>
  
  <entry>
    <title>javascript优化之tree shaking</title>
    <link href="http://tomwang1013.github.io/tree-shaking/"/>
    <id>http://tomwang1013.github.io/tree-shaking/</id>
    <published>2018-08-22T04:49:24.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<p>简单地说，<code>tree shaking</code>就是不要将用不到的代码打包进来，举个例子，下面的文件定义了2个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主模块只用到了其中一个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> util <span class="keyword">from</span> <span class="string">&#x27;util.js&#x27;</span></span><br><span class="line">util.<span class="title function_">f1</span>()</span><br></pre></td></tr></table></figure><p><code>f2</code>虽然没有被用到，但是打包的时候依然会包含进来，导致js文件变大。在webpack中，tree shaking是自动开启的，但是为了让它真正生效，需要你在其他方面稍微配合一下：</p><h3 id="只import你需要的代码"><a href="#只import你需要的代码" class="headerlink" title="只import你需要的代码"></a>只import你需要的代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; f1 &#125; <span class="keyword">from</span> <span class="string">&#x27;util.js&#x27;</span></span><br><span class="line">util.<span class="title function_">f1</span>()</span><br></pre></td></tr></table></figure><h3 id="阻止babel将es6-module编译成commonJS"><a href="#阻止babel将es6-module编译成commonJS" class="headerlink" title="阻止babel将es6 module编译成commonJS"></a>阻止babel将es6 module编译成commonJS</h3><p>webpack的tree shaking只对es6 module其作用，所以我们要阻止babel先做转化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">    [<span class="string">&quot;env&quot;</span>, &#123;</span><br><span class="line">      <span class="string">&quot;modules&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置sideEffects标记"><a href="#设置sideEffects标记" class="headerlink" title="设置sideEffects标记"></a>设置sideEffects标记</h3><p>有些模块的作用不是为了导出东西供其他模块使用，而是在被导入的时候做点其他事(如各种polyfills)，我们称这种模块是有<strong>副作用（side effects）</strong>，这种模块是不能移除的，这就是<code>sideEffects</code>的作用，它用来告诉一个包或项目中哪些文件具有副作用，需要在模块或项目的<code>package.json</code>中指定：</p><ul><li><p>所有文件都没有副作用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;webpack-tree-shaking-example&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sideEffects&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>某些文件具有副作用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;your-project&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sideEffects&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;./src/some-side-effectful-file.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;*.css&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>做到以上几点，webpack的tree shaking就会生效，所以建议一直这样做，可以说百利而无一害</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;简单地说，&lt;code&gt;tree shaking&lt;/code&gt;就是不要将用不到的代码打包进来，举个例子，下面的文件定义了2个函数：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="performance" scheme="http://tomwang1013.github.io/tags/performance/"/>
    
    <category term="webpack" scheme="http://tomwang1013.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Blob类型用法总结</title>
    <link href="http://tomwang1013.github.io/blob/"/>
    <id>http://tomwang1013.github.io/blob/</id>
    <published>2018-08-12T04:49:24.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<p>Blob一般指的是二进制块<code>Binary Large Object</code>的简称，用来存储大块不透明的任何数据，如图片、视频、字符串等等。<code>Blob</code>作为一种js类型，只有下面很少的属性和方法：</p><ul><li><p>属性</p><p><code>size</code>：blob的字节大小</p><p><code>type</code>：blob的<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types">MIME type</a></p></li><li><p>方法</p><p><code>slice</code>：截取blob的一段返回一个新的blob，算是blob的一种创建方法</p></li></ul><h2 id="Blob的构建"><a href="#Blob的构建" class="headerlink" title="Blob的构建"></a>Blob的构建</h2><h3 id="直接构建"><a href="#直接构建" class="headerlink" title="直接构建"></a>直接构建</h3><ul><li><p>Blob构造函数：<code>var aBlob = new Blob( array[, options]);</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aBlob = <span class="keyword">new</span> <span class="title class_">Blob</span>([<span class="string">&#x27;my name&#x27;</span>, <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])], &#123; <span class="attr">type</span>: <span class="string">&#x27;text/plain&#x27;</span> &#125;)</span><br><span class="line">aBlob.<span class="property">size</span> <span class="comment">// 10</span></span><br><span class="line">aBlob.<span class="property">type</span> <span class="comment">// &#x27;text/plain&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>通过BlobBuilder来构建(&#x3D;&#x3D;已废弃，优先选择Blob构造函数&#x3D;&#x3D;)</p></li></ul><h3 id="间接构建"><a href="#间接构建" class="headerlink" title="间接构建"></a>间接构建</h3><ul><li><p>从文件中读取：<code>&lt;input type=&quot;file&quot;&gt;</code></p><p>用户选择文件之后<code>input.files</code>就是一个<code>FileList</code>，里面的元素是<code>File</code>，<code>File</code>是<code>Blob</code>的子类型，具有其他一些额外的属性，如name，lastModifiedDate等：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// Log information about a list of selected files</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">fileinfo</span>(<span class="params">files</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; files.<span class="property">length</span>; i++) &#123; <span class="comment">// files is an array-like object</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> f = files[i];</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">name</span>, <span class="comment">// Name only: no path</span></span></span><br><span class="line"><span class="language-javascript">            f.<span class="property">size</span>, f.<span class="property">type</span>, <span class="comment">// size and type are Blob properties</span></span></span><br><span class="line"><span class="language-javascript">            f.<span class="property">lastModifiedDate</span>); <span class="comment">// another File property</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Allow selection of multiple image files and pass them to fileinfo()--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">accept</span>=<span class="string">&quot;image/*&quot;</span> <span class="attr">multiple</span> <span class="attr">onchange</span>=<span class="string">&quot;fileinfo(this.files)&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>从XHR下载</p><p>可以通过ajax从服务器请求blob类型数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GET the contents of the url as a Blob and pass it to the specified callback.</span></span><br><span class="line"><span class="comment">// This code is untested: no browsers supported this API when it was written.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getBlob</span>(<span class="params">url, callback</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); <span class="comment">// Create new XHR object</span></span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url); <span class="comment">// Specify URL to fetch</span></span><br><span class="line">    xhr.<span class="property">responseType</span> = <span class="string">&quot;blob&quot;</span> <span class="comment">// We&#x27;d like a Blob, please</span></span><br><span class="line">    xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// onload is easier than onreadystatechange</span></span><br><span class="line">    <span class="title function_">callback</span>(xhr.<span class="property">response</span>); <span class="comment">// Pass the blob to our callback</span></span><br><span class="line">    &#125; <span class="comment">// Note .response, not .responseText</span></span><br><span class="line">    xhr.<span class="title function_">send</span>(<span class="literal">null</span>); <span class="comment">// Send the request now</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Blob的使用"><a href="#Blob的使用" class="headerlink" title="Blob的使用"></a>Blob的使用</h2><p>得到一个blob后，该如何使用它呢？</p><h3 id="直接发送给服务器端"><a href="#直接发送给服务器端" class="headerlink" title="直接发送给服务器端"></a>直接发送给服务器端</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;/server&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123; &#125;;</span><br><span class="line">xhr.<span class="title function_">send</span>(blob);</span><br></pre></td></tr></table></figure><h3 id="转化为URL来使用"><a href="#转化为URL来使用" class="headerlink" title="转化为URL来使用"></a>转化为URL来使用</h3><p>blob这个对象不能直接使用，可以转为为一个url，格式为：<code>blob:xxx</code>，使用这个url来引用这个blob。这个格式和<code>data:xxx</code>有点像，但是blob url没有包含任何编码信息，仅仅是作为一个唯一的key来引用这个blob；而data url则是编码后的数据本身。我们使用<code>URL.createObjectURL</code>来做转化，转化后的url可以用在一般的url可以使用的地方，如<code>img.src</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>); <span class="comment">// Create an &lt;img&gt; element</span></span><br><span class="line">img.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(file); <span class="comment">// Use Blob URL with &lt;img&gt;</span></span><br><span class="line">img.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// When it loads</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">width</span> = <span class="number">100</span>; <span class="comment">// adjust its size and</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(<span class="variable language_">this</span>); <span class="comment">// insert into document.</span></span><br><span class="line">    <span class="variable constant_">URL</span>.<span class="title function_">revokeBlobURL</span>(<span class="variable language_">this</span>.<span class="property">src</span>); <span class="comment">// But don&#x27;t leak memory!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用FileReader读取blob的真实内容"><a href="#使用FileReader读取blob的真实内容" class="headerlink" title="使用FileReader读取blob的真实内容"></a>使用FileReader读取blob的真实内容</h3><p>上面提到的url只是一个blob的引用，并不是真实的内容，我们可以使用<code>FileReader</code>通过下面几个方法读取blob的真实内容：</p><ul><li><code>readAsArrayBuffer</code>：将blob读取为ArrayBuffer</li><li><code>readAsDataURL</code>：将blob读取为data url(注意：不是blob url)</li><li><code>readAsText</code>：将blob读取为字符串</li></ul><p>下面是一个读取图片预览的例子，通过<code>readAsDataURL</code>将图片转化为base64编码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">previewFile</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> preview = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> file    = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input[type=file]&#x27;</span>).<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> reader  = <span class="keyword">new</span> <span class="title class_">FileReader</span>();</span><br><span class="line"></span><br><span class="line">  reader.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    preview.<span class="property">src</span> = reader.<span class="property">result</span>;</span><br><span class="line">  &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (file) &#123;</span><br><span class="line">    reader.<span class="title function_">readAsDataURL</span>(file);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Blob一般指的是二进制块&lt;code&gt;Binary Large Object&lt;/code&gt;的简称，用来存储大块不透明的任何数据，如图片、视频、字符串等等。&lt;code&gt;Blob&lt;/code&gt;作为一种js类型，只有下面很少的属性和方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;属性&lt;/</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="html5" scheme="http://tomwang1013.github.io/tags/html5/"/>
    
    <category term="javascript" scheme="http://tomwang1013.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>透视投影解析 - 从建模到像素（WebGL）</title>
    <link href="http://tomwang1013.github.io/webgl-perspect/"/>
    <id>http://tomwang1013.github.io/webgl-perspect/</id>
    <published>2018-07-25T04:49:24.000Z</published>
    <updated>2023-07-18T03:20:12.568Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，在计算机图形学中物体从建模到展示在屏幕上需要经过大概下面几个坐标变换：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="..\images\steps.png" alt="steps" title="">                </div>                <div class="image-caption">steps</div>            </figure><p>我们以一个立方体的绘制来说明这一过程</p><h2 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h2><p>这一步很简单，我们的立方体中心位于坐标系原点，默认情况下，相机也摆放在坐标系原点，和立方体处于同一个坐标系中，且使用的是右手坐标系：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="..\images\default-cube.png" alt="default cube" title="">                </div>                <div class="image-caption">default cube</div>            </figure><h2 id="摆放相机"><a href="#摆放相机" class="headerlink" title="摆放相机"></a>摆放相机</h2><p>立方体建好之后第二个问题就是从哪个方向来观察它，也就是相机的摆放。默认情况下相机位于原点，也就是立方体的中心，且是往Z轴的负方向进行观察，这个时候我们只能看到立方体的后面一面。为了便于观察，我们需要调整相机的位置。我们可以想象相机上面固定住xyz坐标轴，相机移动时，坐标轴也跟着移动。相机摆放完之后，我们要重新计算立方体在新的坐标系下的坐标，观察方向不变，还是沿着新的Z轴负方向：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/default-cube-2.png" alt="default-cube-2" title="">                </div>                <div class="image-caption">default-cube-2</div>            </figure><p>已知原坐标系原点（O）、新坐标系原点（O’），及新坐标系y轴向量，就可以唯一确定这个变换，我们可以用一个函数调用表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新原点：(nOx, nOy, nOz), y轴向量：(upx, upy, upz)</span></span><br><span class="line"><span class="title function_">lookAt</span>(nOx, nOy, nOz, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, upx, upy, upz)</span><br></pre></td></tr></table></figure><p>我们把<code>lookAt</code>确定的矩阵记为<code>Mv</code>,则立方体在新的相机坐标系下的坐标为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np = <span class="title class_">Mv</span> * p</span><br></pre></td></tr></table></figure><h2 id="投影并裁减"><a href="#投影并裁减" class="headerlink" title="投影并裁减"></a>投影并裁减</h2><p>为了清除地看到投影后的图形，我们考虑一种简单的投影情况：相机沿着原Z轴正方向移动10个单位：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">lookAt</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1537254455887.png" alt="1537254455887" title="">                </div>                <div class="image-caption">1537254455887</div>            </figure><p>我们以新的原点为聚焦点做透视投影，以上下裁减面夹角、近裁减面宽高比、近远裁减面距离指定透视投影参数：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1537255932260.png" alt="1537255932260" title="">                </div>                <div class="image-caption">1537255932260</div>            </figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setPerspective</span>(<span class="number">60</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p>大家想想，这个时候我们的立方体在哪里呢？移动相机之后，立方体的前面的z坐标应该变成1 - 10 &#x3D; 9，而后面的z坐标是-1 - 10 &#x3D; -11，下面我们就看看经过这个投影之后，立方体前面在近裁减面上的投影位置及大小，通过简单作图可以看到：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1537257435923.png" alt="1537257435923" title="">                </div>                <div class="image-caption">1537257435923</div>            </figure><p>可以看出立方体前面的成像高度为<code>1/9</code>，而近裁减面的高度为<code>tan(30)</code>，即$\sqrt{3}&#x2F;3$，所以成像高度与近裁减面的高度比为：$\sqrt{3}&#x2F;9$。</p><h2 id="输出到视口"><a href="#输出到视口" class="headerlink" title="输出到视口"></a>输出到视口</h2><p>到最后一步了，我们假设视口是一个<code>400x400</code>的窗口，在WebGL中，即一个canvas：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;webgl&quot;</span> <span class="attr">width</span>=<span class="string">&quot;400&quot;</span> <span class="attr">height</span>=<span class="string">&quot;400&quot;</span>&gt;</span></span><br><span class="line">  Please use a browser that supports &quot;canvas&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们需要把近裁减面映射到这个canvas，按照前面的推算，我们可以得到立方体的前面最终渲染到这个canvas上的高度为$\sqrt{3}&#x2F;9*400$，大概为77个像素，最终的渲染结果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1537258598407.png" alt="1537258598407" title="">                </div>                <div class="image-caption">1537258598407</div>            </figure><p>黑色背景即为整个canvas，通过手动测量，确实是77个像素，说明以上的推算过程是正确的，完整的示例在<a href="../webgl-guide/ch07/HelloCube.html">这里</a>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道，在计算机图形学中物体从建模到展示在屏幕上需要经过大概下面几个坐标变换：&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                   </summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="webgl" scheme="http://tomwang1013.github.io/tags/webgl/"/>
    
  </entry>
  
  <entry>
    <title>promise精髓</title>
    <link href="http://tomwang1013.github.io/promise/"/>
    <id>http://tomwang1013.github.io/promise/</id>
    <published>2018-07-12T04:49:24.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<p>关于promise的教程很多了，个人也看了不少，但心中总是没有一个清晰的脉络，总感觉知识点有点杂乱，希望在这里做个记录，简单清晰全面地总结promise的用法及注意点，不废话不深入，便于查阅</p><h2 id="创建及使用promise"><a href="#创建及使用promise" class="headerlink" title="创建及使用promise"></a>创建及使用promise</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 此函数立即执行</span></span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">if</span> (···) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(value); <span class="comment">// success</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(reason); <span class="comment">// failure</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>promise创建的时候<strong>立即执行参数函数</strong></p><h3 id="promise的状态"><a href="#promise的状态" class="headerlink" title="promise的状态"></a>promise的状态</h3><p>promise有三种状态：</p><ul><li>Pending：代表初始状态，结果未知</li><li>Resolved：结果成功返回(<code>resolve</code>被调用)</li><li>Rejected：计算过程中发生错误(<code>reject</code>被调用<strong>或者</strong>参数函数执行过程中有异常抛出<code>throw</code>)</li></ul><p>如果promise变成Resolved或Rejected，我们称promise已经稳定了(settled)，稳定之后promise的状态不再变化：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../../images/1538204868941.png" alt="1538204868941" title="">                </div>                <div class="image-caption">1538204868941</div>            </figure><h3 id="消费-查询-使用promise"><a href="#消费-查询-使用promise" class="headerlink" title="消费&#x2F;查询&#x2F;使用promise"></a>消费&#x2F;查询&#x2F;使用promise</h3><p>一般都要关心promise的执行结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// onFulfilled处理resolved通知，onRejected处理rejected通知</span></span><br><span class="line">promise.<span class="title function_">then</span>(onFulfilled, onRejected)</span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; <span class="comment">/* fulfillment */</span> &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123; <span class="comment">/* rejection */</span> &#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="function"><span class="params">error</span> =&gt;</span> &#123; <span class="comment">/* rejection */</span> &#125;);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">promise.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123; <span class="comment">/* rejection */</span> &#125;);</span><br></pre></td></tr></table></figure><p>我们可以随时查询promise，无论它当时的状态是否是稳定的</p><h3 id="promise始终是异步的"><a href="#promise始终是异步的" class="headerlink" title="promise始终是异步的"></a>promise始终是异步的</h3><p>即使你查询promise的时候promise的状态已经是稳定的，你传递的通知函数也会被异步调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>).<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(value))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果：</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="其他创建promise的方法"><a href="#其他创建promise的方法" class="headerlink" title="其他创建promise的方法"></a>其他创建promise的方法</h3><h4 id="const-p-Promise-resolve-x"><a href="#const-p-Promise-resolve-x" class="headerlink" title="const p = Promise.resolve(x)"></a><code>const p = Promise.resolve(x)</code></h4><ul><li>x是普通值：p是一个处于Resolved状态且值为x的promise</li><li>x也是通过resolve创建的promise：p &#x3D; x</li><li>x是其他方式创建的promise：p的状态取决于x的状态，就是说你查询p和查询x是等价的</li></ul><h4 id="const-p-Promise-reject-error"><a href="#const-p-Promise-reject-error" class="headerlink" title="const p = Promise.reject(error)"></a><code>const p = Promise.reject(error)</code></h4><p>返回一个处于Rejected状态且错误为error的promise：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myError = <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Problem!&#x27;</span>);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">reject</span>(myError).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err === myError)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="promise链接-Chaining-Promises"><a href="#promise链接-Chaining-Promises" class="headerlink" title="promise链接(Chaining Promises)"></a>promise链接(Chaining Promises)</h2><p>promise的一大优点是可以链接，因为<code>Promise.then</code>的返回值还是一个promise：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> q = p.<span class="title function_">then</span>(onFulfilled, onRejected) <span class="comment">// q is a new promise</span></span><br></pre></td></tr></table></figure><p>所以我们可以继续查询q：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">.<span class="title function_">then</span>(onFulfilled, onRejected)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;&#125;)<span class="comment">// resolved with what is returned by either onFulfilled or onRejected</span></span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span>&#123;&#125;)<span class="comment">// rejected if either onFulfilled or onRejected throw an exception</span></span><br></pre></td></tr></table></figure><h3 id="使用普通值来resolve-q"><a href="#使用普通值来resolve-q" class="headerlink" title="使用普通值来resolve q"></a>使用普通值来resolve q</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;<span class="comment">// q is a promise resolved with 123</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value2</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value2); <span class="comment">// 123</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="使用另一个promise来resolve-q"><a href="#使用另一个promise来resolve-q" class="headerlink" title="使用另一个promise来resolve q"></a>使用另一个promise来resolve q</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> r;<span class="comment">// r is a promise, q = r</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value2</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>resolve promise with normal value or another promise</code>状态示意图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="../images/1538211823168.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="resolve-q-from-onRejected"><a href="#resolve-q-from-onRejected" class="headerlink" title="resolve q from onRejected"></a>resolve q from <code>onRejected</code></h3><p>从<code>onRejected</code>中返回的值一样可以用来resolve(<em>不是reject</em>) q：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Something went wrong, use a default value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Untitled.txt&#x27;</span>;</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">fileName</span>) &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="通过抛出异常来reject-q-这个时候没有reject方法可以调用"><a href="#通过抛出异常来reject-q-这个时候没有reject方法可以调用" class="headerlink" title="通过抛出异常来reject q(这个时候没有reject方法可以调用)"></a>通过抛出异常来reject q(这个时候没有reject方法可以调用)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="comment">// Handle error here</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="错误随链接传递直到catch"><a href="#错误随链接传递直到catch" class="headerlink" title="错误随链接传递直到catch"></a>错误随链接传递直到catch</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">asyncFunc1</span>()</span><br><span class="line">.<span class="title function_">then</span>(asyncFunc2)</span><br><span class="line">.<span class="title function_">then</span>(asyncFunc3)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="comment">// Something went wrong above</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="错误处理要点"><a href="#错误处理要点" class="headerlink" title="错误处理要点"></a>错误处理要点</h2><h3 id="不要使用then方法来捕获错误"><a href="#不要使用then方法来捕获错误" class="headerlink" title="不要使用then方法来捕获错误"></a>不要使用then方法来捕获错误</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Don’t do this</span></span><br><span class="line"><span class="comment">// onRejected能捕获promise抛出的错误，但是不能捕获onFulfilled执行过程中抛出的异常</span></span><br><span class="line">promise.<span class="title function_">then</span>(onFulfilled, onRejected)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更好的做法</span></span><br><span class="line">promise.<span class="title function_">then</span>(onFulfilled).<span class="title function_">catch</span>(onRejected)</span><br></pre></td></tr></table></figure><h3 id="注意区分reject和throw"><a href="#注意区分reject和throw" class="headerlink" title="注意区分reject和throw"></a>注意区分reject和throw</h3><p>一般来说reject抛出的是可预期的操作错误，如文件不存在、网络断开等；而throw抛出的是代码错误，如参数类型错误等</p><h3 id="Promise中抛出的异常不能被try-catch捕获"><a href="#Promise中抛出的异常不能被try-catch捕获" class="headerlink" title="Promise中抛出的异常不能被try-catch捕获"></a>Promise中抛出的异常不能被try-catch捕获</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>).<span class="title function_">then</span>(<span class="function"><span class="params">a</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="string">&#x27;err&#x27;</span> &#125;) </span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">222</span>, e) <span class="comment">// 无法捕获上面的错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="promise组合"><a href="#promise组合" class="headerlink" title="promise组合"></a>promise组合</h2><h3 id="Promise-all-promise1-promise2-…"><a href="#Promise-all-promise1-promise2-…" class="headerlink" title="Promise.all([promise1, promise2, …])"></a>Promise.all([promise1, promise2, …])</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">    <span class="title function_">asyncFunc1</span>(),</span><br><span class="line">    <span class="title function_">asyncFunc2</span>(),</span><br><span class="line">])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">[result1, result2]</span>) =&gt;</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Receives first rejection among the Promises</span></span><br><span class="line">    ···</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise-race-promise1-promise2-…"><a href="#Promise-race-promise1-promise2-…" class="headerlink" title="Promise.race([promise1, promise2, …])"></a>Promise.race([promise1, promise2, …])</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([</span><br><span class="line">    <span class="title function_">httpGet</span>(<span class="string">&#x27;http://example.com/file.txt&#x27;</span>),</span><br><span class="line">    <span class="title function_">delay</span>(<span class="number">5000</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Timed out&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">])</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">text</span>) &#123; ··· &#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">reason</span>) &#123; ··· &#125;);</span><br></pre></td></tr></table></figure><h2 id="两个额外的promise函数"><a href="#两个额外的promise函数" class="headerlink" title="两个额外的promise函数"></a>两个额外的promise函数</h2><h3 id="done"><a href="#done" class="headerlink" title="done()"></a>done()</h3><p>前面说过promise中抛出的异常外界捕获不到，所以我们解决这个问题(始终加上catch也不行，catch中也可能抛出异常)，可以在promise上定义一个<code>done</code>方法，然后跟在promise链最后面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">asyncFunc</span>()</span><br><span class="line">    .<span class="title function_">then</span>(f1)</span><br><span class="line">    .<span class="title function_">catch</span>(r1)</span><br><span class="line">    .<span class="title function_">then</span>(f2)</span><br><span class="line">    .<span class="title function_">done</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以这样来定义done方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">done</span> = <span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">then</span>(onFulfilled, onRejected)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">        <span class="comment">// Throw an exception globally</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="finally"><a href="#finally" class="headerlink" title="finally()"></a>finally()</h3><p>仿造<code>try-catch-finally</code>我们可以在promise上定义一个finally方法，使得无论最后promise状态如何，始终执行一个callback：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">finally</span> = <span class="keyword">function</span> (<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> P = <span class="variable language_">this</span>.<span class="property">constructor</span>;</span><br><span class="line">    <span class="comment">// We don’t invoke the callback in here,</span></span><br><span class="line">    <span class="comment">// because we want then() to handle its exceptions</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">then</span>(</span><br><span class="line">        <span class="comment">// Callback fulfills =&gt; continue with receiver’s fulfillment or rejection</span></span><br><span class="line">        <span class="comment">// Callback rejects =&gt; pass on that rejection (then() has no 2nd parameter!)</span></span><br><span class="line">        <span class="function"><span class="params">value</span>  =&gt;</span> P.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> value),</span><br><span class="line">        <span class="function"><span class="params">reason</span> =&gt;</span> P.<span class="title function_">resolve</span>(<span class="title function_">callback</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;)</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="async-await"><a href="#async-await" class="headerlink" title="async &amp; await"></a>async &amp; await</h2><p>async &amp; await本质上是promise的语法糖，掌握了promise基本知道它们的用法了，这个需要注意的是<strong>async函数始终返回一个promise</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncFunc</span>().<span class="title function_">then</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(x)); <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Problem!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Problem!&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncFunc</span>().<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err)); <span class="comment">// Error: Problem!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// async可可以直接返回另一个promise</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">asyncFunc</span>().<span class="title function_">then</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(x)) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Problem!&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">asyncFunc</span>().<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(err)); <span class="comment">// Error: Problem!</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">otherAsyncFunc</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">otherAsyncFunc</span>()</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result1 = <span class="keyword">await</span> <span class="title function_">otherAsyncFunc1</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result1);</span><br><span class="line">    <span class="keyword">const</span> result2 = <span class="keyword">await</span> <span class="title function_">otherAsyncFunc2</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">otherAsyncFunc1</span>()</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result1</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result1);</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">otherAsyncFunc2</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">result2</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [result1, result2] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">        <span class="title function_">otherAsyncFunc1</span>(),</span><br><span class="line">        <span class="title function_">otherAsyncFunc2</span>(),</span><br><span class="line">    ]);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result1, result2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">        <span class="title function_">otherAsyncFunc1</span>(),</span><br><span class="line">        <span class="title function_">otherAsyncFunc2</span>(),</span><br><span class="line">    ])</span><br><span class="line">    .<span class="title function_">then</span>([result1, result2] =&gt; &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(result1, result2);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 当otherAsyncFunc reject时await语句会抛出异常</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">otherAsyncFunc</span>();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncFunc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">otherAsyncFunc</span>()</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：一个async函数asyncFunc有下面4种调用方法：</p><ul><li>asyncFunc()</li><li>await asyncFunc()</li><li>return asyncFunc()</li><li>return await asyncFunc()</li></ul><p>它们的意义各不相同，参考下面的博文</p><p>参考：</p><p><a href="http://exploringjs.com/es6/ch_promises.html">http://exploringjs.com/es6/ch_promises.html</a></p><p><a href="http://exploringjs.com/es2016-es2017/ch_async-functions.html">http://exploringjs.com/es2016-es2017/ch_async-functions.html</a></p><p><a href="https://jakearchibald.com/2017/await-vs-return-vs-return-await/">https://jakearchibald.com/2017/await-vs-return-vs-return-await/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于promise的教程很多了，个人也看了不少，但心中总是没有一个清晰的脉络，总感觉知识点有点杂乱，希望在这里做个记录，简单清晰全面地总结promise的用法及注意点，不废话不深入，便于查阅&lt;/p&gt;
&lt;h2 id=&quot;创建及使用promise&quot;&gt;&lt;a href=&quot;#创建及使用</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="es6" scheme="http://tomwang1013.github.io/tags/es6/"/>
    
    <category term="promise" scheme="http://tomwang1013.github.io/tags/promise/"/>
    
  </entry>
  
  <entry>
    <title>Promise.race一种变形：any resolve =&gt; resolve, all reject =&gt; reject实现</title>
    <link href="http://tomwang1013.github.io/promise-race-transform/"/>
    <id>http://tomwang1013.github.io/promise-race-transform/</id>
    <published>2018-05-12T04:49:24.000Z</published>
    <updated>2023-07-18T03:20:12.560Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，<code>pr = Promise.race[promises]</code>的意思是promises中任何一个resolve会导致pr变成resolve，任何一个reject会导致pr变成reject，但是有时候我们需要这样的逻辑：resolve和race一样，但是必须是promises中所有的都是reject，pr才变成reject，该怎么办？偶然在网上看到一个实现，很精妙，估记录一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise.race is no good to us because it rejects if</span></span><br><span class="line"><span class="comment">// a promise rejects before fulfilling. Let&#x27;s make a proper</span></span><br><span class="line"><span class="comment">// race function:</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promiseAny</span>(<span class="params">promises</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// make sure promises are all promises</span></span><br><span class="line">    promises = promises.<span class="title function_">map</span>(<span class="function"><span class="params">p</span> =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p));</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// resolve this promise as soon as one resolves</span></span><br><span class="line">    promises.<span class="title function_">forEach</span>(<span class="function"><span class="params">p</span> =&gt;</span> p.<span class="title function_">then</span>(resolve));</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// reject if all promises reject</span></span><br><span class="line">    promises.<span class="title function_">reduce</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="title function_">catch</span>(<span class="function">() =&gt;</span> b))</span><br><span class="line">      .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&quot;All failed&quot;</span>)));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的关键是<code>reduce</code>语句，假设我们传进来的<code>promises</code>是<code>[a, b, c, d]</code>，这条语句等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="title function_">catch</span>(<span class="function">() =&gt;</span> b).<span class="title function_">catch</span>(<span class="function">() =&gt;</span> c).<span class="title function_">catch</span>(<span class="function">() =&gt;</span> d)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">() =&gt;</span> <span class="title function_">reject</span>(<span class="title class_">Error</span>(<span class="string">&quot;All failed&quot;</span>)));</span><br></pre></td></tr></table></figure><p>如果最后一个catch被执行，说明前面所有的catch都被执行了，而前面的catch函数都是返回下一个promise，这说明每个promise都是reject状态</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们知道，&lt;code&gt;pr = Promise.race[promises]&lt;/code&gt;的意思是promises中任何一个resolve会导致pr变成resolve，任何一个reject会导致pr变成reject，但是有时候我们需要这样的逻辑：resolve和race一样</summary>
      
    
    
    
    <category term="programming" scheme="http://tomwang1013.github.io/categories/programming/"/>
    
    
    <category term="es6" scheme="http://tomwang1013.github.io/tags/es6/"/>
    
    <category term="promise" scheme="http://tomwang1013.github.io/tags/promise/"/>
    
  </entry>
  
</feed>
